/* Version: 2.6.0 - June 10, 2025 12:45:43 */
function t$2(t, s, r, i) {
  const n = {
    op: s,
    func: r,
    data: i
  };
  return t.push(n), n;
}
function s$2(t, s) {
  return t;
}
class r$2 {
  constructor() {
    this.program = [];
  }
  test(s, r) {
    return t$2(this.program, 5, s, void 0 === r ? null : r);
  }
  jump(s) {
    return t$2(this.program, 3, null, s);
  }
  record(r, i) {
    return t$2(this.program, 4, void 0 === i ? s$2 : i, r);
  }
  bad(s = 1) {
    return t$2(this.program, 1, null, s);
  }
  accept() {
    return t$2(this.program, 0, null, null);
  }
  fail(s) {
    return t$2(this.program, 2, s || null, null);
  }
}
class i$2 {
  constructor(t, s, r) {
    this.programLength = t, this.maxFromByPc = s, this.maxSurvivorFromByPc = r;
  }
  static fromProgram(t) {
    const s = t.length,
      r = [],
      n = [];
    return t.forEach(t => {
      r.push(0), n.push(0);
    }), t.forEach((t, i) => {
      switch (t.op) {
        case 2:
          if (null === t.func) return;
          if (i + 1 >= s) throw new Error("Invalid program: program could run past end");
          r[i + 1] += 1;
          break;
        case 1:
        case 4:
          if (i + 1 >= s) throw new Error("Invalid program: program could run past end");
          r[i + 1] += 1;
          break;
        case 3:
          t.data.forEach(t => {
            if (t < 0 || t >= s) throw new Error("Invalid program: program could run past end");
            r[t] += 1;
          });
          break;
        case 5:
          if (i + 1 >= s) throw new Error("Invalid program: program could run past end");
          n[i + 1] += 1;
          break;
        case 0:
          n[i] += 1;
      }
    }), new i$2(s, r, n);
  }
  static createStub(t) {
    const s = [],
      r = [];
    for (let i = 0; i < t; ++i) s.push(t), r.push(t);
    return new i$2(t, s, r);
  }
}
class n$2 {
  constructor(t) {
    this.acceptingTraces = t, this.success = t.length > 0;
  }
}
class h$2 {
  constructor(t) {
    this.t = 0, this.i = 0, this.h = new Uint16Array(t), this.l = new Uint8Array(t);
  }
  getBadness(t) {
    return this.l[t];
  }
  add(t, s) {
    this.l[t] = s > 255 ? 255 : s;
    const r = function (t, s, r, i, n) {
      let h = i,
        e = n;
      for (; h < e;) {
        const i = h + e >>> 1;
        r < s[t[i]] ? e = i : h = i + 1;
      }
      return h;
    }(this.h, this.l, s, this.i, this.t);
    this.h.copyWithin(r + 1, r, this.t), this.h[r] = t, this.t += 1;
  }
  reschedule(t, s) {
    const r = Math.max(this.l[t], s > 255 ? 255 : s);
    if (this.l[t] !== r) {
      const s = this.h.indexOf(t, this.i);
      if (s < 0 || s >= this.t) return void (this.l[t] = r);
      this.h.copyWithin(s, s + 1, this.t), this.t -= 1, this.add(t, r);
    }
  }
  getNextPc() {
    return this.i >= this.t ? null : this.h[this.i++];
  }
  reset() {
    this.t = 0, this.i = 0, this.l.fill(0);
  }
}
class e$2 {
  constructor(t) {
    this.o = [];
    let s = t.length;
    t.forEach(t => {
      this.o.push(t > 0 ? s : -1), s += t;
    }), this.u = new Uint16Array(s);
  }
  clear() {
    this.u.fill(0, 0, this.o.length);
  }
  add(t, s) {
    const r = this.u[s],
      i = this.o[s];
    this.u[s] += 1, this.u[i + r] = t;
  }
  has(t) {
    return this.u[t] > 0;
  }
  forEach(t, s) {
    const r = this.u[t],
      i = this.o[t];
    for (let t = i; t < i + r; ++t) s(this.u[t]);
  }
}
function l$2(t, s, r = !1) {
  return null === t ? s : Array.isArray(t) ? (-1 === t.indexOf(s) && (r && (t = t.slice()), t.push(s)), t) : t === s ? t : [t, s];
}
class c$2 {
  constructor(t, s) {
    this.prefixes = t, this.record = s;
  }
}
function o$2(t, s) {
  let r;
  if (null === s) {
    if (!Array.isArray(t)) return t;
    r = t;
  } else r = t === c$2.EMPTY ? [] : Array.isArray(t) ? t : [t];
  return new c$2(r, s);
}
c$2.EMPTY = new c$2([], null);
class u$2 {
  constructor(t) {
    this.p = [], this.v = [];
    for (let s = 0; s < t; ++s) this.p.push(0), this.v.push(null);
  }
  mergeTraces(t, s, r, i, n, h) {
    let e = !1;
    return r.forEach(s, s => {
      const r = this.trace(s, i, n, h);
      var c, o, u;
      o = r, u = e, t = null === (c = t) ? o : null === o ? c : Array.isArray(o) ? o.reduce((t, s) => l$2(t, s, t === o), c) : l$2(c, o, u), e = t === r;
    }), t;
  }
  trace(t, s, r, i) {
    switch (this.p[t]) {
      case 2:
        return this.v[t];
      case 1:
        return null;
    }
    this.p[t] = 1;
    let n = null;
    const h = s[t];
    if (null !== h) n = h;else if (!r.has(t)) throw new Error("Trace without source at pc " + t);
    if (n = this.mergeTraces(n, t, r, s, r, i), null !== n) {
      const s = i[t];
      null !== s && (n = o$2(n, s));
    }
    return this.v[t] = n, this.p[t] = 2, n;
  }
  buildSurvivorTraces(t, s, r, i, n) {
    for (let h = 0, e = t.length; h < e; ++h) {
      if (!r.has(h)) {
        s[h] = null;
        continue;
      }
      this.v.fill(null), this.p.fill(0);
      const e = this.mergeTraces(null, h, r, t, i, n);
      if (null === e) throw new Error("No non-cyclic paths found to survivor " + h);
      s[h] = o$2(e, null);
    }
    this.v.fill(null);
  }
}
class a$2 {
  constructor(t) {
    this.g = [], this.k = [], this.m = [], this.A = new e$2(t.maxFromByPc), this.T = new e$2(t.maxSurvivorFromByPc), this.S = new u$2(t.programLength);
    for (let s = 0; s < t.programLength; ++s) this.g.push(null), this.k.push(null), this.m.push(null);
    this.k[0] = c$2.EMPTY;
  }
  reset(t) {
    this.A.clear(), this.T.clear(), this.g.fill(null), t && (this.k.fill(null), this.m.fill(null), this.k[0] = c$2.EMPTY);
  }
  record(t, s) {
    this.g[t] = s;
  }
  has(t) {
    return this.A.has(t) || null !== this.k[t];
  }
  add(t, s) {
    this.A.add(t, s);
  }
  hasSurvivor(t) {
    return this.T.has(t);
  }
  addSurvivor(t, s) {
    this.T.add(t, s);
  }
  buildSurvivorTraces() {
    const t = this.k;
    this.S.buildSurvivorTraces(t, this.m, this.T, this.A, this.g), this.k = this.m, this.m = t;
  }
  getTraces(t) {
    const s = t.reduce((t, s) => l$2(t, this.k[s]), null);
    return null === s ? [] : Array.isArray(s) ? s : [s];
  }
}
class f$2 {
  constructor(t) {
    this.I = [], this.N = new h$2(t.programLength), this.M = new h$2(t.programLength), this.P = new a$2(t);
  }
  reset() {
    this.N.reset(), this.N.add(0, 0), this.I.length = 0, this.P.reset(!0);
  }
  getNextThreadPc() {
    return this.N.getNextPc();
  }
  step(t, s, r) {
    const i = this.P.has(s);
    this.P.add(t, s);
    const n = this.N.getBadness(t) + r;
    i ? this.N.reschedule(s, n) : this.N.add(s, n);
  }
  stepToNextGeneration(t, s) {
    const r = this.P.hasSurvivor(s);
    this.P.addSurvivor(t, s);
    const i = this.N.getBadness(t);
    r ? this.M.reschedule(s, i) : this.M.add(s, i);
  }
  accept(t) {
    this.I.push(t), this.P.addSurvivor(t, t);
  }
  fail(t) {}
  record(t, s) {
    this.P.record(t, s);
  }
  nextGeneration() {
    this.P.buildSurvivorTraces(), this.P.reset(!1);
    const t = this.N;
    t.reset(), this.N = this.M, this.M = t;
  }
  getAcceptingTraces() {
    return this.P.getTraces(this.I);
  }
}
class d$2 {
  constructor(t) {
    this.U = [], this.G = t, this.V = i$2.fromProgram(t), this.U.push(new f$2(this.V));
  }
  execute(t, s) {
    const r = this.U.pop() || new f$2(this.V);
    r.reset();
    const i = t.length;
    let h,
      e = -1;
    do {
      let n = r.getNextThreadPc();
      if (null === n) break;
      for (++e, h = e >= i ? null : t[e]; null !== n;) {
        const t = this.G[n];
        switch (t.op) {
          case 0:
            null === h ? r.accept(n) : r.fail(n);
            break;
          case 2:
            {
              const i = t.func;
              if (null === i || i(s)) {
                r.fail(n);
                break;
              }
              r.step(n, n + 1, 0);
              break;
            }
          case 1:
            r.step(n, n + 1, t.data);
            break;
          case 5:
            if (null === h) {
              r.fail(n);
              break;
            }
            if (!(0, t.func)(h, t.data, s)) {
              r.fail(n);
              break;
            }
            r.stepToNextGeneration(n, n + 1);
            break;
          case 3:
            {
              const s = t.data,
                i = s.length;
              if (0 === i) {
                r.fail(n);
                break;
              }
              for (let t = 0; t < i; ++t) r.step(n, s[t], 0);
              break;
            }
          case 4:
            {
              const i = (0, t.func)(t.data, e, s);
              null != i && r.record(n, i), r.step(n, n + 1, 0);
              break;
            }
        }
        n = r.getNextThreadPc();
      }
      r.nextGeneration();
    } while (null !== h);
    const l = new n$2(r.getAcceptingTraces());
    return r.reset(), this.U.push(r), l;
  }
}
function w$2(t) {
  const s = new r$2();
  return t(s), new d$2(s.program);
}

function B$1(A) {
  return B => B === A;
}
function a$1(A, B) {
  if (null === A || null === B) throw new Error("unescaped hyphen may not be used as a range endpoint");
  if (B < A) throw new Error("character range is in the wrong order");
  return a => A <= a && a <= B;
}
function n$1(A) {
  return !0;
}
function e$1() {
  return !1;
}
function t$1(A, B) {
  return a => A(a) || B(a);
}
function G$1(A, B) {
  switch (B.kind) {
    case "predicate":
      return void A.test(B.value);
    case "regexp":
      return void r$1(A, B.value, !1);
  }
}
function i$1(A, B) {
  B.forEach(B => {
    !function (A, B) {
      const [a, {
        min: n,
        max: e
      }] = B;
      if (null !== e) {
        for (let B = 0; B < n; ++B) G$1(A, a);
        for (let B = n; B < e; ++B) {
          const B = A.jump([]);
          B.data.push(A.program.length), G$1(A, a), B.data.push(A.program.length);
        }
      } else if (n > 0) {
        for (let B = 0; B < n - 1; ++B) G$1(A, a);
        const B = A.program.length;
        G$1(A, a), A.jump([B]).data.push(A.program.length);
      } else {
        const B = A.program.length,
          n = A.jump([]);
        n.data.push(A.program.length), G$1(A, a), A.jump([B]), n.data.push(A.program.length);
      }
    }(A, B);
  });
}
function r$1(A, B, a) {
  const n = A.program.length,
    e = A.jump([]);
  a && (e.data.push(A.program.length), A.test(() => !0), A.jump([n]));
  const t = [];
  if (B.forEach(B => {
    e.data.push(A.program.length), i$1(A, B), t.push(A.jump([]));
  }), t.forEach(B => {
    B.data.push(A.program.length);
  }), a) {
    const B = A.program.length,
      a = A.jump([]);
    a.data.push(A.program.length), A.test(() => !0), A.jump([B]), a.data.push(A.program.length);
  }
}
function o$1(A, B) {
  return {
    success: !0,
    offset: A,
    value: B
  };
}
function l$1(A) {
  return o$1(A, void 0);
}
function H$1(A, B, a = !1) {
  return {
    success: !1,
    offset: A,
    expected: B,
    fatal: a
  };
}
function C$1(A) {
  return (B, a) => {
    const n = a + A.length;
    return B.slice(a, n) === A ? o$1(n, A) : H$1(a, [A]);
  };
}
function u$1(A, B) {
  return (a, n) => {
    const e = A(a, n);
    return e.success ? o$1(e.offset, B(e.value)) : e;
  };
}
function s$1(A, B, a, n) {
  return (e, t) => {
    const G = A(e, t);
    return G.success ? B(G.value) ? G : H$1(t, a, n) : G;
  };
}
function c$1(A, B) {
  return (a, n) => {
    let e = null;
    for (const t of A) {
      const A = t(a, n);
      if (A.success) return A;
      if (null === e || A.offset > e.offset ? e = A : A.offset === e.offset && void 0 === B && (e.expected = e.expected.concat(A.expected)), A.fatal) return A;
    }
    return B = B || (null == e ? void 0 : e.expected) || [], e && (e.expected = B), e || H$1(n, B);
  };
}
function D$1(A) {
  return (B, a) => {
    const n = A(B, a);
    return n.success || n.fatal ? n : o$1(a, null);
  };
}
function m$1(A) {
  return (B, a) => {
    let n = [],
      e = a;
    for (;;) {
      const a = A(B, e);
      if (!a.success) {
        if (a.fatal) return a;
        break;
      }
      if (n.push(a.value), a.offset === e) break;
      e = a.offset;
    }
    return o$1(e, n);
  };
}
function I$1(A, B, a) {
  return (n, e) => {
    const t = A(n, e);
    if (!t.success) return t;
    const G = B(n, t.offset);
    return G.success ? o$1(G.offset, a(t.value, G.value)) : G;
  };
}
function d$1(A) {
  return I$1(A, m$1(A), (A, B) => [A].concat(B));
}
function h$1(A, B) {
  return A;
}
function p$1(A, B) {
  return B;
}
function T(A, B) {
  return I$1(A, B, p$1);
}
function F$1(A, B) {
  return I$1(A, B, h$1);
}
function E$1(A, B, a, n = !1) {
  return T(A, n ? f$1(F$1(B, a)) : F$1(B, a));
}
function g$1(A, B) {
  return (a, n) => A(a, n).success ? H$1(n, B) : l$1(n);
}
function f$1(A) {
  return (B, a) => {
    const n = A(B, a);
    return n.success ? n : H$1(n.offset, n.expected, !0);
  };
}
const P$1 = (A, B) => A.length === B ? l$1(B) : H$1(B, ["end of input"]);
const M$1 = ["Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Mc", "Me", "Nd", "Nl", "No", "Pc", "Pd", "Ps", "Pe", "Pi", "Pf", "Po", "Zs", "Zl", "Zp", "Sm", "Sc", "Sk", "So", "Cc", "Cf", "Co", "Cn"];
const J$1 = {};
function S$1(A) {
  return A.codePointAt(0);
}
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("").forEach((A, B) => {
  J$1[A] = B;
});
const K$1 = A => -1 === A || -2 === A;
function b$1(A) {
  return B => !K$1(B) && !A(B);
}
function y$1(A, B) {
  return null === B ? A : a => A(a) && !B(a);
}
const Q = function (A, B) {
    const n = new Map();
    let e = 0;
    return A.forEach((A, G) => {
      const i = B[G];
      null !== A && A.split("|").forEach(A => {
        const B = n.get(A),
          G = a$1(e, e + i - 1);
        n.set(A, B ? t$1(B, G) : G);
      }), e += i;
    }), n;
  }(["BasicLatin", "Latin-1Supplement", "LatinExtended-A", "LatinExtended-B", "IPAExtensions", "SpacingModifierLetters", "CombiningDiacriticalMarks", "GreekandCoptic|Greek", "Cyrillic", "CyrillicSupplement", "Armenian", "Hebrew", "Arabic", "Syriac", "ArabicSupplement", "Thaana", "NKo", "Samaritan", "Mandaic", "SyriacSupplement", "ArabicExtended-B", "ArabicExtended-A", "Devanagari", "Bengali", "Gurmukhi", "Gujarati", "Oriya", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhala", "Thai", "Lao", "Tibetan", "Myanmar", "Georgian", "HangulJamo", "Ethiopic", "EthiopicSupplement", "Cherokee", "UnifiedCanadianAboriginalSyllabics", "Ogham", "Runic", "Tagalog", "Hanunoo", "Buhid", "Tagbanwa", "Khmer", "Mongolian", "UnifiedCanadianAboriginalSyllabicsExtended", "Limbu", "TaiLe", "NewTaiLue", "KhmerSymbols", "Buginese", "TaiTham", "CombiningDiacriticalMarksExtended", "Balinese", "Sundanese", "Batak", "Lepcha", "OlChiki", "CyrillicExtended-C", "GeorgianExtended", "SundaneseSupplement", "VedicExtensions", "PhoneticExtensions", "PhoneticExtensionsSupplement", "CombiningDiacriticalMarksSupplement", "LatinExtendedAdditional", "GreekExtended", "GeneralPunctuation", "SuperscriptsandSubscripts", "CurrencySymbols", "CombiningDiacriticalMarksforSymbols|CombiningMarksforSymbols", "LetterlikeSymbols", "NumberForms", "Arrows", "MathematicalOperators", "MiscellaneousTechnical", "ControlPictures", "OpticalCharacterRecognition", "EnclosedAlphanumerics", "BoxDrawing", "BlockElements", "GeometricShapes", "MiscellaneousSymbols", "Dingbats", "MiscellaneousMathematicalSymbols-A", "SupplementalArrows-A", "BraillePatterns", "SupplementalArrows-B", "MiscellaneousMathematicalSymbols-B", "SupplementalMathematicalOperators", "MiscellaneousSymbolsandArrows", "Glagolitic", "LatinExtended-C", "Coptic", "GeorgianSupplement", "Tifinagh", "EthiopicExtended", "CyrillicExtended-A", "SupplementalPunctuation", "CJKRadicalsSupplement", "KangxiRadicals", null, "IdeographicDescriptionCharacters", "CJKSymbolsandPunctuation", "Hiragana", "Katakana", "Bopomofo", "HangulCompatibilityJamo", "Kanbun", "BopomofoExtended", "CJKStrokes", "KatakanaPhoneticExtensions", "EnclosedCJKLettersandMonths", "CJKCompatibility", "CJKUnifiedIdeographsExtensionA", "YijingHexagramSymbols", "CJKUnifiedIdeographs", "YiSyllables", "YiRadicals", "Lisu", "Vai", "CyrillicExtended-B", "Bamum", "ModifierToneLetters", "LatinExtended-D", "SylotiNagri", "CommonIndicNumberForms", "Phags-pa", "Saurashtra", "DevanagariExtended", "KayahLi", "Rejang", "HangulJamoExtended-A", "Javanese", "MyanmarExtended-B", "Cham", "MyanmarExtended-A", "TaiViet", "MeeteiMayekExtensions", "EthiopicExtended-A", "LatinExtended-E", "CherokeeSupplement", "MeeteiMayek", "HangulSyllables", "HangulJamoExtended-B", "HighSurrogates", "HighPrivateUseSurrogates", "LowSurrogates", "PrivateUseArea|PrivateUse", "CJKCompatibilityIdeographs", "AlphabeticPresentationForms", "ArabicPresentationForms-A", "VariationSelectors", "VerticalForms", "CombiningHalfMarks", "CJKCompatibilityForms", "SmallFormVariants", "ArabicPresentationForms-B", "HalfwidthandFullwidthForms", "Specials", "LinearBSyllabary", "LinearBIdeograms", "AegeanNumbers", "AncientGreekNumbers", "AncientSymbols", "PhaistosDisc", null, "Lycian", "Carian", "CopticEpactNumbers", "OldItalic", "Gothic", "OldPermic", "Ugaritic", "OldPersian", null, "Deseret", "Shavian", "Osmanya", "Osage", "Elbasan", "CaucasianAlbanian", "Vithkuqi", null, "LinearA", "LatinExtended-F", null, "CypriotSyllabary", "ImperialAramaic", "Palmyrene", "Nabataean", null, "Hatran", "Phoenician", "Lydian", null, "MeroiticHieroglyphs", "MeroiticCursive", "Kharoshthi", "OldSouthArabian", "OldNorthArabian", null, "Manichaean", "Avestan", "InscriptionalParthian", "InscriptionalPahlavi", "PsalterPahlavi", null, "OldTurkic", null, "OldHungarian", "HanifiRohingya", null, "RumiNumeralSymbols", "Yezidi", "ArabicExtended-C", "OldSogdian", "Sogdian", "OldUyghur", "Chorasmian", "Elymaic", "Brahmi", "Kaithi", "SoraSompeng", "Chakma", "Mahajani", "Sharada", "SinhalaArchaicNumbers", "Khojki", null, "Multani", "Khudawadi", "Grantha", null, "Newa", "Tirhuta", null, "Siddham", "Modi", "MongolianSupplement", "Takri", null, "Ahom", null, "Dogra", null, "WarangCiti", "DivesAkuru", null, "Nandinagari", "ZanabazarSquare", "Soyombo", "UnifiedCanadianAboriginalSyllabicsExtended-A", "PauCinHau", "DevanagariExtended-A", null, "Bhaiksuki", "Marchen", null, "MasaramGondi", "GunjalaGondi", null, "Makasar", "Kawi", null, "LisuSupplement", "TamilSupplement", "Cuneiform", "CuneiformNumbersandPunctuation", "EarlyDynasticCuneiform", null, "Cypro-Minoan", "EgyptianHieroglyphs", "EgyptianHieroglyphFormatControls", null, "AnatolianHieroglyphs", null, "BamumSupplement", "Mro", "Tangsa", "BassaVah", "PahawhHmong", null, "Medefaidrin", null, "Miao", null, "IdeographicSymbolsandPunctuation", "Tangut", "TangutComponents", "KhitanSmallScript", "TangutSupplement", null, "KanaExtended-B", "KanaSupplement", "KanaExtended-A", "SmallKanaExtension", "Nushu", null, "Duployan", "ShorthandFormatControls", null, "ZnamennyMusicalNotation", null, "ByzantineMusicalSymbols", "MusicalSymbols", "AncientGreekMusicalNotation", null, "KaktovikNumerals", "MayanNumerals", "TaiXuanJingSymbols", "CountingRodNumerals", null, "MathematicalAlphanumericSymbols", "SuttonSignWriting", null, "LatinExtended-G", "GlagoliticSupplement", "CyrillicExtended-D", null, "NyiakengPuachueHmong", null, "Toto", "Wancho", null, "NagMundari", null, "EthiopicExtended-B", "MendeKikakui", null, "Adlam", null, "IndicSiyaqNumbers", null, "OttomanSiyaqNumbers", null, "ArabicMathematicalAlphabeticSymbols", null, "MahjongTiles", "DominoTiles", "PlayingCards", "EnclosedAlphanumericSupplement", "EnclosedIdeographicSupplement", "MiscellaneousSymbolsandPictographs", "Emoticons", "OrnamentalDingbats", "TransportandMapSymbols", "AlchemicalSymbols", "GeometricShapesExtended", "SupplementalArrows-C", "SupplementalSymbolsandPictographs", "ChessSymbols", "SymbolsandPictographsExtended-A", "SymbolsforLegacyComputing", null, "CJKUnifiedIdeographsExtensionB", null, "CJKUnifiedIdeographsExtensionC", "CJKUnifiedIdeographsExtensionD", "CJKUnifiedIdeographsExtensionE", "CJKUnifiedIdeographsExtensionF", null, "CJKCompatibilityIdeographsSupplement", null, "CJKUnifiedIdeographsExtensionG", "CJKUnifiedIdeographsExtensionH", null, "Tags", null, "VariationSelectorsSupplement", null, "SupplementaryPrivateUseArea-A|PrivateUse", "SupplementaryPrivateUseArea-B|PrivateUse"], [128, 128, 128, 208, 96, 80, 112, 144, 256, 48, 96, 112, 256, 80, 48, 64, 64, 64, 32, 16, 48, 96, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 256, 160, 96, 256, 384, 32, 96, 640, 32, 96, 32, 32, 32, 32, 128, 176, 80, 80, 48, 96, 32, 32, 144, 80, 128, 64, 64, 80, 48, 16, 48, 16, 48, 128, 64, 64, 256, 256, 112, 48, 48, 48, 80, 64, 112, 256, 256, 64, 32, 160, 128, 32, 96, 256, 192, 48, 16, 256, 128, 128, 256, 256, 96, 32, 128, 48, 80, 96, 32, 128, 128, 224, 16, 16, 64, 96, 96, 48, 96, 16, 32, 48, 16, 256, 256, 6592, 64, 20992, 1168, 64, 48, 320, 96, 96, 32, 224, 48, 16, 64, 96, 32, 48, 48, 32, 96, 32, 96, 32, 96, 32, 48, 64, 80, 64, 11184, 80, 896, 128, 1024, 6400, 512, 80, 688, 16, 16, 16, 32, 32, 144, 240, 16, 128, 128, 64, 80, 64, 48, 128, 32, 64, 32, 48, 32, 48, 32, 64, 32, 80, 48, 48, 80, 48, 64, 80, 64, 384, 64, 64, 64, 32, 32, 48, 48, 32, 32, 32, 64, 32, 96, 96, 32, 32, 32, 64, 64, 32, 32, 48, 80, 80, 48, 128, 64, 288, 32, 64, 64, 48, 64, 64, 48, 32, 128, 80, 48, 80, 48, 96, 32, 80, 48, 48, 80, 128, 128, 128, 96, 160, 128, 96, 32, 80, 48, 80, 176, 80, 80, 96, 96, 64, 96, 80, 96, 16, 64, 96, 160, 112, 80, 64, 96, 80, 304, 32, 96, 80, 16, 64, 1024, 128, 208, 2624, 112, 1072, 48, 4e3, 640, 8576, 576, 48, 96, 48, 144, 688, 96, 96, 160, 64, 32, 6144, 768, 512, 128, 8816, 16, 256, 48, 64, 400, 2304, 160, 16, 4688, 208, 48, 256, 256, 80, 112, 32, 32, 96, 32, 128, 1024, 688, 1104, 256, 48, 96, 112, 80, 320, 48, 64, 464, 48, 736, 32, 224, 32, 96, 784, 80, 64, 80, 176, 256, 256, 48, 112, 96, 256, 256, 768, 80, 48, 128, 128, 128, 256, 256, 112, 144, 256, 1024, 42720, 32, 4160, 224, 5776, 7488, 3088, 544, 1504, 4944, 4192, 711760, 128, 128, 240, 65040, 65536, 65536]),
  x$1 = function (A) {
    const n = new Map(),
      G = A.split(""),
      i = M$1.map(() => []);
    let r = 0,
      o = 0;
    for (; o < G.length;) {
      const A = J$1[G[o]],
        n = (31 & A) - 2;
      let e = 1 + J$1[G[o + 1]];
      switch (32 & A ? (e += J$1[G[o + 2]] << 6, e += J$1[G[o + 3]] << 12, e += J$1[G[o + 4]] << 18, o += 5) : o += 2, n) {
        case -2:
          {
            let A = 0;
            for (let a = r; a < r + e; ++a) {
              i[A].push(B$1(a)), A = (A + 1) % 2;
            }
            break;
          }
        case -1:
          break;
        default:
          {
            const A = i[n];
            1 === e ? A.push(B$1(r)) : A.push(a$1(r, r + e - 1));
            break;
          }
      }
      r += e;
    }
    const l = new Map();
    return M$1.forEach((A, B) => {
      const a = i[B].reduce(t$1, e$1);
      n.set(A, a);
      const G = A.charAt(0),
        r = l.get(G) || [];
      l.set(G, r), r.push(a);
    }), l.forEach((A, B) => {
      n.set(B, A.reduce(t$1, e$1));
    }), n;
  }("bfUATCYATCPAQATAXATAOATBKJTBXCTBCZPATAQAZANAZADZPAXAQAXAbgUATAYDaATAZAaAGARAXAcAaAZAaAXAMBZADATBZAMAGASAMCTACWXACGDXXADHA3DAAPDAAtCAAFDBCAADCAABCCDBCCABCAABCCDCCAABCAAFCAADDAABCAABCBADCBDBGACADCGDCAEADACAEADACAEADAAPDAARDACAEADAABCBA7DFCAABCBDBABCCAJjDBAAGADaFRZDFLZNFEZGFAZAFAZQnvBAAADFAZACADABBFADCTACABDZBCATACCBACABACAABCQBACIDiCADBCCDCAXDDCADAXAABCBDBCyDvAhaAHEJBA1CAANDAgfBAABAClBBFATFDoTAOABBaBYABAHsOAHATAHBTAHBTAHABHGaBDGDTBBKcFXCTBYATBaBHKTAcATCGfFAGJHUKJTDGBHAmiBAATAGAHGcAaAHFFBHBaAHDGBKJGCaBGATNBAcAGAHAGdHaBBmYBAAHKGABNKJGgHIFBaATCFABBHAYBGVHDFAHIFAHCFAHEBBTOBAGYHCBBTABAGKBEGXZAGFBAcBBFHHGoFAHXcAHfIAG1HAIAHAGAICHHIDHAIBGAHGGJHBTBKJTAFAGOHAIBBAGHBBGBBBGVBAGGBAGABCGDBBHAGAICHDBBIBBBIBHAGABHIABDGBBAGCHBBBKJGBYBMFaAYAGATAHABBHBIABAGFBDGBBBGVBAGGBAGBBAGBBAGBBBHABAICHBBDHBBBHCBCHABGGDBAGABGKJHBGCHATABJHBIABAGIBAGCBAGVBAGGBAGBBAGEBBHAGAICHEBAHBIABAIBHABBGABOGBHBBBKJTAYABGGAHFBAHAIBBAGHBBGBBBGVBAGGBAGBBAGEBBHAGAIAHAIAHDBBIBBBIBHABGHBIABDGBBAGCHBBBKJaAGAMFBJHAGABAGFBCGCBAGDBCGBBAGABAGBBCGBBCGCBCGLBDIBHAIBBCICBAICHABBGABFIABNKJMCaFYAaABEHAICHAGHBAGCBAGWBAGPBBHAGAHCIDBAHCBAHDBGHBBAGCBBGABBGBHBBBKJBGTAMGaAGAHAIBTAGHBAGCBAGWBAGJBAGEBBHAGAIAHAIEBAHAIBBAIBHBBGIBBFGBBAGBHBBBKJBAGBIABLHBIBGIBAGCBAGoHBGAICHDBAICBAICHAGAaABDGCIAMGGCHBBBKJMIaAGFBAHAIBBAGRBCGXBAGIBAGABBGGBCHABDICHCBAHABAIHBFKJBBIBTABLGvHAGBHGBDYAGFFAHHTAKJTBBkGBBAGABAGEBAGXBAGABAGJHAGBHIGABBGEBAFABAHGBAKJBBGDBfGAaCTOaATAaCHBaFKJMJaAHAaAHAaAHAPAQAPAQAIBGHBAGjBDHNIAHETAHBGEHKBAHjBAaHHAaFBAaBTEaDTBBkGqIBHDIAHFIAHBIBHBGAKJTFGFIBHBGDHCGAICGBIGGCHDGMHAIBHBIFHAGAIAKJICHAaBClBACABECABBDqTAFADCmIFAABAGDBBGGBAGABAGDBBGoBAGDBBGgBAGDBBGGBAGABAGDBBGOBAG4BAGDBBmCBAABBHCTIMTBCGPaJBFiVBAABBDFBBOAmrJAAaATAGQUAGZPAQABCmKBAATCLCGHBGGRHCIABIGSHBIATBBIGRHBBLGMBAGCBAHBBLGzHBIAHGIHHAIBHKTCFATCYAGAHABBKJBFMJBFTFOATDHCcAHAKJBFGiFAG0BGGEHBGhHAGABEmFBAABJGeBAHCIDHBICBDIBHAIFHCBDaABCTBKJGdBBGEBKGrBDGZBFKJMABCahGWHBIBHABBTBG0IAHAIAHGBAHAIAHAIBHHIFHJBBHAKJBFKJBFTGFATFBBHNJAHPBwHDIAGuHAIAHEIAHAIEHAIBGHBCKJTGaJHIaITBBAHBIAGdIAHDIBHBIAHCGBKJGrHAIAHBICHAIAHCIBBHTDGjIHHHIBHBBCTEKJBCGCKJGdFFTBDIBGCqBBCCTHBHHCTAHMIAHGGDHAGFHAGBIAHBGABEDrF+DMFADhFkH/gVCAADHghBAADHCHDFBBCFBBDHCHDHCHDFBBCFBBDHBACABACABACABACADHCHDNBBDHEHDHEHDHEHDEBADBCDEAZADAZCDCBADBCDEAZCDDBBDBCDBAZCDHCEZCBBDCBADBCDEAZBBAUKcEOFTBRASAPARBSAPARATHVAWAcEUATIRASATDNBTCXAPAQATKXATANATJUAcEBAcJMAFABBMFXCPAQAFAMJXCPAQABAFMBCYgBOHMJDHAJCHLBOaBCAaDCAaBDACCDBCCDAaACAaBXACEaFCAaACAaACAaACDaADACDDAGDDAaBDBCBXECADDaAXAaBDAaAMPLiCADALDMAaBBDXEaEXBaDXAaBXAaBXAaGXAaeXBaBXAaAXAae3LEAAaHPAQAPAQAaTXBaGPAQA6QBAAXAadXYanXF6EBAABYaKBUM76NBAAMV62CAAXAaIXAa1XH6uBAAXA63DAAPAQAPAQAPAQAPAQAPAQAPAQAPAQAMdarXEPAQAXePAQAPAQAPAQAPAQAPAQAXP6/DAA3CCAAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAX+PAQAPAQAXfPAQA3BEAAavXUaBXFamBBafBA6oBAACvDvABCCDBAFCCADDACADFFBCBgjBAADAaFADHCCADABETDMATBDlBADABEDABBG3BGFATABNHAGWBIGGBAGGBAGGBAGGBAGGBAGGBAGGBAGGBAHfTBRASARASATCRASATARASATIOATBOATARASATBRASAPAQAPAQAPAQAPAQATEFATJOBTDOATAPATMaBTCPAQAPAQAPAQAPAQAOABhaZBA6YBAABL6VDAABZaLBDUATCaAFAGALAPAQAPAQAPAQAPAQAPAQAaBPAQAPAQAPAQAPAQAOAPAQBaALIHDIBOAFEaBLCFAGATAaBBAmVBAABBHBZBFBGAOAmZBAATAFCGABEGqBAmdBAABAaBMDaJGfajBLGPaeBAMJadMHaAMOafMJamMO6/EAAm/mBAa/mUIFAFAm2RAABCa2BIGnFFTBmLEAAFATCGPKJGBBTAtGAHAJCTAHJTAFAAbFBHBmFBAALJHBTFBHZWFIZBANDBA9FADHADCAAJFAZBADGAADDBATCDABCDAPCCADBECADABADABADAADBXFCCADAGAFBDAGGHAGCHAGDHAGWIBHBIAaDHABCMFaBYAaABFGzTDBHIBGxIPHBBHTBKJBFHRGFTCGATAGBHAKJGbHHTBGWHKIBBKTAGcBCHCIAGuHAIBHDIBHBICTMBAFAKJBDTBGEHAFAGIKJGEBAGoHFIBHBIBHBBIGCHAGHHAIABBKJBBTDGPFAGFaCGAIAHAIAGxHAGAHCGBHBGEHBGAHAGABXGBFATBGKIAHBIBTBGAFBIAHABJGFBBGFBBGFBIGGBAGGBADqZAFDDIFAZBBDjPBAAGiIBHAIBHAIBTAIAHABBKJBFmjuCABLGWBDGwhDgAA9/jBAmtFAABBmpBAABlDGBLDEBEGAHAGJXAGMBAGEBAGABAGBBAGBBAmrBAAZQBPmqFAAQAPAaPG/BBG1BGaABfGLYAaCHPTGPAQATABFHPTAOBNBPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQATBPAQATDNCTCBATDOAPAQAPAQAPAQATCXAOAXCBATAYATBBDGEBAmGCAABBcABATCYATCPAQATAXATAOATBKJTBXCTBCZPATAQAZANAZADZPAXAQAXAPAQATAPAQATBGJFAGsFBGeBCGFBBGFBBGFBBGCBCYBXAZAaAYBBAaAXDaBBJcCaBBBGLBAGZBAGSBAGBBAGOBBGNBhm6BAABETCBDMsBCaIL0MDaQMBaCBAaMBCaABuasHAhBCAAGcBCGwBOHAMaBDGfMDBIGTLAGHLABEGlHEBEGdBATAGjBDGHTALEBpCnDnmNBAABBKJBFCjBDDjBDGnBHGzBKTACKBACOBACGBACBBADKBADOBADGBADBhCBAAm2EAABIGVBJGHBXFFBAFpBAFIhEBAAGFBBGABAGrBAGBBCGABBGWBATAMHGWaBMGGeBHMIBvGSBAGBBEMEGVMFBCTAGZBETAB/G3BDMBGBMPBBMtGAHCBAHBBEHDGDBAGCBAGcBBHCBDHAMIBGTIBGGcMBTAGcMCBfGHaAGbHBBDMETGBIG1BCTGGVBBMHGSBEMHGRBGTDBLMGhPBAAmIBAAB2CyBMDyBGMFGjHDBHKJhlEAAMeBAGpBAHBOABBGBhKBAAHCGcMJGABHGVHKMDTEBVGRHDTDBlGUMGBTGWBIIAHAIAG0HOTGBDMTKJHAGBHBGABIHCIAGsICHDIBHBTBcATDHABJcABBGYBGKJBFHCGjHEIAHHBAKJTDGAIBGABHGiHATBGABIHBIAGvICHIIBGDTDHDTAIAHAKJGATAGATCBAMTBKGRBAGYICHCIBHAIAHBTFHAGBHAB9GGBAGABAGDBAGOBAGJTABFGuHAICHHBEKJBFHBIBBAGHBBGBBBGVBAGGBAGBBAGEBAHBGAIBHAIDBBIBBBICBBGABFIABEGEIBBBHGBCHEhKCAAG0ICHHIBHCIAHAGDTEKJTBBATAHAGCBdGvICHFIAHAIDHBIAHBGBTAGABHKJhlCAAGuICHDBBIDHBIAHBTWGDHBBhGvICHHIBHAIAHBTCGABKKJBFTMBSGqHAIAHAIBHFIAHAGATABFKJB1GaBBHCIBHDIAHEBDKJMBTCaAGGh4CAAGrICHIIAHBTAhjBAACfDfKJMIBLGHBBGABBGHBAGBBAGXIFBAIBBBHBIAHAGAIAGAIAHATCBIKJhFBAAGHBBGmICHDBBHBIDHAGATAGAIABaGAHJGnHFIAGAHDTHHABHGAHFIBHCGtHMIAHBTCGATEBMmIBAABGTJh1DAAGIBAGkIAHGBAHFIAHAGATEBJKJMSBCTBGdBBHVBAIAHGIAHBIAHBhIBAAGGBAGBBAGlHFBCHABAHBBAHGGAHABHKJBFGFBAGBBAGfIEBAHBBAIBHAIAHAGABGKJh1EAAGSHBIBTBBGHBGAIAGMBAGhIBHEBCIBHAIAHATMKJhVBAAGABOMUaHYDaQBMTAmZOAAhlBAAruBAABATEBKmDDAAhLpAAmgBAATBBMmvQAAcPHAGFHOhp+AAmGJAAh4GCAm4IAABGGeBAKJBDTBmOBAABAKJBFGdBBHETABJGvHGTEaDFDTAaABJKJBAMGBAGUBEGShvKAACfDfMWTDhkBAAmKBAABDHAGAI2BGHDFMB/FBTAFAHABKIBBNm3fBABHmVTAABpGIhmLCAFDBAFGBAFBBAmiEAABOGABcGCBBGABNGDBHmLGAAhDkAAmqBAABEGMBCGIBGGJBBaAHBTAcDhbJBAHtBBHWBI6zBAAB761DAABJamBBa7IBHCaCIFcHHHaBHGadHDa8BU6BBAAHCaAh5BAAMTBLMTBL6WBAABIMYhGCAACZDZCZDGBADRCZDZCABACBBBCABBCBBBCDBACHDDBADABADGBADKCZDZCBBACDBBCHBACGBADZCBBACDBACEBACABCCGBADZCZDZCZDZCZDZCZDZCZDZCZDbBBCYXADYXADFCYXADYXADFCYXADYXADFCYXADYXADFCYXADYXADFCADABBKx6/HAAH2aDHxaHHAaNHAaBTEBOHEBAHOhPRAADJGADTBFDFhUDAAHGBAHQBBHGBAHBBAHEBEF9BgHAhvBAAGsBCHGFGBBKJBDGAaAh/EAAGdHABQGrHDKJBEYAhPHAAGaFAHDKJhlLAAGGBAGDBAGBBAGOBAmEDAABBMIHGBoChDhHGFABDKJBDTBhQMAAM6aAMCYAMDhLBAAMsaAMOhBDAAGDBAGaBAGBBAGABBGABAGJBAGDBAGABAGABFGABDGABAGABAGABAGCBAGBBAGABBGABAGABAGABAGABAGABAGBBAGABBGDBAGGBAGDBAGDBAGABAGJBAGQBEGCBAGEBAGQBzXBhNEAAarBD6jBAABLaOBBaOBAaOBAakBJMM6gCAAB3acBMarBDaIBGaBBNaFhZCAA66DAAZE6XLAABDaQBCaMBC62BAABD6eBAABFaLBDaABOaLBDa3BHaJBFanBHadBBaBhNBAA6TFAABLaNBBaMBCaIBGatBAaGBHaNBDaIBGaIBG6SCAABAa2BkKJhFQAAmfbKABfm5ABABFmdDAABBmBaBABNmw0BAhewAAmdIAAhhXAAmKNBABEmfBBAhQxtCcABd8fBAAh/BAAnvDAAhP4PA99/PABB99/PA");
function L$1(A) {
  return 32 === A || 9 === A || 10 === A || 13 === A;
}
const X = [B$1(S$1(":")), a$1(S$1("A"), S$1("Z")), B$1(S$1("_")), a$1(S$1("a"), S$1("z")), a$1(192, 214), a$1(216, 246), a$1(192, 214), a$1(216, 246), a$1(248, 767), a$1(880, 893), a$1(895, 8191), a$1(8204, 8205), a$1(8304, 8591), a$1(11264, 12271), a$1(12289, 55295), a$1(63744, 64975), a$1(65008, 65533), a$1(65536, 983039)].reduce(t$1),
  Z = [X, B$1(S$1("-")), B$1(S$1(".")), a$1(S$1("0"), S$1("9")), B$1(183), a$1(768, 879), a$1(8255, 8256)].reduce(t$1),
  O = x$1.get("Nd"),
  k$1 = b$1(O),
  N$1 = y$1(a$1(0, 1114111), [x$1.get("P"), x$1.get("Z"), x$1.get("C")].reduce(t$1)),
  v$1 = b$1(N$1);
function w$1(A) {
  return 10 !== A && 13 !== A && !K$1(A);
}
const Y = {
    s: L$1,
    S: b$1(L$1),
    i: X,
    I: b$1(X),
    c: Z,
    C: b$1(Z),
    d: O,
    D: k$1,
    w: N$1,
    W: v$1
  },
  U = C$1("*"),
  j$1 = C$1("\\"),
  R = C$1("{"),
  V = C$1("}"),
  W = C$1("["),
  q$1 = C$1("]"),
  z$1 = C$1("^"),
  $$1 = C$1("$"),
  _ = C$1(","),
  AA = C$1("-"),
  BA = C$1("("),
  aA = C$1(")"),
  nA = C$1("."),
  eA = C$1("|"),
  tA = C$1("+"),
  GA = C$1("?"),
  iA = C$1("-["),
  rA = S$1("0");
function oA(A) {
  function e(A) {
    return new Set(A.split("").map(A => S$1(A)));
  }
  function G(A, B) {
    const a = A.codePointAt(B);
    return void 0 === a ? H$1(B, ["any character"]) : o$1(B + String.fromCodePoint(a).length, a);
  }
  const i = "xpath" === A.language ? T(j$1, c$1([u$1(C$1("n"), () => 10), u$1(C$1("r"), () => 13), u$1(C$1("t"), () => 9), u$1(c$1([j$1, eA, nA, AA, z$1, GA, U, tA, R, V, $$1, BA, aA, W, q$1]), A => S$1(A))])) : T(j$1, c$1([u$1(C$1("n"), () => 10), u$1(C$1("r"), () => 13), u$1(C$1("t"), () => 9), u$1(c$1([j$1, eA, nA, AA, z$1, GA, U, tA, R, V, BA, aA, W, q$1]), A => S$1(A))]));
  function r(A, B) {
    const a = e(B);
    return I$1(C$1(A), D$1(s$1(G, A => a.has(A), B.split(""))), (A, B) => function (A) {
      const B = x$1.get(A);
      if (null == B) throw new Error(A + " is not a valid unicode category");
      return B;
    }(null === B ? A : A + String.fromCodePoint(B)));
  }
  const l = c$1([r("L", "ultmo"), r("M", "nce"), r("N", "dlo"), r("P", "cdseifo"), r("Z", "slp"), r("S", "mcko"), r("C", "cfon")]),
    p = [a$1(S$1("a"), S$1("z")), a$1(S$1("A"), S$1("Z")), a$1(S$1("0"), S$1("9")), B$1(45)].reduce(t$1),
    M = c$1([l, u$1(T(C$1("Is"), function (A) {
      return (B, a) => {
        const n = A(B, a);
        return n.success ? o$1(n.offset, B.slice(a, n.offset)) : n;
      };
    }(d$1(s$1(G, p, ["block identifier"])))), B => function (A, B) {
      const a = Q.get(A);
      if (void 0 === a) {
        if (B) return n$1;
        throw new Error(`The unicode block identifier "${A}" is not known.`);
      }
      return a;
    }(B, "xpath" !== A.language))]),
    J = E$1(C$1("\\p{"), M, V, !0),
    K = u$1(E$1(C$1("\\P{"), M, V, !0), b$1),
    L = T(j$1, u$1(c$1("sSiIcCdDwW".split("").map(A => C$1(A))), A => Y[A])),
    X = u$1(nA, () => w$1),
    Z = c$1([L, J, K]),
    O = e("\\[]"),
    k = c$1([i, s$1(G, A => !O.has(A), ["unescaped character"])]),
    N = c$1([u$1(AA, () => null), k]),
    v = I$1(N, T(AA, N), a$1);
  function oA(A, B) {
    return [A].concat(B || []);
  }
  const lA = u$1(function (A) {
      return (B, a) => {
        const n = A(B, a);
        return n.success ? o$1(a, n.value) : n;
      };
    }(c$1([q$1, iA])), () => null),
    HA = S$1("-"),
    CA = c$1([u$1(F$1(F$1(AA, g$1(W, ["not ["])), lA), () => HA), T(g$1(AA, ["not -"]), k)]),
    uA = c$1([I$1(u$1(CA, B$1), c$1([function (A, B) {
      return uA(A, B);
    }, lA]), oA), I$1(c$1([v, Z]), c$1([cA, lA]), oA)]);
  const sA = c$1([I$1(u$1(k, B$1), c$1([uA, lA]), oA), I$1(c$1([v, Z]), c$1([cA, lA]), oA)]);
  function cA(A, B) {
    return sA(A, B);
  }
  const DA = u$1(sA, A => A.reduce(t$1)),
    mA = u$1(T(z$1, DA), b$1),
    IA = I$1(c$1([T(g$1(z$1, ["not ^"]), DA), mA]), D$1(T(AA, function (A, B) {
      return dA(A, B);
    })), y$1),
    dA = E$1(W, IA, q$1, !0);
  const hA = "xpath" === A.language ? c$1([u$1(i, B$1), Z, dA, X, u$1(z$1, () => A => -1 === A), u$1($$1, () => A => -2 === A)]) : c$1([u$1(i, B$1), Z, dA, X]),
    pA = "xpath" === A.language ? e(".\\?*+{}()|^$[]") : e(".\\?*+{}()|[]"),
    TA = s$1(G, A => !pA.has(A), ["NormalChar"]),
    FA = u$1(T(j$1, I$1(u$1(s$1(G, a$1(S$1("1"), S$1("9")), ["digit"]), A => A - rA), m$1(u$1(s$1(G, a$1(rA, S$1("9")), ["digit"]), A => A - rA)), (A, B) => {
      B.reduce((A, B) => 10 * A + B, A);
    })), A => {
      throw new Error("Backreferences in XPath patterns are not yet implemented.");
    }),
    EA = "xpath" === A.language ? c$1([u$1(TA, A => ({
      kind: "predicate",
      value: B$1(A)
    })), u$1(hA, A => ({
      kind: "predicate",
      value: A
    })), u$1(E$1(BA, T(D$1(C$1("?:")), SA), aA, !0), A => ({
      kind: "regexp",
      value: A
    })), FA]) : c$1([u$1(TA, A => ({
      kind: "predicate",
      value: B$1(A)
    })), u$1(hA, A => ({
      kind: "predicate",
      value: A
    })), u$1(E$1(BA, SA, aA, !0), A => ({
      kind: "regexp",
      value: A
    }))]),
    gA = u$1(d$1(u$1(s$1(G, a$1(rA, S$1("9")), ["digit"]), A => A - rA)), A => A.reduce((A, B) => 10 * A + B)),
    fA = c$1([I$1(gA, T(_, gA), (A, B) => {
      if (B < A) throw new Error("quantifier range is in the wrong order");
      return {
        min: A,
        max: B
      };
    }), I$1(gA, _, A => ({
      min: A,
      max: null
    })), u$1(gA, A => ({
      min: A,
      max: A
    }))]),
    PA = "xpath" === A.language ? I$1(c$1([u$1(GA, () => ({
      min: 0,
      max: 1
    })), u$1(U, () => ({
      min: 0,
      max: null
    })), u$1(tA, () => ({
      min: 1,
      max: null
    })), E$1(R, fA, V, !0)]), D$1(GA), (A, B) => A) : c$1([u$1(GA, () => ({
      min: 0,
      max: 1
    })), u$1(U, () => ({
      min: 0,
      max: null
    })), u$1(tA, () => ({
      min: 1,
      max: null
    })), E$1(R, fA, V, !0)]),
    MA = m$1(I$1(EA, u$1(D$1(PA), A => null === A ? {
      min: 1,
      max: 1
    } : A), (A, B) => [A, B])),
    JA = I$1(MA, m$1(T(eA, f$1(MA))), (A, B) => [A].concat(B));
  function SA(A, B) {
    return JA(A, B);
  }
  const KA = function (A) {
    return I$1(A, P$1, h$1);
  }(JA);
  return function (A) {
    let B;
    try {
      B = KA(A, 0);
    } catch (B) {
      throw new Error(`Error parsing pattern "${A}": ${B instanceof Error ? B.message : B}`);
    }
    return B.success ? B.value : function (A, B, a) {
      const n = a.map(A => `"${A}"`);
      throw new Error(`Error parsing pattern "${A}" at offset ${B}: expected ${n.length > 1 ? "one of " + n.join(", ") : n[0]} but found "${A.slice(B, B + 1)}"`);
    }(A, B.offset, B.expected);
  };
}
function lA(A) {
  return [...A].map(A => A.codePointAt(0));
}
function HA(B, a = {
  language: "xsd"
}) {
  const n = oA(a)(B),
    e = w$2(A => {
      r$1(A, n, "xpath" === a.language), A.accept();
    });
  return function (A) {
    const B = "xpath" === a.language ? [-1, ...lA(A), -2] : lA(A);
    return e.execute(B).success;
  };
}

var xspattern = /*#__PURE__*/Object.freeze({
	__proto__: null,
	compile: HA
});

function n(n, t) {
  return {
    success: !0,
    offset: n,
    value: t
  };
}
function t(t) {
  return n(t, void 0);
}
function e(n, t, e = !1) {
  return {
    success: !1,
    offset: n,
    expected: t,
    fatal: e
  };
}
function r(t) {
  return (r, u) => {
    const o = u + t.length;
    return r.slice(u, o) === t ? n(o, t) : e(u, [t]);
  };
}
function u(n) {
  return n > 65535 ? 2 : 1;
}
function o(n, r) {
  return (o, c) => {
    const f = o.codePointAt(c);
    return void 0 !== f && n(f) ? t(c + u(f)) : e(c, r);
  };
}
function c(n, r) {
  return (u, o) => {
    const c = o;
    for (;;) {
      const t = u.codePointAt(o);
      if (void 0 === t) break;
      if (!n(t)) break;
      o += t > 65535 ? 2 : 1;
    }
    return void 0 !== r && o === c ? e(o, r) : t(o);
  };
}
function f(n, t, e) {
  return o(e => n <= e && e <= t, e || [`${String.fromCodePoint(n)}-${String.fromCodePoint(t)}`]);
}
function s(n) {
  return (r, o) => {
    let c = n;
    for (; c > 0;) {
      const n = r.codePointAt(o);
      if (void 0 === n) return e(o, ["any character"]);
      o += u(n), c -= 1;
    }
    return t(o);
  };
}
function i(t, e) {
  return (r, u) => {
    const o = t(r, u);
    return o.success ? n(o.offset, e(o.value)) : o;
  };
}
function l(n) {
  return i(n, () => {});
}
function a(n, t, r, u) {
  return (o, c) => {
    const f = n(o, c);
    return f.success ? t(f.value) ? f : e(c, r, u) : f;
  };
}
function d(n, t) {
  return (r, u) => {
    let o = null;
    for (const e of n) {
      const n = e(r, u);
      if (n.success) return n;
      if (null === o || n.offset > o.offset ? o = n : n.offset === o.offset && void 0 === t && (o.expected = o.expected.concat(n.expected)), n.fatal) return n;
    }
    return t = t || (null == o ? void 0 : o.expected) || [], o && (o.expected = t), o || e(u, t);
  };
}
function v(t) {
  return (e, r) => {
    const u = t(e, r);
    return u.success || u.fatal ? u : n(r, null);
  };
}
function p(t) {
  return (e, r) => {
    let u = [],
      o = r;
    for (;;) {
      const n = t(e, o);
      if (!n.success) {
        if (n.fatal) return n;
        break;
      }
      if (u.push(n.value), n.offset === o) break;
      o = n.offset;
    }
    return n(o, u);
  };
}
function x(n) {
  return (e, r) => {
    let u = r;
    for (;;) {
      const t = n(e, u);
      if (!t.success) {
        if (t.fatal) return t;
        break;
      }
      if (t.offset === u) break;
      u = t.offset;
    }
    return t(u);
  };
}
function y(n) {
  return i(n, n => n.filter(n => void 0 !== n));
}
function b(t, e, r) {
  return (u, o) => {
    const c = t(u, o);
    if (!c.success) return c;
    const f = e(u, c.offset);
    return f.success ? n(f.offset, r(c.value, f.value)) : f;
  };
}
function h(...t) {
  return (e, r) => {
    const u = [];
    for (const n of t) {
      const t = n(e, r);
      if (!t.success) return t;
      r = t.offset, u.push(t.value);
    }
    return n(r, u);
  };
}
function k(...n) {
  return (e, r) => {
    for (const t of n) {
      const n = t(e, r);
      if (!n.success) return n;
      r = n.offset;
    }
    return t(r);
  };
}
function P(n) {
  return b(n, p(n), (n, t) => [n].concat(t));
}
function g(n, t) {
  return n;
}
function A(n, t) {
  return t;
}
function m(n) {
  return b(n, x(n), A);
}
function C(n, t) {
  return b(n, t, A);
}
function S(n, t) {
  return b(n, t, g);
}
function $(n, t, e, r = !1) {
  return C(n, r ? D(S(t, e)) : S(t, e));
}
function j(t) {
  return (e, r) => {
    const u = t(e, r);
    return u.success ? n(u.offset, e.slice(r, u.offset)) : u;
  };
}
function q(t) {
  return (e, r) => {
    const u = t(e, r);
    return u.success ? n(r, u.value) : u;
  };
}
function w(n, r) {
  return (u, o) => n(u, o).success ? e(o, r) : t(o);
}
function z(n, t, e) {
  return C(w(t, e), n);
}
function B(n, t, r = 0, u = []) {
  return (o, c) => {
    const f = o.codePointAt(c + r);
    if (void 0 === f) return e(c, u);
    const s = n[f];
    return void 0 === s ? void 0 === t ? e(c, u) : t(o, c) : s(o, c);
  };
}
function D(n) {
  return (t, r) => {
    const u = n(t, r);
    return u.success ? u : e(u.offset, u.expected, !0);
  };
}
const E = (n, r) => 0 === r ? t(r) : e(r, ["start of input"]),
  F = (n, r) => n.length === r ? t(r) : e(r, ["end of input"]);
function G(n) {
  return b(n, F, g);
}
function H(n) {
  const t = [];
  let e = n.next();
  for (; !e.done;) t.push(e.value), e = n.next();
  return [t, e.value];
}
function I(n) {
  return function* (t, e) {
    const r = n(t, e);
    return r.success && (yield r.value), r;
  };
}
function J(n, t) {
  return function* (e, r) {
    const u = yield* n(e, r);
    return u.success ? yield* t(e, u.offset) : u;
  };
}
function K(n) {
  return function* (t, e) {
    const r = n(t, e);
    let u = r.next();
    for (; !u.done;) {
      const n = u.value;
      void 0 !== n && (yield n), u = r.next();
    }
    return u.value;
  };
}
function L(n) {
  return function* (e, r) {
    for (;;) {
      const [u, o] = H(n(e, r));
      if (!o.success) return o.fatal ? o : t(r);
      if (yield* u, r === o.offset) return t(r);
      r = o.offset;
    }
  };
}
function M(n) {
  return function* (e, r) {
    const [u, o] = H(n(e, r));
    return o.success ? (yield* u, o) : o.fatal ? o : t(r);
  };
}
function N(n) {
  return function* (t, e) {
    const r = yield* n(t, e);
    return r.success ? F(t, r.offset) : r;
  };
}

var prsc = /*#__PURE__*/Object.freeze({
	__proto__: null,
	codepoint: o,
	codepoints: c,
	collect: H,
	complete: G,
	consume: l,
	cut: D,
	delimited: $,
	dispatch: B,
	end: F,
	error: e,
	except: z,
	filter: a,
	filterUndefined: y,
	first: g,
	followed: S,
	map: i,
	not: w,
	ok: t,
	okWithValue: n,
	optional: v,
	or: d,
	peek: q,
	plus: P,
	plusConsumed: m,
	preceded: C,
	range: f,
	recognize: j,
	second: A,
	sequence: h,
	sequenceConsumed: k,
	skipChars: s,
	star: p,
	starConsumed: x,
	start: E,
	streaming: I,
	streamingComplete: N,
	streamingFilterUndefined: K,
	streamingOptional: M,
	streamingStar: L,
	streamingThen: J,
	then: b,
	token: r
});

const fontoxpath = function (xspattern, prsc) {
  const VERSION = '3.33.0';
  const fontoxpathGlobal = {};
  function aa(a, b) {
    if (!("0" !== a && "-0" !== a || "0" !== b && "-0" !== b)) return 0;
    var c = /(?:\+|(-))?(\d+)?(?:\.(\d+))?/;
    a = c.exec(a + "");
    var d = c.exec(b + ""),
      e = !a[1];
    const f = !d[1];
    b = (a[2] || "").replace(/^0*/, "");
    c = (d[2] || "").replace(/^0*/, "");
    a = a[3] || "";
    d = d[3] || "";
    if (e && !f) return 1;
    if (!e && f) return -1;
    e = e && f;
    if (b.length > c.length) return e ? 1 : -1;
    if (b.length < c.length) return e ? -1 : 1;
    if (b > c) return e ? 1 : -1;
    if (b < c) return e ? -1 : 1;
    b = Math.max(a.length, d.length);
    c = a.padEnd(b, "0");
    b = d.padEnd(b, "0");
    return c > b ? e ? 1 : -1 : c < b ? e ? -1 : 1 : 0;
  }
  function ba(a, b) {
    a = a.toString();
    if (-1 < a.indexOf(".") && 0 === b) return !1;
    a = /^[-+]?0*([1-9]\d*)?(?:\.((?:\d*[1-9])*)0*)?$/.exec(a);
    return a[2] ? a[2].length <= b : !0;
  }
  function da() {
    return function (a, b) {
      return 1 > aa(a, b);
    };
  }
  function fa() {
    return function (a, b) {
      return 0 > aa(a, b);
    };
  }
  function ha() {
    return function (a, b) {
      return -1 < aa(a, b);
    };
  }
  function ia() {
    return function (a, b) {
      return 0 < aa(a, b);
    };
  }
  function ja(a, b) {
    switch (b) {
      case "required":
        return /(Z)|([+-])([01]\d):([0-5]\d)$/.test(a.toString());
      case "prohibited":
        return !/(Z)|([+-])([01]\d):([0-5]\d)$/.test(a.toString());
      case "optional":
        return !0;
    }
  }
  function ka(a) {
    switch (a) {
      case 1:
      case 0:
      case 6:
      case 3:
        return {};
      case 4:
        return {
          ka: ba,
          wa: da(),
          nc: fa(),
          xa: ha(),
          oc: ia()
        };
      case 18:
        return {};
      case 9:
      case 8:
      case 7:
      case 11:
      case 12:
      case 13:
      case 15:
      case 14:
        return {
          Ba: ja
        };
      case 22:
      case 21:
      case 20:
      case 23:
      case 44:
        return {};
      default:
        return null;
    }
  }
  var la = {},
    ma = {};
  function na(a) {
    return /^([+-]?(\d*(\.\d*)?([eE][+-]?\d*)?|INF)|NaN)$/.test(a);
  }
  function oa(a) {
    return /^[_:A-Za-z][-._:A-Za-z0-9]*$/.test(a);
  }
  function pa(a) {
    return oa(a) && /^[_A-Za-z]([-._A-Za-z0-9])*$/.test(a);
  }
  function qa(a) {
    a = a.split(":");
    return 1 === a.length ? pa(a[0]) : 2 !== a.length ? !1 : pa(a[0]) && pa(a[1]);
  }
  function ra(a) {
    return !/[\u0009\u000A\u000D]/.test(a);
  }
  function sa(a) {
    return pa(a);
  }
  const ta = new Map([[45, function () {
    return !0;
  }], [46, function () {
    return !0;
  }], [1, function () {
    return !0;
  }], [0, function (a) {
    return /^(0|1|true|false)$/.test(a);
  }], [6, function (a) {
    return na(a);
  }], [3, na], [4, function (a) {
    return /^[+-]?\d*(\.\d*)?$/.test(a);
  }], [18, function (a) {
    return /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.test(a);
  }], [9, function (a) {
    return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [8, function (a) {
    return /^(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [7, function (a) {
    return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [11, function (a) {
    return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [12, function (a) {
    return /^-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [13, function (a) {
    return /^--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [15, function (a) {
    return /^---(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [14, function (a) {
    return /^--(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a);
  }], [22, function (a) {
    return /^([0-9A-Fa-f]{2})*$/.test(a);
  }], [21, function (a) {
    return new RegExp(/^((([A-Za-z0-9+/] ?){4})*((([A-Za-z0-9+/] ?){3}[A-Za-z0-9+/])|(([A-Za-z0-9+/] ?){2}[AEIMQUYcgkosw048] ?=)|(([A-Za-z0-9+/] ?)[AQgw] ?= ?=)))?$/).test(a);
  }], [20, function () {
    return !0;
  }], [44, qa], [48, ra], [52, function (a) {
    return ra(a) && !/^ | {2,}| $/.test(a);
  }], [51, function (a) {
    return /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/.test(a);
  }], [50, function (a) {
    return /^[-._:A-Za-z0-9]+$/.test(a);
  }], [25, oa], [23, qa], [24, pa], [42, sa], [41, sa], [26, function (a) {
    return pa(a);
  }], [5, function (a) {
    return /^[+-]?\d+$/.test(a);
  }], [16, function (a) {
    return /^-?P[0-9]+(Y([0-9]+M)?|M)$/.test(a);
  }], [17, function (a) {
    return /^-?P([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9]+)?S)?)?$/.test(a);
  }]]);
  var ua = Object.create(null);
  [{
    C: 0,
    name: 59
  }, {
    C: 0,
    name: 46,
    parent: 59,
    K: {
      whiteSpace: "preserve"
    }
  }, {
    C: 0,
    name: 19,
    parent: 46
  }, {
    C: 0,
    name: 1,
    parent: 46
  }, {
    C: 0,
    name: 0,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 4,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 6,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 3,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 18,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 9,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 8,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 7,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 11,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 12,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 13,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 15,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 14,
    parent: 46,
    K: {
      Ba: "optional",
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 22,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 21,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 20,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 23,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 44,
    parent: 46,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 10,
    S: 9,
    K: {
      whiteSpace: "collapse",
      Ba: "required"
    }
  }, {
    C: 1,
    name: 48,
    S: 1,
    K: {
      whiteSpace: "replace"
    }
  }, {
    C: 1,
    name: 52,
    S: 48,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 51,
    S: 52,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 50,
    S: 52,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 2,
    name: 49,
    type: 50,
    K: {
      minLength: 1,
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 25,
    S: 52,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 24,
    S: 25,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 42,
    S: 24,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 41,
    S: 24,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 2,
    name: 43,
    type: 41,
    K: {
      minLength: 1,
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 26,
    S: 24,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 2,
    name: 40,
    type: 26,
    K: {
      minLength: 1,
      whiteSpace: "collapse"
    }
  }, {
    C: 0,
    name: 5,
    parent: 4,
    K: {
      ka: 0,
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 27,
    S: 5,
    K: {
      ka: 0,
      wa: "0",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 28,
    S: 27,
    K: {
      ka: 0,
      wa: "-1",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 31,
    S: 5,
    K: {
      ka: 0,
      wa: "9223372036854775807",
      xa: "-9223372036854775808",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 32,
    S: 31,
    K: {
      ka: 0,
      wa: "2147483647",
      xa: "-2147483648",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 33,
    S: 32,
    K: {
      ka: 0,
      wa: "32767",
      xa: "-32768",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 34,
    S: 33,
    K: {
      ka: 0,
      wa: "127",
      xa: "-128",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 30,
    S: 5,
    K: {
      ka: 0,
      xa: "0",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 36,
    S: 30,
    K: {
      ka: 0,
      wa: "18446744073709551615",
      xa: "0",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 35,
    S: 36,
    K: {
      ka: 0,
      wa: "4294967295",
      xa: "0",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 38,
    S: 35,
    K: {
      ka: 0,
      wa: "65535",
      xa: "0",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 37,
    S: 38,
    K: {
      ka: 0,
      wa: "255",
      xa: "0",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 29,
    S: 30,
    K: {
      ka: 0,
      xa: "1",
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 16,
    S: 18,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 17,
    S: 18,
    K: {
      whiteSpace: "collapse"
    }
  }, {
    C: 1,
    name: 60,
    S: 59
  }, {
    C: 3,
    name: 39,
    Ca: []
  }, {
    C: 1,
    name: 61,
    S: 60
  }, {
    C: 1,
    name: 62,
    S: 60
  }, {
    C: 0,
    name: 53,
    parent: 59
  }, {
    C: 1,
    name: 54,
    S: 53
  }, {
    C: 1,
    name: 58,
    S: 53
  }, {
    C: 1,
    name: 47,
    S: 53
  }, {
    C: 1,
    name: 56,
    S: 53
  }, {
    C: 1,
    name: 57,
    S: 53
  }, {
    C: 1,
    name: 55,
    S: 53
  }, {
    C: 3,
    name: 2,
    Ca: [4, 5, 6, 3]
  }, {
    C: 3,
    name: 63,
    Ca: []
  }].forEach(a => {
    const b = a.name,
      c = a.K || {};
    switch (a.C) {
      case 0:
        a = a.parent ? ua[a.parent] : null;
        var d = ta.get(b) || null;
        ua[b] = {
          C: 0,
          type: b,
          Ka: c,
          parent: a,
          gb: d,
          Oa: ka(b),
          Ca: []
        };
        break;
      case 1:
        a = ua[a.S];
        d = ta.get(b) || null;
        ua[b] = {
          C: 1,
          type: b,
          Ka: c,
          parent: a,
          gb: d,
          Oa: a.Oa,
          Ca: []
        };
        break;
      case 2:
        ua[b] = {
          C: 2,
          type: b,
          Ka: c,
          parent: ua[a.type],
          gb: null,
          Oa: la,
          Ca: []
        };
        break;
      case 3:
        a = a.Ca.map(e => ua[e]), ua[b] = {
          C: 3,
          type: b,
          Ka: c,
          parent: null,
          gb: null,
          Oa: ma,
          Ca: a
        };
    }
  });
  function g(a, b) {
    if (!ua[b]) throw Error("Unknown type");
    return {
      type: b,
      value: a
    };
  }
  var va = g(!0, 0),
    wa = g(!1, 0);
  var xa = (a = "A wrong argument type was specified in a function call.") => Error(`FORG0006: ${a}`);
  var ya = class {
      constructor(a, b) {
        this.done = a;
        this.value = b;
      }
    },
    p = new ya(!0);
  function q(a) {
    return new ya(!1, a);
  }
  function za(a, b) {
    if (3 === b.C) return !!b.Ca.find(c => za(a, c));
    for (; a;) {
      if (a.type === b.type) return !0;
      if (3 === a.C) return !!a.Ca.find(c => v(c.type, b.type));
      a = a.parent;
    }
    return !1;
  }
  function v(a, b) {
    return a === b ? !0 : za(ua[a], ua[b]);
  }
  var Aa = class {
    constructor(a) {
      this.o = w;
      this.h = a;
      let b = -1;
      this.value = {
        next: () => {
          b++;
          return b >= a.length ? p : q(a[b]);
        }
      };
    }
    hb() {
      return this;
    }
    filter(a) {
      let b = -1;
      return this.o.create({
        next: () => {
          for (b++; b < this.h.length && !a(this.h[b], b, this);) b++;
          return b >= this.h.length ? p : q(this.h[b]);
        }
      });
    }
    first() {
      return this.h[0];
    }
    O() {
      return this.h;
    }
    fa() {
      if (v(this.h[0].type, 53)) return !0;
      throw xa("Cannot determine the effective boolean value of a sequence with a length higher than one.");
    }
    Pa() {
      return this.h.length;
    }
    F() {
      return !1;
    }
    oa() {
      return !1;
    }
    map(a) {
      let b = -1;
      return this.o.create({
        next: () => ++b >= this.h.length ? p : q(a(this.h[b], b, this))
      }, this.h.length);
    }
    N(a) {
      return a(this.h);
    }
    X(a) {
      return a.multiple ? a.multiple(this) : a.default(this);
    }
  };
  var Ba = class {
    constructor() {
      this.value = {
        next: () => p
      };
    }
    hb() {
      return this;
    }
    filter() {
      return this;
    }
    first() {
      return null;
    }
    O() {
      return [];
    }
    fa() {
      return !1;
    }
    Pa() {
      return 0;
    }
    F() {
      return !0;
    }
    oa() {
      return !1;
    }
    map() {
      return this;
    }
    N(a) {
      return a([]);
    }
    X(a) {
      return a.empty ? a.empty(this) : a.default(this);
    }
  };
  var Ca = class {
    constructor(a, b) {
      this.type = a;
      this.value = b;
    }
  };
  const Da = {
      [0]: "xs:boolean",
      [1]: "xs:string",
      [2]: "xs:numeric",
      [3]: "xs:double",
      [4]: "xs:decimal",
      [5]: "xs:integer",
      [6]: "xs:float",
      [7]: "xs:date",
      [8]: "xs:time",
      [9]: "xs:dateTime",
      [10]: "xs:dateTimeStamp",
      [11]: "xs:gYearMonth",
      [12]: "xs:gYear",
      [13]: "xs:gMonthDay",
      [14]: "xs:gMonth",
      [15]: "xs:gDay",
      [16]: "xs:yearMonthDuration",
      [17]: "xs:dayTimeDuration",
      [18]: "xs:duration",
      [19]: "xs:untypedAtomic",
      [20]: "xs:anyURI",
      [21]: "xs:base64Binary",
      [22]: "xs:hexBinary",
      [23]: "xs:QName",
      [24]: "xs:NCName",
      [25]: "xs:Name",
      [26]: "xs:ENTITY",
      [27]: "xs:nonPositiveInteger",
      [28]: "xs:negativeInteger",
      [29]: "xs:positiveInteger",
      [30]: "xs:nonNegativeInteger",
      [31]: "xs:long",
      [32]: "xs:int",
      [33]: "xs:short",
      [34]: "xs:byte",
      [35]: "xs:unsignedInt",
      [36]: "xs:unsignedLong",
      [37]: "xs:unsignedByte",
      [38]: "xs:unsignedShort",
      [39]: "xs:error",
      [40]: "xs:ENTITIES",
      [41]: "xs:IDREF",
      [42]: "xs:ID",
      [43]: "xs:IDREFS",
      [44]: "xs:NOTATION",
      [45]: "xs:anySimpleType",
      [46]: "xs:anyAtomicType",
      [47]: "attribute()",
      [48]: "xs:normalizedString",
      [49]: "xs:NMTOKENS",
      [50]: "xs:NMTOKEN",
      [51]: "xs:language",
      [52]: "xs:token",
      [53]: "node()",
      [54]: "element()",
      [55]: "document-node()",
      [56]: "text()",
      [57]: "processing-instruction()",
      [58]: "comment()",
      [59]: "item()",
      [60]: "function(*)",
      [61]: "map(*)",
      [62]: "array(*)",
      [63]: "none"
    },
    Ea = {
      "xs:boolean": 0,
      "xs:string": 1,
      "xs:numeric": 2,
      "xs:double": 3,
      "xs:decimal": 4,
      "xs:integer": 5,
      "xs:float": 6,
      "xs:date": 7,
      "xs:time": 8,
      "xs:dateTime": 9,
      "xs:dateTimeStamp": 10,
      "xs:gYearMonth": 11,
      "xs:gYear": 12,
      "xs:gMonthDay": 13,
      "xs:gMonth": 14,
      "xs:gDay": 15,
      "xs:yearMonthDuration": 16,
      "xs:dayTimeDuration": 17,
      "xs:duration": 18,
      "xs:untypedAtomic": 19,
      "xs:anyURI": 20,
      "xs:base64Binary": 21,
      "xs:hexBinary": 22,
      "xs:QName": 23,
      "xs:NCName": 24,
      "xs:Name": 25,
      "xs:ENTITY": 26,
      "xs:nonPositiveInteger": 27,
      "xs:negativeInteger": 28,
      "xs:positiveInteger": 29,
      "xs:nonNegativeInteger": 30,
      "xs:long": 31,
      "xs:int": 32,
      "xs:short": 33,
      "xs:byte": 34,
      "xs:unsignedInt": 35,
      "xs:unsignedLong": 36,
      "xs:unsignedByte": 37,
      "xs:unsignedShort": 38,
      "xs:error": 39,
      "xs:ENTITIES": 40,
      "xs:IDREF": 41,
      "xs:ID": 42,
      "xs:IDREFS": 43,
      "xs:NOTATION": 44,
      "xs:anySimpleType": 45,
      "xs:anyAtomicType": 46,
      "attribute()": 47,
      "xs:normalizedString": 48,
      "xs:NMTOKENS": 49,
      "xs:NMTOKEN": 50,
      "xs:language": 51,
      "xs:token": 52,
      "node()": 53,
      "element()": 54,
      "document-node()": 55,
      "text()": 56,
      "processing-instruction()": 57,
      "comment()": 58,
      "item()": 59,
      "function(*)": 60,
      "map(*)": 61,
      "array(*)": 62
    };
  function Ha(a) {
    return 2 === a.g ? Da[a.type] + "*" : 1 === a.g ? Da[a.type] + "+" : 0 === a.g ? Da[a.type] + "?" : Da[a.type];
  }
  function Ia(a) {
    if ("none" === a) throw Error('XPST0051: The type "none" could not be found');
    if (!a.startsWith("xs:") && 0 <= a.indexOf(":")) throw Error(`XPST0081: Invalid prefix for input ${a}`);
    const b = Ea[a];
    if (void 0 === b) throw Error(`XPST0051: The type "${a}" could not be found`);
    return b;
  }
  function Ja(a) {
    switch (a[a.length - 1]) {
      case "*":
        return {
          type: Ia(a.substr(0, a.length - 1)),
          g: 2
        };
      case "?":
        return {
          type: Ia(a.substr(0, a.length - 1)),
          g: 0
        };
      case "+":
        return {
          type: Ia(a.substr(0, a.length - 1)),
          g: 1
        };
      default:
        return {
          type: Ia(a),
          g: 3
        };
    }
  }
  function Ka(a) {
    switch (a) {
      case "*":
        return 2;
      case "?":
        return 0;
      case "+":
        return 1;
      default:
        return 3;
    }
  }
  function La(a) {
    const b = a.value;
    if (v(a.type, 53)) return !0;
    if (v(a.type, 0)) return b;
    if (v(a.type, 1) || v(a.type, 20) || v(a.type, 19)) return 0 !== b.length;
    if (v(a.type, 2)) return !isNaN(b) && 0 !== b;
    throw xa(`Cannot determine the effective boolean value of a value with the type ${Da[a.type]}`);
  }
  function Ma(a, b = 0) {
    a.h = b;
  }
  var Na = class {
    constructor(a, b = null) {
      this.D = w;
      this.value = {
        next: c => {
          if (null !== this.o && this.h >= this.o) return p;
          if (void 0 !== this.v[this.h]) return q(this.v[this.h++]);
          c = a.next(c);
          if (c.done) return this.o = this.h, c;
          if (this.l || 2 > this.h) this.v[this.h] = c.value;
          this.h++;
          return c;
        }
      };
      this.l = !1;
      this.v = [];
      this.h = 0;
      this.o = b;
    }
    hb() {
      return this.D.create(this.O());
    }
    filter(a) {
      let b = -1;
      const c = this.value;
      return this.D.create({
        next: d => {
          b++;
          for (d = c.next(d); !d.done && !a(d.value, b, this);) b++, d = c.next(0);
          return d;
        }
      });
    }
    first() {
      if (void 0 !== this.v[0]) return this.v[0];
      const a = this.value.next(0);
      Ma(this);
      return a.done ? null : a.value;
    }
    O() {
      if (this.h > this.v.length && this.o !== this.v.length) throw Error("Implementation error: Sequence Iterator has progressed.");
      const a = this.value;
      this.l = !0;
      let b = a.next(0);
      for (; !b.done;) b = a.next(0);
      return this.v;
    }
    fa() {
      const a = this.value,
        b = this.h;
      Ma(this);
      var c = a.next(0);
      if (c.done) return Ma(this, b), !1;
      c = c.value;
      if (v(c.type, 53)) return Ma(this, b), !0;
      if (!a.next(0).done) throw xa("Cannot determine the effective boolean value of a sequence with a length higher than one.");
      Ma(this, b);
      return La(c);
    }
    Pa(a = !1) {
      if (null !== this.o) return this.o;
      if (a) return -1;
      a = this.h;
      const b = this.O().length;
      Ma(this, a);
      return b;
    }
    F() {
      return 0 === this.o ? !0 : null === this.first();
    }
    oa() {
      if (null !== this.o) return 1 === this.o;
      var a = this.value;
      const b = this.h;
      Ma(this);
      if (a.next(0).done) return Ma(this, b), !1;
      a = a.next(0);
      Ma(this, b);
      return a.done;
    }
    map(a) {
      let b = 0;
      const c = this.value;
      return this.D.create({
        next: d => {
          d = c.next(d);
          return d.done ? p : q(a(d.value, b++, this));
        }
      }, this.o);
    }
    N(a, b) {
      const c = this.value;
      let d;
      const e = [];
      let f = !0;
      (function () {
        for (let h = c.next(f ? 0 : b); !h.done; h = c.next(b)) f = !1, e.push(h.value);
        d = a(e).value;
      })();
      return this.D.create({
        next: () => d.next(0)
      });
    }
    X(a) {
      let b = null;
      const c = d => {
        b = d.value;
        d = d.Pa(!0);
        -1 !== d && (this.o = d);
      };
      return this.D.create({
        next: d => {
          if (b) return b.next(d);
          if (this.F()) return c(a.empty ? a.empty(this) : a.default(this)), b.next(d);
          if (this.oa()) return c(a.m ? a.m(this) : a.default(this)), b.next(d);
          c(a.multiple ? a.multiple(this) : a.default(this));
          return b.next(d);
        }
      });
    }
  };
  var Oa = class {
    constructor(a) {
      this.v = w;
      this.h = a;
      let b = !1;
      this.value = {
        next: () => {
          if (b) return p;
          b = !0;
          return q(a);
        }
      };
      this.o = null;
    }
    hb() {
      return this;
    }
    filter(a) {
      return a(this.h, 0, this) ? this : this.v.create();
    }
    first() {
      return this.h;
    }
    O() {
      return [this.h];
    }
    fa() {
      null === this.o && (this.o = La(this.h));
      return this.o;
    }
    Pa() {
      return 1;
    }
    F() {
      return !1;
    }
    oa() {
      return !0;
    }
    map(a) {
      return this.v.create(a(this.h, 0, this));
    }
    N(a) {
      return a([this.h]);
    }
    X(a) {
      return a.m ? a.m(this) : a.default(this);
    }
  };
  const Pa = new Ba();
  function Qa(a = null, b = null) {
    if (null === a) return Pa;
    if (Array.isArray(a)) switch (a.length) {
      case 0:
        return Pa;
      case 1:
        return new Oa(a[0]);
      default:
        return new Aa(a);
    }
    return a.next ? new Na(a, b) : new Oa(a);
  }
  var w = {
    create: Qa,
    m: a => new Oa(a),
    empty: () => Qa(),
    aa: () => Qa(va),
    T: () => Qa(wa)
  };
  function Ra(a) {
    const b = [],
      c = a.value;
    return () => {
      let d = 0;
      return w.create({
        next: () => {
          if (void 0 !== b[d]) return b[d++];
          const e = c.next(0);
          return e.done ? e : b[d++] = e;
        }
      });
    };
  }
  var Sa = class {
    constructor(a, b, c) {
      this.namespaceURI = b || null;
      this.prefix = a || "";
      this.localName = c;
    }
    za() {
      return this.prefix ? this.prefix + ":" + this.localName : this.localName;
    }
  };
  function Ua(a, b) {
    const c = a.value,
      d = b.map(e => null === e ? null : Ra(e));
    b = b.reduce((e, f, h) => {
      null === f && e.push(a.o[h]);
      return e;
    }, []);
    b = new Va({
      j: b,
      arity: b.length,
      Ya: !0,
      I: a.I,
      localName: "boundFunction",
      namespaceURI: a.l,
      i: a.s,
      value: function (e, f, h) {
        const k = Array.from(arguments).slice(3),
          l = d.map(n => null === n ? k.shift() : n());
        return c.apply(void 0, [e, f, h].concat(l));
      }
    });
    return w.m(b);
  }
  var Va = class extends Ca {
    constructor({
      j: a,
      arity: b,
      Ya: c = !1,
      I: d = !1,
      localName: e,
      namespaceURI: f,
      i: h,
      value: k
    }) {
      super(60, null);
      this.value = k;
      this.I = d;
      d = -1;
      for (k = 0; k < a.length; k++) 4 === a[k] && (d = k);
      -1 < d && (k = Array(b - (a.length - 1)).fill(a[d - 1]), a = a.slice(0, d).concat(k));
      this.o = a;
      this.v = b;
      this.ia = c;
      this.D = e;
      this.l = f;
      this.s = h;
    }
    Ya() {
      return this.ia;
    }
  };
  function Wa(a, b) {
    const c = [];
    2 !== a && 1 !== a || c.push("type-1-or-type-2");
    c.push(`type-${a}`);
    b && c.push(`name-${b}`);
    return c;
  }
  function Xa(a) {
    const b = a.node.nodeType;
    let c;
    if (2 === b || 1 === b) c = a.node.localName;
    return Wa(b, c);
  }
  function Ya(a) {
    let b = a.nodeType;
    4 === b && (b = 3);
    let c;
    if (2 === b || 1 === b) c = a.localName;
    return Wa(b, c);
  }
  var Za = class {
    getAllAttributes(a, b = null) {
      if (1 !== a.nodeType) return [];
      a = Array.from(a.attributes);
      return null === b ? a : a.filter(c => Ya(c).includes(b));
    }
    getAttribute(a, b) {
      return 1 !== a.nodeType ? null : a.getAttribute(b);
    }
    getChildNodes(a, b = null) {
      a = Array.from(a.childNodes);
      return null === b ? a : a.filter(c => Ya(c).includes(b));
    }
    getData(a) {
      return 2 === a.nodeType ? a.value : a.data;
    }
    getFirstChild(a, b = null) {
      for (a = a.firstChild; a; a = a.nextSibling) if (null === b || Ya(a).includes(b)) return a;
      return null;
    }
    getLastChild(a, b = null) {
      for (a = a.lastChild; a; a = a.previousSibling) if (null === b || Ya(a).includes(b)) return a;
      return null;
    }
    getNextSibling(a, b = null) {
      for (a = a.nextSibling; a; a = a.nextSibling) if (null === b || Ya(a).includes(b)) return a;
      return null;
    }
    getParentNode(a, b = null) {
      return (a = 2 === a.nodeType ? a.ownerElement : a.parentNode) ? null === b || Ya(a).includes(b) ? a : null : null;
    }
    getPreviousSibling(a, b = null) {
      for (a = a.previousSibling; a; a = a.previousSibling) if (null === b || Ya(a).includes(b)) return a;
      return null;
    }
  };
  class $a {
    insertBefore(a, b, c) {
      return a.insertBefore(b, c);
    }
    removeAttributeNS(a, b, c) {
      return a.removeAttributeNS(b, c);
    }
    removeChild(a, b) {
      return a.removeChild(b);
    }
    setAttributeNS(a, b, c, d) {
      a.setAttributeNS(b, c, d);
    }
    setData(a, b) {
      a.data = b;
    }
  }
  var ab = new $a();
  class bb {
    constructor(a) {
      this.h = a;
    }
    insertBefore(a, b, c) {
      return this.h.insertBefore(a, b, c);
    }
    removeAttributeNS(a, b, c) {
      return this.h.removeAttributeNS(a, b, c);
    }
    removeChild(a, b) {
      return this.h.removeChild(a, b);
    }
    setAttributeNS(a, b, c, d) {
      this.h.setAttributeNS(a, b, c, d);
    }
    setData(a, b) {
      this.h.setData(a, b);
    }
  }
  function cb(a) {
    return void 0 !== a.Ra;
  }
  function db(a, b, c) {
    let d = null;
    b && (cb(b.node) ? d = {
      G: b.G,
      offset: c,
      parent: b.node
    } : b.G && (d = b.G));
    return {
      node: a,
      G: d
    };
  }
  function eb(a, b, c = null) {
    return a.getAllAttributes(b.node, c).map(d => db(d, b, d.nodeName));
  }
  function fb(a, b, c) {
    b = b.node;
    return cb(b) ? (a = b.attributes.find(d => c === d.name)) ? a.value : null : (a = a.h.getAttribute(b, c)) ? a : null;
  }
  function hb(a, b, c = null) {
    return a.getChildNodes(b.node, c).map((d, e) => db(d, b, e));
  }
  function ib(a, b) {
    return a.getData(b.node);
  }
  function jb(a, b, c = null) {
    const d = b.node;
    cb(d) ? a = d.childNodes[0] : ((c = a.h.getFirstChild(d, c)) && 10 === c.nodeType && (c = a.h.getNextSibling(c)), a = c);
    return a ? db(a, b, 0) : null;
  }
  function kb(a, b, c = null) {
    var d = b.node;
    cb(d) ? (a = d.childNodes.length - 1, d = d.childNodes[a]) : ((d = a.h.getLastChild(d, c)) && 10 === d.nodeType && (d = a.h.getPreviousSibling(d)), a = a.getChildNodes(b.node, c).length - 1);
    return d ? db(d, b, a) : null;
  }
  function x(a, b, c = null) {
    const d = b.node,
      e = b.G;
    if (e) "number" === typeof e.offset && d === e.parent.childNodes[e.offset] || "string" === typeof e.offset && d === e.parent.attributes.find(f => e.offset === f.nodeName) ? (a = e.parent, b = e.G) : (a = a.getParentNode(d, c), b = e);else {
      if (cb(d)) return null;
      a = a.getParentNode(d, c);
      b = null;
    }
    return a ? {
      node: a,
      G: b
    } : null;
  }
  function lb(a, b, c = null) {
    const d = b.node;
    let e, f, h;
    const k = b.G;
    if (cb(d)) k && (h = k.offset + 1, e = k.parent.childNodes[h]);else if (k) h = k.offset + 1, f = x(a, b, null), e = a.getChildNodes(f.node, c)[h];else {
      for (e = d; e && (!(e = a.h.getNextSibling(e, c)) || 10 === e.nodeType););
      return e ? {
        node: e,
        G: null
      } : null;
    }
    return e ? db(e, f || x(a, b, c), h) : null;
  }
  function mb(a, b, c = null) {
    const d = b.node;
    let e, f;
    const h = b.G;
    let k;
    if (cb(d)) h && (k = h.offset - 1, e = h.parent.childNodes[k]);else if (h) k = h.offset - 1, f = x(a, b, null), e = a.getChildNodes(f.node, c)[k];else {
      for (e = d; e && (!(e = a.h.getPreviousSibling(e, c)) || 10 === e.nodeType););
      return e ? {
        node: e,
        G: null
      } : null;
    }
    return e ? db(e, f || x(a, b, c), k) : null;
  }
  var nb = class {
    constructor(a) {
      this.h = a;
      this.o = [];
    }
    getAllAttributes(a, b = null) {
      return cb(a) ? a.attributes : this.h.getAllAttributes(a, b);
    }
    getChildNodes(a, b = null) {
      b = cb(a) ? a.childNodes : this.h.getChildNodes(a, b);
      return 9 === a.nodeType ? b.filter(c => 10 !== c.nodeType) : b;
    }
    getData(a) {
      return cb(a) ? 2 === a.nodeType ? a.value : a.data : this.h.getData(a) || "";
    }
    getParentNode(a, b = null) {
      return this.h.getParentNode(a, b);
    }
  };
  var ob = (a, b, c, d, e) => e.N(([f]) => d.N(([h]) => {
    const k = f.value;
    if (0 >= k || k > h.h.length) throw Error("FOAY0001: array position out of bounds.");
    return h.h[k - 1]();
  }));
  var pb = class extends Va {
    constructor(a) {
      super({
        value: (b, c, d, e) => ob(b, c, d, w.m(this), e),
        localName: "get",
        namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
        j: [{
          type: 5,
          g: 3
        }],
        arity: 1,
        i: {
          type: 59,
          g: 2
        }
      });
      this.type = 62;
      this.h = a;
    }
  };
  function qb(a) {
    switch (a.node.nodeType) {
      case 2:
        return 47;
      case 1:
        return 54;
      case 3:
      case 4:
        return 56;
      case 7:
        return 57;
      case 8:
        return 58;
      case 9:
        return 55;
      default:
        return 53;
    }
  }
  function rb(a) {
    return {
      type: qb(a),
      value: a
    };
  }
  function A(a, b) {
    a = a.map(c => c.first());
    return b(a);
  }
  function sb(a, b) {
    var c = v(a.type, 1) || v(a.type, 20) || v(a.type, 19),
      d = v(b.type, 1) || v(b.type, 20) || v(b.type, 19);
    if (c && d) return a.value === b.value;
    c = v(a.type, 4) || v(a.type, 3) || v(a.type, 6);
    d = v(b.type, 4) || v(b.type, 3) || v(b.type, 6);
    if (c && d) return isNaN(a.value) && isNaN(b.value) ? !0 : a.value === b.value;
    c = v(a.type, 0) || v(a.type, 22) || v(a.type, 18) || v(a.type, 23) || v(a.type, 44);
    d = v(b.type, 0) || v(b.type, 22) || v(b.type, 18) || v(b.type, 23) || v(b.type, 44);
    return c && d ? a.value === b.value : !1;
  }
  var tb = (a, b, c, d, e) => A([d, e], ([f, h]) => (f = f.h.find(k => sb(k.key, h))) ? f.value() : w.empty());
  var ub = class extends Va {
    constructor(a) {
      super({
        j: [{
          type: 59,
          g: 3
        }],
        arity: 1,
        localName: "get",
        namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
        value: (b, c, d, e) => tb(b, c, d, w.m(this), e),
        i: {
          type: 59,
          g: 2
        }
      });
      this.type = 61;
      this.h = a;
    }
  };
  function vb(a, b) {
    return a.h() === b.h() && a.o() === b.o();
  }
  var wb = class {
    $a() {
      return 0;
    }
    getHours() {
      return 0;
    }
    getMinutes() {
      return 0;
    }
    ab() {
      return 0;
    }
    h() {
      return 0;
    }
    o() {
      return 0;
    }
    getSeconds() {
      return 0;
    }
    bb() {
      return 0;
    }
    na() {
      return !0;
    }
  };
  function xb(a) {
    var b = Math.abs(a.$a()),
      c = Math.abs(a.getHours());
    const d = Math.abs(a.getMinutes());
    a = Math.abs(a.getSeconds());
    b = `${b ? `${b}D` : ""}`;
    c = (c ? `${c}H` : "") + (d ? `${d}M` : "") + (a ? `${a}S` : "");
    return b && c ? `${b}T${c}` : b ? b : c ? `T${c}` : "T0S";
  }
  var yb = class extends wb {
      constructor(a) {
        super();
        if (a > Number.MAX_SAFE_INTEGER || a < Number.MIN_SAFE_INTEGER) throw Error("FODT0002: Number of seconds given to construct DayTimeDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER");
        this.ca = a;
      }
      $a() {
        return Math.trunc(this.ca / 86400);
      }
      getHours() {
        return Math.trunc(this.ca % 86400 / 3600);
      }
      getMinutes() {
        return Math.trunc(this.ca % 3600 / 60);
      }
      o() {
        return this.ca;
      }
      getSeconds() {
        const a = this.ca % 60;
        return Object.is(-0, a) ? 0 : a;
      }
      na() {
        return Object.is(-0, this.ca) ? !1 : 0 <= this.ca;
      }
      toString() {
        return (this.na() ? "P" : "-P") + xb(this);
      }
    },
    zb = (a, b, c, d, e, f) => {
      a = 86400 * a + 3600 * b + 60 * c + d + e;
      return new yb(f || 0 === a ? a : -a);
    },
    Ab = a => (a = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.exec(a)) ? zb(a[4] ? parseInt(a[4], 10) : 0, a[5] ? parseInt(a[5], 10) : 0, a[6] ? parseInt(a[6], 10) : 0, a[7] ? parseInt(a[7], 10) : 0, a[8] ? parseFloat(a[8]) : 0, !a[1]) : null,
    Bb = a => {
      a = /^(Z)|([+-])([01]\d):([0-5]\d)$/.exec(a);
      return "Z" === a[1] ? zb(0, 0, 0, 0, 0, !0) : zb(0, a[3] ? parseInt(a[3], 10) : 0, a[4] ? parseInt(a[4], 10) : 0, 0, 0, "+" === a[2]);
    };
  function Cb(a, b) {
    if (isNaN(b)) throw Error("FOCA0005: Cannot multiply xs:dayTimeDuration by NaN");
    a = a.ca * b;
    if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while multiplying xs:dayTimeDuration");
    return new yb(a < Number.MIN_SAFE_INTEGER || Object.is(-0, a) ? 0 : a);
  }
  function Db(a) {
    return a ? parseInt(a, 10) : null;
  }
  function Eb(a) {
    a += "";
    const b = a.startsWith("-");
    b && (a = a.substring(1));
    return (b ? "-" : "") + a.padStart(4, "0");
  }
  function Fb(a) {
    return (a + "").padStart(2, "0");
  }
  function Hb(a) {
    a += "";
    1 === a.split(".")[0].length && (a = a.padStart(a.length + 1, "0"));
    return a;
  }
  function Ib(a) {
    return 0 === a.getHours() && 0 === a.getMinutes() ? "Z" : (a.na() ? "+" : "-") + Fb(Math.abs(a.getHours())) + ":" + Fb(Math.abs(a.getMinutes()));
  }
  function Jb(a) {
    var b = /^(?:(-?\d{4,}))?(?:--?(\d\d))?(?:-{1,3}(\d\d))?(T)?(?:(\d\d):(\d\d):(\d\d))?(\.\d+)?(Z|(?:[+-]\d\d:\d\d))?$/.exec(a);
    a = b[1] ? parseInt(b[1], 10) : null;
    const c = Db(b[2]),
      d = Db(b[3]),
      e = b[4],
      f = Db(b[5]),
      h = Db(b[6]),
      k = Db(b[7]),
      l = b[8] ? parseFloat(b[8]) : 0;
    b = b[9] ? Bb(b[9]) : null;
    if (a && (-271821 > a || 273860 < a)) throw Error("FODT0001: Datetime year is out of bounds");
    return e ? new Kb(a, c, d, f, h, k, l, b, 9) : null !== f && null !== h && null !== k ? new Kb(1972, 12, 31, f, h, k, l, b, 8) : null !== a && null !== c && null !== d ? new Kb(a, c, d, 0, 0, 0, 0, b, 7) : null !== a && null !== c ? new Kb(a, c, 1, 0, 0, 0, 0, b, 11) : null !== c && null !== d ? new Kb(1972, c, d, 0, 0, 0, 0, b, 13) : null !== a ? new Kb(a, 1, 1, 0, 0, 0, 0, b, 12) : null !== c ? new Kb(1972, c, 1, 0, 0, 0, 0, b, 14) : new Kb(1972, 12, d, 0, 0, 0, 0, b, 15);
  }
  function Lb(a, b) {
    switch (b) {
      case 15:
        return new Kb(1972, 12, a.o, 0, 0, 0, 0, a.Y, 15);
      case 14:
        return new Kb(1972, a.h, 1, 0, 0, 0, 0, a.Y, 14);
      case 12:
        return new Kb(a.v, 1, 1, 0, 0, 0, 0, a.Y, 12);
      case 13:
        return new Kb(1972, a.h, a.o, 0, 0, 0, 0, a.Y, 13);
      case 11:
        return new Kb(a.v, a.h, 1, 0, 0, 0, 0, a.Y, 11);
      case 8:
        return new Kb(1972, 12, 31, a.l, a.s, a.D, a.qa, a.Y, 8);
      case 7:
        return new Kb(a.v, a.h, a.o, 0, 0, 0, 0, a.Y, 7);
      default:
        return new Kb(a.v, a.h, a.o, a.l, a.s, a.D, a.qa, a.Y, 9);
    }
  }
  function Mb(a, b) {
    b = a.Y || b || Bb("Z");
    return new Date(Date.UTC(a.v, a.h - 1, a.o, a.l - b.getHours(), a.s - b.getMinutes(), a.D, 1E3 * a.qa));
  }
  var Kb = class {
    constructor(a, b, c, d, e, f, h, k, l = 9) {
      this.v = a;
      this.h = b;
      this.o = c + (24 === d ? 1 : 0);
      this.l = 24 === d ? 0 : d;
      this.s = e;
      this.D = f;
      this.qa = h;
      this.Y = k;
      this.type = l;
    }
    getDay() {
      return this.o;
    }
    getHours() {
      return this.l;
    }
    getMinutes() {
      return this.s;
    }
    getMonth() {
      return this.h;
    }
    getSeconds() {
      return this.D;
    }
    getYear() {
      return this.v;
    }
    toString() {
      switch (this.type) {
        case 9:
          return Eb(this.v) + "-" + Fb(this.h) + "-" + Fb(this.o) + "T" + Fb(this.l) + ":" + Fb(this.s) + ":" + Hb(this.D + this.qa) + (this.Y ? Ib(this.Y) : "");
        case 7:
          return Eb(this.v) + "-" + Fb(this.h) + "-" + Fb(this.o) + (this.Y ? Ib(this.Y) : "");
        case 8:
          return Fb(this.l) + ":" + Fb(this.s) + ":" + Hb(this.D + this.qa) + (this.Y ? Ib(this.Y) : "");
        case 15:
          return "---" + Fb(this.o) + (this.Y ? Ib(this.Y) : "");
        case 14:
          return "--" + Fb(this.h) + (this.Y ? Ib(this.Y) : "");
        case 13:
          return "--" + Fb(this.h) + "-" + Fb(this.o) + (this.Y ? Ib(this.Y) : "");
        case 12:
          return Eb(this.v) + (this.Y ? Ib(this.Y) : "");
        case 11:
          return Eb(this.v) + "-" + Fb(this.h) + (this.Y ? Ib(this.Y) : "");
      }
      throw Error("Unexpected subType");
    }
  };
  function Nb(a, b, c) {
    const d = Mb(a, c).getTime();
    c = Mb(b, c).getTime();
    return d === c ? a.qa === b.qa ? 0 : a.qa > b.qa ? 1 : -1 : d > c ? 1 : -1;
  }
  function Ob(a, b, c) {
    return 0 === Nb(a, b, c);
  }
  function Pb(a, b, c) {
    a = (Mb(a, c).getTime() - Mb(b, c).getTime()) / 1E3;
    return new yb(a);
  }
  function Qb(a) {
    throw Error(`Not implemented: adding durations to ${Da[a.type]}`);
  }
  function Rb(a) {
    throw Error(`Not implemented: subtracting durations from ${Da[a.type]}`);
  }
  function Sb(a, b) {
    if (null === a) return null;
    switch (typeof a) {
      case "boolean":
        return a ? va : wa;
      case "number":
        return g(a, 3);
      case "string":
        return g(a, 1);
      case "object":
        if ("nodeType" in a) return rb({
          node: a,
          G: null
        });
        if (Array.isArray(a)) return new pb(a.map(c => {
          if (void 0 === c) return () => w.empty();
          c = Sb(c);
          c = null === c ? w.empty() : w.m(c);
          return Ra(c);
        }));
        if (a instanceof Date) {
          const c = Jb(a.toISOString());
          return g(c, c.type);
        }
        return new ub(Object.keys(a).filter(c => void 0 !== a[c]).map(c => {
          var d = Sb(a[c]);
          d = null === d ? w.empty() : w.m(d);
          return {
            key: g(c, 1),
            value: Ra(d)
          };
        }));
    }
    throw Error(`Value ${String(a)} of type "${typeof a}" is not adaptable to an XPath value.`);
  }
  function Tb(a, b) {
    if ("number" !== typeof a && ("string" !== typeof a || !ta.get(b)(a))) throw Error(`Cannot convert JavaScript value '${a}' to the XPath type ${Da[b]} since it is not valid.`);
  }
  function Ub(a, b, c) {
    if (null === b) return null;
    switch (a) {
      case 0:
        return b ? va : wa;
      case 1:
        return g(b + "", 1);
      case 3:
      case 2:
        return Tb(b, 3), g(+b, 3);
      case 4:
        return Tb(b, a), g(+b, 4);
      case 5:
        return Tb(b, a), g(b | 0, 5);
      case 6:
        return Tb(b, a), g(+b, 6);
      case 7:
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
        if (!(b instanceof Date)) throw Error(`The JavaScript value ${b} with type ${typeof b} is not a valid type to be converted to an XPath ${Da[a]}.`);
        return g(Lb(Jb(b.toISOString()), a), a);
      case 53:
      case 47:
      case 55:
      case 54:
      case 56:
      case 57:
      case 58:
        if ("object" !== typeof b || !("nodeType" in b)) throw Error(`The JavaScript value ${b} with type ${typeof b} is not a valid type to be converted to an XPath ${Da[a]}.`);
        return rb({
          node: b,
          G: null
        });
      case 59:
        return Sb(b);
      case 61:
        return Sb(b);
      default:
        throw Error(`Values of the type "${Da[a]}" can not be adapted from JavaScript to equivalent XPath values.`);
    }
  }
  function Vb(a, b, c) {
    if (0 === c.g) return b = Ub(c.type, b), null === b ? [] : [b];
    if (2 === c.g || 1 === c.g) {
      if (!Array.isArray(b)) throw Error(`The JavaScript value ${b} should be an array if it is to be converted to ${Ha(c)}.`);
      return b.map(e => Ub(c.type, e)).filter(e => null !== e);
    }
    const d = Ub(c.type, b);
    if (null === d) throw Error(`The JavaScript value ${b} should be a single entry if it is to be converted to ${Ha(c)}.`);
    return [d];
  }
  function Wb(a, b, c = {
    type: 59,
    g: 0
  }) {
    return w.create(Vb(a, b, c));
  }
  var ac = class {
      constructor() {
        this.h = Math.abs(Math.floor(Math.random() * $b) % $b);
      }
    },
    $b = 2 ** 32;
  function bc(a, b, c, d) {
    return new cc({
      M: c,
      Aa: b,
      ta: d || a.ta,
      ra: a.ra
    }, a.h, a.o);
  }
  function dc(a, b) {
    let c = 0;
    const d = b.value;
    return {
      next: e => {
        e = d.next(e);
        return e.done ? p : q(bc(a, c++, e.value, b));
      }
    };
  }
  function ec(a) {
    a.h.ib || (a.h.ib = !0, a.h.qb = Jb(new Date().toISOString()), a.h.vb = Ab("PT0S"));
    return a.h.qb;
  }
  function fc(a) {
    a.h.ib || (a.h.ib = !0, a.h.qb = Jb(new Date().toISOString()), a.h.vb = Ab("PT0S"));
    return a.h.vb;
  }
  function gc(a, b = null) {
    a = 29421 * (null !== b && void 0 !== b ? b : a.o.h) % $b;
    return {
      rb: Math.floor(a),
      $b: a / $b
    };
  }
  function hc(a, b) {
    return new cc({
      M: a.M,
      Aa: a.Aa,
      ta: a.ta,
      ra: Object.assign(Object.create(null), a.ra, b)
    }, a.h, a.o);
  }
  var cc = class {
    constructor(a, b = {
      qb: null,
      vb: null,
      ib: !1
    }, c = new ac()) {
      this.h = b;
      this.Aa = a.Aa;
      this.ta = a.ta;
      this.M = a.M;
      this.ra = a.ra || Object.create(null);
      this.o = c;
    }
  };
  var ic = class {
    constructor(a, b, c, d, e, f, h, k, l) {
      this.debug = a;
      this.Ha = b;
      this.h = c;
      this.Ja = d;
      this.Ma = e;
      this.o = f;
      this.v = h;
      this.jb = k;
      this.Ua = l;
    }
  };
  function jc(a) {
    let b = 0,
      c = null,
      d = !0;
    return w.create({
      next: e => {
        for (; b < a.length;) {
          c || (c = a[b].value, d = !0);
          const f = c.next(d ? 0 : e);
          d = !1;
          if (f.done) b++, c = null;else return f;
        }
        return p;
      }
    });
  }
  var kc = (a, b, c) => Error(`FORG0001: Cannot cast ${a} to ${Da[b]}${c ? `, ${c}` : ""}`),
    lc = a => Error(`XPDY0002: ${a}`),
    mc = a => Error(`XPTY0004: ${a}`),
    nc = a => Error(`FOTY0013: Atomization is not supported for ${Da[a]}.`),
    oc = a => Error(`XPST0081: The prefix ${a} could not be resolved.`);
  function pc(a, b) {
    if (v(a.type, 46) || v(a.type, 19) || v(a.type, 0) || v(a.type, 4) || v(a.type, 3) || v(a.type, 6) || v(a.type, 5) || v(a.type, 2) || v(a.type, 23) || v(a.type, 1)) return w.create(a);
    const c = b.h;
    if (v(a.type, 53)) {
      const d = a.value;
      if (2 === d.node.nodeType || 3 === d.node.nodeType) return w.create(g(ib(c, d), 19));
      if (8 === d.node.nodeType || 7 === d.node.nodeType) return w.create(g(ib(c, d), 1));
      const e = [];
      (function k(h) {
        if (8 !== d.node.nodeType && 7 !== d.node.nodeType) {
          var l = h.nodeType;
          3 === l || 4 === l ? e.push(c.getData(h)) : 1 !== l && 9 !== l && 11 !== l || c.getChildNodes(h).forEach(n => {
            k(n);
          });
        }
      })(d.node);
      return w.create(g(e.join(""), 19));
    }
    if (v(a.type, 60) && !v(a.type, 62)) throw nc(a.type);
    if (v(a.type, 62)) return jc(a.h.map(d => qc(d(), b)));
    throw Error(`Atomizing ${a.type} is not implemented.`);
  }
  function qc(a, b) {
    let c = !1;
    const d = a.value;
    let e = null;
    return w.create({
      next: () => {
        for (; !c;) {
          if (!e) {
            var f = d.next(0);
            if (f.done) {
              c = !0;
              break;
            }
            e = pc(f.value, b).value;
          }
          f = e.next(0);
          if (f.done) e = null;else return f;
        }
        return p;
      }
    });
  }
  function rc(a) {
    for (a = ua[a]; a && 0 !== a.C;) a = a.parent;
    return a ? a.type : null;
  }
  function sc(a, b) {
    b = ua[b];
    const c = b.Ka;
    if (!c || !c.whiteSpace) return b.parent ? sc(a, b.parent.type) : a;
    switch (b.Ka.whiteSpace) {
      case "replace":
        return a.replace(/[\u0009\u000A\u000D]/g, " ");
      case "collapse":
        return a.replace(/[\u0009\u000A\u000D]/g, " ").replace(/ {2,}/g, " ").replace(/^ | $/g, "");
    }
    return a;
  }
  function tc(a, b) {
    for (b = ua[b]; b && null === b.gb;) {
      if (2 === b.C || 3 === b.C) return !0;
      b = b.parent;
    }
    return b ? b.gb(a) : !0;
  }
  function uc(a, b) {
    for (; a;) {
      if (a.Oa && a.Oa[b]) return a.Oa[b];
      a = a.parent;
    }
    return () => !0;
  }
  function vc(a, b) {
    let c = ua[b];
    for (; c;) {
      if (c.Ka && !Object.keys(c.Ka).every(d => {
        if ("whiteSpace" === d) return !0;
        const e = uc(c, d);
        return e ? e(a, c.Ka[d]) : !0;
      })) return !1;
      c = c.parent;
    }
    return !0;
  }
  function wc(a) {
    return a ? 2 === a.g || 0 === a.g : !0;
  }
  function xc(a) {
    return a(1) || a(19) ? b => ({
      u: !0,
      value: g(b, 20)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:anyURI or any of its derived types.")
    });
  }
  function yc(a) {
    return a(22) ? b => {
      let c = "";
      for (let d = 0; d < b.length; d += 2) c += String.fromCharCode(parseInt(b.substr(d, 2), 16));
      return {
        u: !0,
        value: g(btoa(c), 21)
      };
    } : a(1) || a(19) ? b => ({
      u: !0,
      value: g(b, 21)
    }) : () => ({
      error: Error("XPTY0004: Casting not supported from given type to xs:base64Binary or any of its derived types."),
      u: !1
    });
  }
  function zc(a) {
    return a(2) ? b => ({
      u: !0,
      value: 0 === b || isNaN(b) ? wa : va
    }) : a(1) || a(19) ? b => {
      switch (b) {
        case "true":
        case "1":
          return {
            u: !0,
            value: va
          };
        case "false":
        case "0":
          return {
            u: !0,
            value: wa
          };
        default:
          return {
            u: !1,
            error: Error("XPTY0004: Casting not supported from given type to xs:boolean or any of its derived types.")
          };
      }
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:boolean or any of its derived types.")
    });
  }
  function Dc(a) {
    return a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 7), 7)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 7)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:date or any of its derived types.")
    });
  }
  function Ec(a) {
    return a(7) ? b => ({
      u: !0,
      value: g(Lb(b, 9), 9)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 9)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:dateTime or any of its derived types.")
    });
  }
  function Fc(a) {
    return a(18) && !a(16) ? b => ({
      u: !0,
      value: g(b.Ga, 17)
    }) : a(16) ? () => ({
      u: !0,
      value: g(Ab("PT0.0S"), 17)
    }) : a(19) || a(1) ? b => {
      const c = Ab(b);
      return c ? {
        u: !0,
        value: g(c, 17)
      } : {
        u: !1,
        error: Error(`FORG0001: Can not cast ${b} to xs:dayTimeDuration`)
      };
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:dayTimeDuration or any of its derived types.")
    });
  }
  function Gc(a) {
    return a(5) ? b => ({
      u: !0,
      value: g(b, 4)
    }) : a(6) || a(3) ? b => isNaN(b) || !isFinite(b) ? {
      u: !1,
      error: Error(`FOCA0002: Can not cast ${b} to xs:decimal`)
    } : Math.abs(b) > Number.MAX_VALUE ? {
      u: !1,
      error: Error(`FOAR0002: Can not cast ${b} to xs:decimal, it is out of bounds for JavaScript numbers`)
    } : {
      u: !0,
      value: g(b, 4)
    } : a(0) ? b => ({
      u: !0,
      value: g(b ? 1 : 0, 4)
    }) : a(1) || a(19) ? b => {
      const c = parseFloat(b);
      return !isNaN(c) || isFinite(c) ? {
        u: !0,
        value: g(c, 4)
      } : {
        u: !1,
        error: Error(`FORG0001: Can not cast ${b} to xs:decimal`)
      };
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:decimal or any of its derived types.")
    });
  }
  function Hc(a, b) {
    return a(2) ? c => ({
      u: !0,
      value: c
    }) : a(0) ? c => ({
      u: !0,
      value: c ? 1 : 0
    }) : a(1) || a(19) ? c => {
      switch (c) {
        case "NaN":
          return {
            u: !0,
            value: NaN
          };
        case "INF":
        case "+INF":
          return {
            u: !0,
            value: Infinity
          };
        case "-INF":
          return {
            u: !0,
            value: -Infinity
          };
        case "0":
        case "+0":
          return {
            u: !0,
            value: 0
          };
        case "-0":
          return {
            u: !0,
            value: -0
          };
      }
      const d = parseFloat(c);
      return isNaN(d) ? {
        u: !1,
        error: kc(c, b)
      } : {
        u: !0,
        value: d
      };
    } : () => ({
      u: !1,
      error: Error(`XPTY0004: Casting not supported from given type to ${b} or any of its derived types.`)
    });
  }
  function Ic(a) {
    const b = Hc(a, 3);
    return c => {
      c = b(c);
      return c.u ? {
        u: !0,
        value: g(c.value, 3)
      } : c;
    };
  }
  function Jc(a) {
    const b = Math.abs(a.bb());
    a = Math.abs(a.ab());
    return `${b ? `${b}Y` : ""}` + `${a ? `${a}M` : ""}` || "0M";
  }
  var Kc = class extends wb {
      constructor(a) {
        super();
        if (a > Number.MAX_SAFE_INTEGER || a < Number.MIN_SAFE_INTEGER) throw Error("FODT0002: Number of months given to construct YearMonthDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER");
        this.ea = a;
      }
      ab() {
        const a = this.ea % 12;
        return 0 === a ? 0 : a;
      }
      h() {
        return this.ea;
      }
      bb() {
        return Math.trunc(this.ea / 12);
      }
      na() {
        return Object.is(-0, this.ea) ? !1 : 0 <= this.ea;
      }
      toString() {
        return (this.na() ? "P" : "-P") + Jc(this);
      }
    },
    Lc = a => {
      var b = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.exec(a);
      if (b) {
        a = !b[1];
        b = 12 * (b[2] ? parseInt(b[2], 10) : 0) + (b[3] ? parseInt(b[3], 10) : 0);
        if (b > Number.MAX_SAFE_INTEGER || !Number.isFinite(b)) throw Error("FODT0002: Value overflow while constructing xs:yearMonthDuration");
        a = new Kc(a || 0 === b ? b : -b);
      } else a = null;
      return a;
    };
  function Mc(a, b) {
    if (isNaN(b)) throw Error("FOCA0005: Cannot multiply xs:yearMonthDuration by NaN");
    a = Math.round(a.ea * b);
    if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while constructing xs:yearMonthDuration");
    return new Kc(a < Number.MIN_SAFE_INTEGER || 0 === a ? 0 : a);
  }
  var Nc = class extends wb {
    constructor(a, b) {
      super();
      this.Va = a;
      this.Ga = b;
    }
    $a() {
      return this.Ga.$a();
    }
    getHours() {
      return this.Ga.getHours();
    }
    getMinutes() {
      return this.Ga.getMinutes();
    }
    ab() {
      return this.Va.ab();
    }
    h() {
      return this.Va.h();
    }
    o() {
      return this.Ga.o();
    }
    getSeconds() {
      return this.Ga.getSeconds();
    }
    bb() {
      return this.Va.bb();
    }
    na() {
      return this.Va.na() && this.Ga.na();
    }
    toString() {
      const a = this.na() ? "P" : "-P",
        b = Jc(this.Va),
        c = xb(this.Ga);
      return "0M" === b ? a + c : "T0S" === c ? a + b : a + b + c;
    }
  };
  function Oc(a) {
    return a(16) ? b => ({
      u: !0,
      value: g(new Nc(b, new yb(b.na() ? 0 : -0)), 18)
    }) : a(17) ? b => {
      b = new Nc(new Kc(b.na() ? 0 : -0), b);
      return {
        u: !0,
        value: g(b, 18)
      };
    } : a(18) ? b => ({
      u: !0,
      value: g(b, 18)
    }) : a(19) || a(1) ? b => {
      var c;
      return c = new Nc(Lc(b), Ab(b)), {
        u: !0,
        value: g(c, 18)
      };
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:duration or any of its derived types.")
    });
  }
  function Pc(a) {
    const b = Hc(a, 6);
    return c => {
      c = b(c);
      return c.u ? {
        u: !0,
        value: g(c.value, 6)
      } : c;
    };
  }
  function Qc(a) {
    return a(7) || a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 15), 15)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 15)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:gDay or any of its derived types.")
    });
  }
  function Rc(a) {
    return a(7) || a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 14), 14)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 14)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:gMonth or any of its derived types.")
    });
  }
  function Sc(a) {
    return a(7) || a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 13), 13)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 13)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:gMonthDay or any of its derived types.")
    });
  }
  function Tc(a) {
    return a(7) || a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 12), 12)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 12)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:gYear or any of its derived types.")
    });
  }
  function Uc(a) {
    return a(7) || a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 11), 11)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 11)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:gYearMonth or any of its derived types.")
    });
  }
  function Vc(a) {
    return a(21) ? b => {
      b = atob(b);
      let c = "";
      for (let d = 0, e = b.length; d < e; d++) c += Number(b.charCodeAt(d)).toString(16);
      return {
        u: !0,
        value: g(c.toUpperCase(), 22)
      };
    } : a(1) || a(19) ? b => ({
      u: !0,
      value: g(b, 22)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:hexBinary or any of its derived types.")
    });
  }
  function Wc(a) {
    return a(0) ? b => ({
      u: !0,
      value: g(b ? 1 : 0, 5)
    }) : a(2) ? b => {
      const c = Math.trunc(b);
      return !isFinite(c) || isNaN(c) ? {
        u: !1,
        error: Error(`FOCA0002: can not cast ${b} to xs:integer`)
      } : Number.isSafeInteger(c) ? {
        u: !0,
        value: g(c, 5)
      } : {
        u: !1,
        error: Error(`FOAR0002: can not cast ${b} to xs:integer, it is out of bounds for JavaScript numbers.`)
      };
    } : a(1) || a(19) ? b => {
      const c = parseInt(b, 10);
      return isNaN(c) ? {
        u: !1,
        error: kc(b, 5)
      } : Number.isSafeInteger(c) ? {
        u: !0,
        value: g(c, 5)
      } : {
        u: !1,
        error: Error(`FOCA0003: can not cast ${b} to xs:integer, it is out of bounds for JavaScript numbers.`)
      };
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:integer or any of its derived types.")
    });
  }
  const Xc = [3, 6, 4, 5];
  function Yc(a) {
    var b = Zc;
    return c => {
      for (const d of Xc) {
        const e = b(a, d)(c);
        if (e.u) return e;
      }
      return {
        u: !1,
        error: Error(`XPTY0004: Casting not supported from "${c}" given type to xs:numeric or any of its derived types.`)
      };
    };
  }
  function $c(a) {
    if (a(1) || a(19)) return b => ({
      u: !0,
      value: b + ""
    });
    if (a(20)) return b => ({
      u: !0,
      value: b
    });
    if (a(23)) return b => ({
      u: !0,
      value: b.prefix ? `${b.prefix}:${b.localName}` : b.localName
    });
    if (a(44)) return b => ({
      u: !0,
      value: b.toString()
    });
    if (a(2)) {
      if (a(5) || a(4)) return b => ({
        u: !0,
        value: (b + "").replace("e", "E")
      });
      if (a(6) || a(3)) return b => isNaN(b) ? {
        u: !0,
        value: "NaN"
      } : isFinite(b) ? Object.is(b, -0) ? {
        u: !0,
        value: "-0"
      } : {
        u: !0,
        value: (b + "").replace("e", "E").replace("E+", "E")
      } : {
        u: !0,
        value: `${0 > b ? "-" : ""}INF`
      };
    }
    return a(9) || a(7) || a(8) || a(15) || a(14) || a(13) || a(12) || a(11) ? b => ({
      u: !0,
      value: b.toString()
    }) : a(16) ? b => ({
      u: !0,
      value: b.toString()
    }) : a(17) ? b => ({
      u: !0,
      value: b.toString()
    }) : a(18) ? b => ({
      u: !0,
      value: b.toString()
    }) : a(22) ? b => ({
      u: !0,
      value: b.toUpperCase()
    }) : b => ({
      u: !0,
      value: b + ""
    });
  }
  function ad(a) {
    const b = $c(a);
    return c => {
      c = b(c);
      return c.u ? {
        u: !0,
        value: g(c.value, 1)
      } : c;
    };
  }
  function bd(a) {
    return a(9) ? b => ({
      u: !0,
      value: g(Lb(b, 8), 8)
    }) : a(19) || a(1) ? b => ({
      u: !0,
      value: g(Jb(b), 8)
    }) : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:time or any of its derived types.")
    });
  }
  function cd(a) {
    const b = $c(a);
    return c => {
      c = b(c);
      return c.u ? {
        u: !0,
        value: g(c.value, 19)
      } : c;
    };
  }
  function dd(a) {
    return a(18) && !a(17) ? b => ({
      u: !0,
      value: g(b.Va, 16)
    }) : a(17) ? () => ({
      u: !0,
      value: g(Lc("P0M"), 16)
    }) : a(19) || a(1) ? b => {
      const c = Lc(b);
      return c ? {
        u: !0,
        value: g(c, 16)
      } : {
        u: !1,
        error: kc(b, 16)
      };
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:yearMonthDuration or any of its derived types.")
    });
  }
  const ed = [2, 5, 17, 16];
  function Zc(a, b) {
    const c = d => v(a, d);
    if (39 === b) return () => ({
      u: !1,
      error: Error("FORG0001: Casting to xs:error is always invalid.")
    });
    switch (b) {
      case 19:
        return cd(c);
      case 1:
        return ad(c);
      case 6:
        return Pc(c);
      case 3:
        return Ic(c);
      case 4:
        return Gc(c);
      case 5:
        return Wc(c);
      case 2:
        return Yc(a);
      case 18:
        return Oc(c);
      case 16:
        return dd(c);
      case 17:
        return Fc(c);
      case 9:
        return Ec(c);
      case 8:
        return bd(c);
      case 7:
        return Dc(c);
      case 11:
        return Uc(c);
      case 12:
        return Tc(c);
      case 13:
        return Sc(c);
      case 15:
        return Qc(c);
      case 14:
        return Rc(c);
      case 0:
        return zc(c);
      case 21:
        return yc(c);
      case 22:
        return Vc(c);
      case 20:
        return xc(c);
      case 23:
        throw Error("Casting to xs:QName is not implemented.");
    }
    return () => ({
      u: !1,
      error: Error(`XPTY0004: Casting not supported from ${a} to ${b}.`)
    });
  }
  const gd = Object.create(null);
  function hd(a, b) {
    if (19 === a && 1 === b) return f => ({
      u: !0,
      value: g(f, 1)
    });
    if (44 === b) return () => ({
      u: !1,
      error: Error("XPST0080: Casting to xs:NOTATION is not permitted.")
    });
    if (39 === b) return () => ({
      u: !1,
      error: Error("FORG0001: Casting to xs:error is not permitted.")
    });
    if (45 === a || 45 === b) return () => ({
      u: !1,
      error: Error("XPST0080: Casting from or to xs:anySimpleType is not permitted.")
    });
    if (46 === a || 46 === b) return () => ({
      u: !1,
      error: Error("XPST0080: Casting from or to xs:anyAtomicType is not permitted.")
    });
    if (v(a, 60) && 1 === b) return () => ({
      u: !1,
      error: Error("FOTY0014: Casting from function item to xs:string is not permitted.")
    });
    if (a === b) return f => ({
      u: !0,
      value: {
        type: b,
        value: f
      }
    });
    const c = ed.includes(a) ? a : rc(a),
      d = ed.includes(b) ? b : rc(b);
    if (null === d || null === c) return () => ({
      u: !1,
      error: Error(`XPST0081: Can not cast: type ${d ? Da[a] : Da[b]} is unknown.`)
    });
    const e = [];
    1 !== c && 19 !== c || e.push(f => {
      const h = sc(f, b);
      return tc(h, b) ? {
        u: !0,
        value: h
      } : {
        u: !1,
        error: kc(f, b, "pattern validation failed.")
      };
    });
    c !== d && (e.push(Zc(c, d)), e.push(f => ({
      u: !0,
      value: f.value
    })));
    19 !== d && 1 !== d || e.push(f => tc(f, b) ? {
      u: !0,
      value: f
    } : {
      u: !1,
      error: kc(f, b, "pattern validation failed.")
    });
    e.push(f => vc(f, b) ? {
      u: !0,
      value: f
    } : {
      u: !1,
      error: kc(f, b, "pattern validation failed.")
    });
    e.push(f => ({
      u: !0,
      value: {
        type: b,
        value: f
      }
    }));
    return f => {
      f = {
        u: !0,
        value: f
      };
      for (let h = 0, k = e.length; h < k && (f = e[h](f.value), !1 !== f.u); ++h);
      return f;
    };
  }
  function id(a, b) {
    const c = a.type + 1E4 * b;
    let d = gd[c];
    d ||= gd[c] = hd(a.type, b);
    return d.call(void 0, a.value, b);
  }
  function jd(a, b) {
    a = id(a, b);
    if (!0 === a.u) return a.value;
    throw a.error;
  }
  function kd(a) {
    let b = !1;
    return {
      next: () => {
        if (b) return p;
        b = !0;
        return q(a);
      }
    };
  }
  function ld(a, b) {
    return a === b ? !0 : a && b && a.offset === b.offset && a.parent === b.parent ? ld(a.G, b.G) : !1;
  }
  function md(a, b) {
    return a === b || a.node === b.node && ld(a.G, b.G) ? !0 : !1;
  }
  function nd(a, b, c) {
    var d = x(a, b, null);
    a = hb(a, d, null);
    for (let e = 0, f = a.length; e < f; ++e) {
      d = a[e];
      if (md(d, b)) return -1;
      if (md(d, c)) return 1;
    }
  }
  function od(a, b) {
    const c = [];
    for (; b; b = x(a, b, null)) c.unshift(b);
    return c;
  }
  function pd(a, b) {
    const c = [];
    for (; b; b = a.getParentNode(b, null)) c.unshift(b);
    return c;
  }
  function qd(a, b, c, d) {
    if (c.G || d.G || cb(c.node) || cb(d.node)) {
      if (md(c, d)) return 0;
      c = od(b, c);
      d = od(b, d);
      const f = c[0],
        h = d[0];
      if (!md(f, h)) return b = a.findIndex(k => md(k, f)), c = a.findIndex(k => md(k, h)), -1 === b && (b = a.push(f)), -1 === c && (c = a.push(h)), b - c;
      a = 1;
      for (var e = Math.min(c.length, d.length); a < e && md(c[a], d[a]); ++a);
      return c[a] ? d[a] ? nd(b, c[a], d[a]) : 1 : -1;
    }
    c = c.node;
    e = d.node;
    if (c === e) return 0;
    d = pd(b, c);
    c = pd(b, e);
    if (d[0] !== c[0]) {
      const f = {
          node: d[0],
          G: null
        },
        h = {
          node: c[0],
          G: null
        };
      b = a.findIndex(k => md(k, f));
      c = a.findIndex(k => md(k, h));
      -1 === b && (b = a.push(f));
      -1 === c && (c = a.push(h));
      return b - c;
    }
    a = 1;
    for (e = Math.min(d.length, c.length); a < e && d[a] === c[a]; ++a);
    d = d[a];
    e = c[a];
    if (!d) return -1;
    if (!e) return 1;
    b = b.getChildNodes(c[a - 1], null);
    for (let f = 0, h = b.length; f < h; ++f) {
      a = b[f];
      if (a === d) return -1;
      if (a === e) return 1;
    }
  }
  function rd(a, b, c, d) {
    const e = v(c.type, 47),
      f = v(d.type, 47);
    if (e && !f) {
      if (c = x(b, c.value), d = d.value, md(c, d)) return 1;
    } else if (f && !e) {
      if (c = c.value, d = x(b, d.value), md(c, d)) return -1;
    } else if (e && f) {
      if (md(x(b, d.value), x(b, c.value))) return c.value.node.localName > d.value.node.localName ? 1 : -1;
      c = x(b, c.value);
      d = x(b, d.value);
    } else c = c.value, d = d.value;
    return qd(a, b, c, d);
  }
  function sd(a, b, c) {
    return rd(a.o, a, b, c);
  }
  function td(a, b) {
    return ud(b, (c, d) => rd(a.o, a, c, d)).filter((c, d, e) => 0 === d ? !0 : !md(c.value, e[d - 1].value));
  }
  const vd = (a, b) => a < b ? -1 : 0;
  function ud(a, b = vd) {
    if (1 >= a.length) return a;
    var c = Math.floor(a.length / 2);
    const d = ud(a.slice(0, c), b);
    a = ud(a.slice(c), b);
    for (c = []; d.length && a.length;) 0 > b(d[0], a[0]) ? c.push(d.shift()) : c.push(a.shift());
    return c.concat(d.concat(a));
  }
  var wd = xspattern;
  function xd(a, b) {
    if (v(a.type, 2)) {
      if (v(a.type, 6)) return 3 === b ? g(a.value, 3) : null;
      if (v(a.type, 4)) {
        if (6 === b) return g(a.value, 6);
        if (3 === b) return g(a.value, 3);
      }
      return null;
    }
    return v(a.type, 20) && 1 === b ? g(a.value, 1) : null;
  }
  function yd(a, b, c, d, e) {
    if (v(a.type, b.type)) return a;
    v(b.type, 46) && v(a.type, 53) && (a = pc(a, c).first());
    if (v(a.type, b.type) || 46 === b.type) return a;
    if (v(a.type, 19)) {
      c = jd(a, b.type);
      if (!c) throw Error(`XPTY0004 Unable to convert ${e ? "return" : "argument"} of type ${Da[a.type]} to type ${Ha(b)} while calling ${d}`);
      return c;
    }
    c = xd(a, b.type);
    if (!c) throw Error(`XPTY0004 Unable to cast ${e ? "return" : "argument"} of type ${Da[a.type]} to type ${Ha(b)} while calling ${d}`);
    return c;
  }
  function zd(a) {
    switch (a) {
      case 2:
        return "*";
      case 1:
        return "+";
      case 0:
        return "?";
      case 3:
        return "";
    }
  }
  var Ad = (a, b, c, d, e) => 0 === a.g ? b.X({
    default: () => b.map(f => yd(f, a, c, d, e)),
    multiple: () => {
      throw Error(`XPTY0004: Multiplicity of ${e ? "function return value" : "function argument"} of type ${Da[a.type]}${zd(a.g)} for ${d} is incorrect. Expected "?", but got "+".`);
    }
  }) : 1 === a.g ? b.X({
    empty: () => {
      throw Error(`XPTY0004: Multiplicity of ${e ? "function return value" : "function argument"} of type ${Da[a.type]}${zd(a.g)} for ${d} is incorrect. Expected "+", but got "empty-sequence()"`);
    },
    default: () => b.map(f => yd(f, a, c, d, e))
  }) : 2 === a.g ? b.map(f => yd(f, a, c, d, e)) : b.X({
    m: () => b.map(f => yd(f, a, c, d, e)),
    default: () => {
      throw Error(`XPTY0004: Multiplicity of ${e ? "function return value" : "function argument"} of type ${Da[a.type]}${zd(a.g)} for ${d} is incorrect. Expected exactly one`);
    }
  });
  function Bd(a, b) {
    return v(a, 5) ? g(b, 5) : v(a, 6) ? g(b, 6) : v(a, 3) ? g(b, 3) : g(b, 4);
  }
  const Cd = [{
    la: "M",
    ja: 1E3
  }, {
    la: "CM",
    ja: 900
  }, {
    la: "D",
    ja: 500
  }, {
    la: "CD",
    ja: 400
  }, {
    la: "C",
    ja: 100
  }, {
    la: "XC",
    ja: 90
  }, {
    la: "L",
    ja: 50
  }, {
    la: "XL",
    ja: 40
  }, {
    la: "X",
    ja: 10
  }, {
    la: "IX",
    ja: 9
  }, {
    la: "V",
    ja: 5
  }, {
    la: "IV",
    ja: 4
  }, {
    la: "I",
    ja: 1
  }];
  function Dd(a, b) {
    const c = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    let d = Cd.reduce((e, f) => {
      const h = Math.floor(a / f.ja);
      a -= h * f.ja;
      return e + f.la.repeat(h);
    }, "");
    b && (d = d.toLowerCase());
    c && (d = `-${d}`);
    return d;
  }
  const Ed = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  function Fd(a, b) {
    const c = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    let d = "",
      e;
    for (; 0 < a;) e = (a - 1) % Ed.length, d = Ed[e] + d, a = (a - e) / Ed.length | 0;
    b && (d = d.toLowerCase());
    c && (d = `-${d}`);
    return d;
  }
  function Gd(a, b, c = []) {
    return Array.from({
      length: b
    }, (d, e) => e + a).filter(d => !c.includes(d));
  }
  const Hd = Gd(1488, 27, [1498, 1501, 1503, 1507, 1509]),
    Id = Gd(1575, 36, [1577, 1595, 1596, 1597, 1598, 1599, 1600, 1609]),
    Jd = "\u0623\u0628\u062c\u062f\u0647\u0648\u0632\u062d\u0637\u064a\u0643\u0644\u0645\u0646\u0633\u0639\u0641\u0635\u0642\u0631\u0634\u062a\u062b\u062e\u0630\u0636\u0638\u063a".split(""),
    Kd = [[1E3, "\u063a"], [900, "\u0638"], [800, "\u0636"], [700, "\u0630"], [600, "\u062e"], [500, "\u062b"], [400, "\u062a"], [300, "\u0634"], [200, "\u0631"], [100, "\u0642"], [90, "\u0635"], [80, "\u0641"], [70, "\u0639"], [60, "\u0633"], [50, "\u0646"], [40, "\u0645"], [30, "\u0644"], [20, "\u0643"], [10, "\u064a"], [9, "\u0637"], [8, "\u062d"], [7, "\u0632"], [6, "\u0648"], [5, "\u0647"], [4, "\u062f"], [3, "\u062c"], [2, "\u0628"], [1, "\u0623"]],
    Ld = [[400, "\u05ea"], [300, "\u05e9"], [200, "\u05e8"], [100, "\u05e7"], [90, "\u05e6"], [80, "\u05e4"], [70, "\u05e2"], [60, "\u05e1"], [50, "\u05e0"], [40, "\u05de"], [30, "\u05dc"], [20, "\u05db"], [10, "\u05d9"], [9, "\u05d8"], [8, "\u05d7"], [7, "\u05d6"], [6, "\u05d5"], [5, "\u05d4"], [4, "\u05d3"], [3, "\u05d2"], [2, "\u05d1"], [1, "\u05d0"]];
  function Md(a, b = []) {
    var c = 25;
    b.sort((d, e) => d - e);
    c -= b.length;
    return function (d) {
      const e = 0 > d;
      d = Math.abs(d);
      if (!d) return "-";
      const f = [];
      for (; 0 < d;) {
        let h = a + (d - 1) % c;
        b.forEach(k => {
          h >= k && h++;
        });
        f.unshift(String.fromCodePoint(h));
        d = Math.floor((d - 1) / c);
      }
      d = f.join("");
      e && (d = `-${d}`);
      return d;
    };
  }
  const Nd = Md(945, [962]),
    Od = Md(913, [930]);
  function Pd(a) {
    return new Intl.NumberFormat([], {
      numberingSystem: "arab",
      useGrouping: !1
    }).format(a);
  }
  function Qd(a) {
    return new Intl.NumberFormat([], {
      numberingSystem: "arabext",
      useGrouping: !1
    }).format(a);
  }
  const Rd = new Map([["A", function (a) {
    return Fd(a, !1);
  }], ["a", function (a) {
    return Fd(a, !0);
  }], ["I", function (a) {
    return Dd(a, !1);
  }], ["i", function (a) {
    return Dd(a, !0);
  }], ["lowerGreek", Nd], ["\u03b1", Nd], ["upperGreek", Od], ["\u0391", Od], ["arabicAbjadi", function (a) {
    const b = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    a = Array(Math.floor((a - 1) / Jd.length) + 1).fill(Jd[(a - 1) % Jd.length]).join(String.fromCodePoint(8204));
    b && (a = `-${a}`);
    return a;
  }], ["arabicAbjadNumeral", function (a) {
    const b = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    var c = [],
      d = Math.floor(a / 1E3);
    a -= 1E3 * d;
    if (1 === d) c.push(Kd[0][1]);else if (1 < d) {
      for (const [f, h] of Kd) {
        var e = f;
        const k = h;
        for (; d >= e;) c.push(k), d -= e;
      }
      c.push(Kd[0][1]);
    }
    for (const [f, h] of Kd) for (d = f, e = h; a >= d;) a -= d, c.push(e);
    c = c.join("");
    b && (c = `-${c}`);
    return c;
  }], ["arabicAlifBaTa", function (a) {
    const b = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    a = Array(Math.floor((a - 1) / Id.length) + 1).fill(String.fromCodePoint(Id[(a - 1) % Id.length])).join(String.fromCodePoint(8204));
    b && (a = `-${a}`);
    return a;
  }], ["hebrewAlefBet", function (a) {
    const b = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    var c = Math.floor((a - 1) / Hd.length);
    const d = String.fromCodePoint(1514);
    c = Array(c).fill(d);
    c.push(String.fromCodePoint(Hd[(a - 1) % Hd.length]));
    a = c.join("");
    b && (a = `-${a}`);
    return a;
  }], ["hebrewNumeral", function (a) {
    const b = 0 > a;
    a = Math.abs(a);
    if (!a) return "-";
    var c = [],
      d = Math.floor(a / 400);
    a -= 400 * d;
    for (var e = 0; e < d; e++) c.push("\u05ea");
    for (const [f, h] of Ld) for (d = f, e = h; a >= d;) a -= d, c.push(e);
    a = c.slice(-2).join("");
    "\u05d9\u05d4" === a && c.splice(-2, 2, "\u05d8", "\u05d5");
    "\u05d9\u05d5" === a && c.splice(-2, 2, "\u05d8", "\u05d6");
    c = c.join("");
    b && (c = `-${c}`);
    return c;
  }], ["arabicIndicNumeral", Pd], ["\u0661", Pd], ["\u0662", Pd], ["\u0663", Pd], ["\u0664", Pd], ["\u0665", Pd], ["\u0666", Pd], ["\u0667", Pd], ["\u0668", Pd], ["\u0669", Pd], ["persianNumeral", Qd], ["\u06f1", Qd], ["\u06f2", Qd], ["\u06f3", Qd], ["\u06f4", Qd], ["\u06f5", Qd], ["\u06f6", Qd], ["\u06f7", Qd], ["\u06f8", Qd], ["\u06f9", Qd]]);
  function Sd(a) {
    if (Math.floor(a) === a || isNaN(a)) return 0;
    a = /\d+(?:\.(\d*))?(?:[Ee](-)?(\d+))*/.exec(`${a}`);
    const b = a[1] ? a[1].length : 0;
    if (a[3]) {
      if (a[2]) return b + parseInt(a[3], 10);
      a = b - parseInt(a[3], 10);
      return 0 > a ? 0 : a;
    }
    return b;
  }
  function Td(a, b, c) {
    return b && 0 === a * c % 1 % .5 ? 0 === Math.floor(a * c) % 2 ? Math.floor(a * c) / c : Math.ceil(a * c) / c : Math.round(a * c) / c;
  }
  function Ud(a, b, c, d, e, f) {
    let h = !1;
    return w.create({
      next: () => {
        if (h) return p;
        const k = e.first();
        if (!k) return h = !0, p;
        if ((v(k.type, 6) || v(k.type, 3)) && (0 === k.value || isNaN(k.value) || Infinity === k.value || -Infinity === k.value)) return h = !0, q(k);
        var l;
        f ? l = f.first().value : l = 0;
        h = !0;
        if (Sd(k.value) < l) return q(k);
        const n = [5, 4, 3, 6].find(u => v(k.type, u)),
          t = jd(k, 4);
        l = Td(t.value, a, Math.pow(10, l));
        switch (n) {
          case 4:
            return q(g(l, 4));
          case 3:
            return q(g(l, 3));
          case 6:
            return q(g(l, 6));
          case 5:
            return q(g(l, 5));
        }
      }
    });
  }
  const Vd = (a, b, c, d) => qc(d, b).X({
    empty: () => w.m(g(NaN, 3)),
    m: () => {
      const e = id(d.first(), 3);
      return e.u ? w.m(e.value) : w.m(g(NaN, 3));
    },
    multiple: () => {
      throw Error("fn:number may only be called with zero or one values");
    }
  });
  function Wd(a) {
    let b = 5381;
    for (let c = 0; c < a.length; ++c) b = 33 * b + a.charCodeAt(c), b %= Number.MAX_SAFE_INTEGER;
    return b;
  }
  const Xd = (a, b, c, d = w.empty()) => {
    function e(f) {
      const h = (k, l, n, t) => {
        if (t.F() || t.oa()) return t;
        k = t.O();
        l = f;
        for (n = k.length - 1; 1 < n; n--) {
          l = gc(a, l).rb;
          t = l % n;
          const u = k[t];
          k[t] = k[n];
          k[n] = u;
        }
        return w.create(k);
      };
      return w.m(new ub([{
        key: g("number", 1),
        value: () => w.m(g(gc(a, f).$b, 3))
      }, {
        key: g("next", 1),
        value: () => w.m(new Va({
          value: () => e(gc(a, f).rb),
          Ya: !0,
          localName: "",
          namespaceURI: "",
          j: [],
          arity: 0,
          i: {
            type: 61,
            g: 3
          }
        }))
      }, {
        key: g("permute", 1),
        value: () => w.m(new Va({
          value: h,
          Ya: !0,
          localName: "",
          namespaceURI: "",
          j: [{
            type: 59,
            g: 2
          }],
          arity: 1,
          i: {
            type: 59,
            g: 2
          }
        }))
      }]));
    }
    b = d.F() ? gc(a) : gc(a, Wd(jd(d.first(), 1).value));
    return e(b.rb);
  };
  var Yd = [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "abs",
    j: [{
      type: 2,
      g: 0
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => Bd(e.type, Math.abs(e.value)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "format-integer",
    j: [{
      type: 5,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: (a, b, c, d, e) => {
      a = d.first();
      e = e.first();
      if (d.F()) return w.m(g("", 1));
      d = Rd.get(e.value);
      e = a.value;
      return d ? (d = d(e), w.m(g(d, 1))) : w.m(g(e.toString(), 1));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "ceiling",
    j: [{
      type: 2,
      g: 0
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => Bd(e.type, Math.ceil(e.value)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "floor",
    j: [{
      type: 2,
      g: 0
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => Bd(e.type, Math.floor(e.value)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "round",
    j: [{
      type: 2,
      g: 0
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: Ud.bind(null, !1)
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "round",
    j: [{
      type: 2,
      g: 0
    }, {
      type: 5,
      g: 3
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: Ud.bind(null, !1)
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "round-half-to-even",
    j: [{
      type: 2,
      g: 0
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: Ud.bind(null, !0)
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "round-half-to-even",
    j: [{
      type: 2,
      g: 0
    }, {
      type: 5,
      g: 3
    }],
    i: {
      type: 2,
      g: 0
    },
    callFunction: Ud.bind(null, !0)
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "number",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 3,
      g: 3
    },
    callFunction: Vd
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "number",
    j: [],
    i: {
      type: 3,
      g: 3
    },
    callFunction: (a, b, c) => {
      const d = a.M && Ad({
        type: 46,
        g: 0
      }, w.m(a.M), b, "fn:number", !1);
      if (!d) throw lc("fn:number needs an atomizable context item.");
      return Vd(a, b, c, d);
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "random-number-generator",
    j: [],
    i: {
      type: 61,
      g: 3
    },
    callFunction: Xd
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "random-number-generator",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 61,
      g: 3
    },
    callFunction: Xd
  }];
  function Zd() {
    throw Error("FOCH0002: No collations are supported");
  }
  function $d(a, b, c, d) {
    if (null === b.M) throw lc("The function which was called depends on dynamic context, which is absent.");
    return a(b, c, d, w.m(b.M));
  }
  const ae = (a, b, c, d) => d.X({
      empty: () => w.m(g("", 1)),
      default: () => d.map(e => {
        if (v(e.type, 53)) {
          const f = pc(e, b).first();
          return v(e.type, 47) ? jd(f, 1) : f;
        }
        return jd(e, 1);
      })
    }),
    be = (a, b, c, d, e) => A([e], ([f]) => qc(d, b).N(h => {
      h = h.map(k => jd(k, 1).value).join(f.value);
      return w.m(g(h, 1));
    })),
    ce = (a, b, c, d) => {
      if (d.F()) return w.m(g(0, 5));
      a = d.first().value;
      return w.m(g(Array.from(a).length, 5));
    },
    ee = (a, b, c, d, e, f) => {
      const h = Ud(!1, a, b, c, e, null),
        k = null !== f ? Ud(!1, a, b, c, f, null) : null;
      let l = !1,
        n = null,
        t = null,
        u = null;
      return w.create({
        next: () => {
          if (l) return p;
          if (!n && (n = d.first(), null === n)) return l = !0, q(g("", 1));
          t ||= h.first();
          !u && f && (u = null, u = k.first());
          l = !0;
          return q(g(Array.from(n.value).slice(Math.max(t.value - 1, 0), f ? t.value + u.value - 1 : void 0).join(""), 1));
        }
      });
    },
    ge = (a, b, c, d, e) => {
      if (d.F() || 0 === d.first().value.length) return w.empty();
      a = d.first().value;
      e = e.first().value;
      e = fe(e);
      e.lastIndex = 0;
      b = [];
      c = e.exec(a);
      for (d = 0; c;) b.push(a.slice(d, c.index)), d = e.lastIndex, c = e.exec(a);
      b.push(a.slice(d));
      return w.create(b.map(f => g(f, 1)));
    },
    he = (a, b, c, d) => {
      if (d.F()) return w.m(g("", 1));
      a = d.first().value.trim();
      return w.m(g(a.replace(/\s+/g, " "), 1));
    },
    ie = new Map(),
    je = new Map();
  function fe(a) {
    if (je.has(a)) return je.get(a);
    let b;
    try {
      b = new RegExp(a, "g");
    } catch (c) {
      throw Error(`FORX0002: ${c}`);
    }
    if (b.test("")) throw Error(`FORX0003: the pattern ${a} matches the zero length string`);
    je.set(a, b);
    return b;
  }
  var ke = [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "compare",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: (a, b, c, d, e) => {
      if (d.F() || e.F()) return w.empty();
      a = d.first().value;
      e = e.first().value;
      return a > e ? w.m(g(1, 5)) : a < e ? w.m(g(-1, 5)) : w.m(g(0, 5));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "compare",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Zd
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "concat",
    j: [{
      type: 46,
      g: 0
    }, {
      type: 46,
      g: 0
    }, 4],
    i: {
      type: 1,
      g: 3
    },
    callFunction: (a, b, c, ...d) => {
      d = d.map(e => qc(e, b).N(f => w.m(g(f.map(h => null === h ? "" : jd(h, 1).value).join(""), 1))));
      return A(d, e => w.m(g(e.map(f => f.value).join(""), 1)));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "contains",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: Zd
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "contains",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: (a, b, c, d, e) => {
      a = d.F() ? "" : d.first().value;
      e = e.F() ? "" : e.first().value;
      return 0 === e.length ? w.aa() : 0 === a.length ? w.T() : a.includes(e) ? w.aa() : w.T();
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "ends-with",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: (a, b, c, d, e) => {
      a = e.F() ? "" : e.first().value;
      if (0 === a.length) return w.aa();
      d = d.F() ? "" : d.first().value;
      return 0 === d.length ? w.T() : d.endsWith(a) ? w.aa() : w.T();
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "ends-with",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: Zd
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "normalize-space",
    j: [{
      type: 1,
      g: 0
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: he
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "normalize-space",
    j: [],
    i: {
      type: 1,
      g: 3
    },
    callFunction: $d.bind(null, (a, b, c, d) => he(a, b, c, ae(a, b, c, d)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "starts-with",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: (a, b, c, d, e) => {
      a = e.F() ? "" : e.first().value;
      if (0 === a.length) return w.aa();
      d = d.F() ? "" : d.first().value;
      return 0 === d.length ? w.T() : d.startsWith(a) ? w.aa() : w.T();
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "starts-with",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: Zd
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string",
    j: [{
      type: 59,
      g: 0
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: ae
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string",
    j: [],
    i: {
      type: 1,
      g: 3
    },
    callFunction: $d.bind(null, ae)
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "substring-before",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: (a, b, c, d, e) => {
      a = d.F() ? "" : d.first().value;
      e = e.F() ? "" : e.first().value;
      if ("" === e) return w.m(g("", 1));
      e = a.indexOf(e);
      return -1 === e ? w.m(g("", 1)) : w.m(g(a.substring(0, e), 1));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "substring-after",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: (a, b, c, d, e) => {
      a = d.F() ? "" : d.first().value;
      e = e.F() ? "" : e.first().value;
      if ("" === e) return w.m(g(a, 1));
      b = a.indexOf(e);
      return -1 === b ? w.m(g("", 1)) : w.m(g(a.substring(b + e.length), 1));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "substring",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 3,
      g: 3
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: ee
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "substring",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 3,
      g: 3
    }, {
      type: 3,
      g: 3
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: ee
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "upper-case",
    j: [{
      type: 1,
      g: 0
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: (a, b, c, d) => d.F() ? w.m(g("", 1)) : d.map(e => g(e.value.toUpperCase(), 1))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "lower-case",
    j: [{
      type: 1,
      g: 0
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: (a, b, c, d) => d.F() ? w.m(g("", 1)) : d.map(e => g(e.value.toLowerCase(), 1))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string-join",
    j: [{
      type: 46,
      g: 2
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction: be
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string-join",
    j: [{
      type: 46,
      g: 2
    }],
    i: {
      type: 1,
      g: 3
    },
    callFunction(a, b, c, d) {
      return be(a, b, c, d, w.m(g("", 1)));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string-length",
    j: [{
      type: 1,
      g: 0
    }],
    i: {
      type: 5,
      g: 3
    },
    callFunction: ce
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string-length",
    j: [],
    i: {
      type: 5,
      g: 3
    },
    callFunction: $d.bind(null, (a, b, c, d) => ce(a, b, c, ae(a, b, c, d)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "tokenize",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 1,
      g: 2
    },
    callFunction() {
      throw Error("Not implemented: Using flags in tokenize is not supported");
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "tokenize",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 1,
      g: 2
    },
    callFunction: ge
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "tokenize",
    j: [{
      type: 1,
      g: 0
    }],
    i: {
      type: 1,
      g: 2
    },
    callFunction(a, b, c, d) {
      return ge(a, b, c, he(a, b, c, d), w.m(g(" ", 1)));
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }, {
      type: 1,
      g: 3
    }],
    callFunction: (a, b, c, d, e, f) => A([d, e, f], ([h, k, l]) => {
      h = Array.from(h ? h.value : "");
      const n = Array.from(k.value),
        t = Array.from(l.value);
      k = h.map(u => {
        if (n.includes(u)) {
          if (u = n.indexOf(u), u <= t.length) return t[u];
        } else return u;
      });
      return w.m(g(k.join(""), 1));
    }),
    localName: "translate",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 5,
      g: 2
    }],
    callFunction: (a, b, c, d) => d.N(e => {
      e = e.map(f => {
        f = f.value;
        if (9 === f || 10 === f || 13 === f || 32 <= f && 55295 >= f || 57344 <= f && 65533 >= f || 65536 <= f && 1114111 >= f) return String.fromCodePoint(f);
        throw Error("FOCH0001");
      }).join("");
      return w.m(g(e, 1));
    }),
    localName: "codepoints-to-string",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }],
    callFunction: (a, b, c, d) => A([d], ([e]) => {
      e = e ? e.value.split("") : [];
      return 0 === e.length ? w.empty() : w.create(e.map(f => g(f.codePointAt(0), 5)));
    }),
    localName: "string-to-codepoints",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 5,
      g: 2
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }],
    callFunction: (a, b, c, d) => A([d], ([e]) => null === e || 0 === e.value.length ? w.create(g("", 1)) : w.create(g(encodeURIComponent(e.value).replace(/[!'()*]/g, f => "%" + f.charCodeAt(0).toString(16).toUpperCase()), 1))),
    localName: "encode-for-uri",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }],
    callFunction: (a, b, c, d) => A([d], ([e]) => null === e || 0 === e.value.length ? w.create(g("", 1)) : w.create(g(e.value.replace(/([\u00A0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFEF "<>{}|\\^`/\n\u007f\u0080-\u009f]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g, f => encodeURI(f)), 1))),
    localName: "iri-to-uri",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 0
    }],
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => {
      if (null === f || null === h) return w.empty();
      f = f.value;
      var k = h.value;
      if (f.length !== k.length) return w.T();
      h = f.split("");
      f = k.split("");
      for (k = 0; k < h.length; k++) if (h[k].codePointAt(0) !== f[k].codePointAt(0)) return w.T();
      return w.aa();
    }),
    localName: "codepoint-equal",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 0
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => {
      f = f ? f.value : "";
      h = h.value;
      let k = ie.get(h);
      if (!k) {
        try {
          k = (0, wd.compile)(h, {
            language: "xpath"
          });
        } catch (l) {
          throw Error(`FORX0002: ${l}`);
        }
        ie.set(h, k);
      }
      return k(f) ? w.aa() : w.T();
    }),
    localName: "matches",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }, {
      type: 1,
      g: 3
    }],
    callFunction: (a, b, c, d, e, f) => A([d, e, f], ([h, k, l]) => {
      h = h ? h.value : "";
      k = k.value;
      l = l.value;
      if (l.includes("$0")) throw Error("Using $0 in fn:replace to replace substrings with full matches is not supported.");
      l = l.split(/((?:\$\$)|(?:\\\$)|(?:\\\\))/).map(n => {
        switch (n) {
          case "\\$":
            return "$$";
          case "\\\\":
            return "\\";
          case "$$":
            throw Error('FORX0004: invalid replacement: "$$"');
          default:
            return n;
        }
      }).join("");
      k = fe(k);
      h = h.replace(k, l);
      return w.m(g(h, 1));
    }),
    localName: "replace",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }, {
      type: 1,
      g: 3
    }, {
      type: 1,
      g: 3
    }],
    localName: "replace",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    },
    callFunction() {
      throw Error("Not implemented: Using flags in replace is not supported");
    }
  }];
  const le = new WeakMap();
  let me = 0;
  function ne(a, b, c, d, e) {
    if (null === c.M) throw lc(`The function ${a} depends on dynamic context, which is absent.`);
    return b(c, d, e, w.m(c.M));
  }
  const oe = (a, b, c, d) => A([d], ([e]) => {
      if (null === e) return w.empty();
      e = e.value;
      switch (e.node.nodeType) {
        case 1:
        case 2:
          return w.m(g(new Sa(e.node.prefix, e.node.namespaceURI, e.node.localName), 23));
        case 7:
          return w.m(g(new Sa("", "", e.node.target), 23));
        default:
          return w.empty();
      }
    }),
    pe = (a, b, c, d) => d.X({
      default: () => ae(a, b, c, oe(a, b, c, d)),
      empty: () => w.m(g("", 1))
    }),
    qe = (a, b, c, d) => qc(d, b),
    re = (a, b, c, d) => {
      if (d.F()) return w.m(g("", 1));
      if (!v(d.first().type, 53)) throw Error("XPTY0004: The context item must be a node.");
      c = d.first().value;
      a = w;
      b = a.m;
      c = c.node;
      le.has(c) || le.set(c, `id${++me}`);
      c = le.get(c);
      return b.call(a, g(c, 1));
    },
    se = (a, b, c, d) => A([d], ([e]) => {
      e = e ? e.value : null;
      return null !== e && jb(b.h, e, null) ? w.aa() : w.T();
    });
  function te(a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return a === b ? !0 : 5 > a.length || !a.startsWith(b) ? !1 : te(a.replace(/-[a-z0-9]+$/, ""), b);
  }
  const ue = (a, b, c, d, e) => {
      b = b.h;
      if (d.F()) d = "";else if (v(d.first().type, 1)) d = d.first().value;else throw Error("XPTY0004: The first argument of lang must be a string.");
      if (e) e = e.first().value;else {
        if (!a || !a.M) throw lc("The function lang depends on dynamic context if a node is not passed as the second argument.");
        if (!v(a.M.type, 53)) throw Error("XPTY0004: The context item must be a node.");
        e = a.M.value;
      }
      a: {
        for (a = d; e;) if (1 !== e.node.nodeType) e = x(b, e);else if (1 === e.node.nodeType) {
          if (d = fb(b, e, "xml:lang")) {
            b = te(d, a) ? w.aa() : w.T();
            break a;
          }
          e = x(b, e);
        }
        b = w.T();
      }
      return b;
    },
    ve = (a, b, c, d) => A([d], ([e]) => {
      function f(n) {
        let t = 0,
          u = n;
        for (; null !== u;) (n.node.nodeType !== u.node.nodeType ? 0 : 1 === u.node.nodeType ? u.node.localName === n.node.localName && u.node.namespaceURI === n.node.namespaceURI : 7 === u.node.nodeType ? u.node.target === n.node.target : 1) && t++, u = mb(h, u, null);
        return t;
      }
      if (null === e) return w.empty();
      const h = b.h;
      let k = "";
      for (e = e.value; null !== x(b.h, e, null); e = x(b.h, e, null)) switch (e.node.nodeType) {
        case 1:
          var l = e;
          k = `/Q{${l.node.namespaceURI || ""}}${l.node.localName}[${f(l)}]${k}`;
          break;
        case 2:
          l = e;
          k = `/@${l.node.namespaceURI ? `Q{${l.node.namespaceURI}}` : ""}${l.node.localName}${k}`;
          break;
        case 3:
          k = `/text()[${f(e)}]${k}`;
          break;
        case 7:
          l = e;
          k = `/processing-instruction(${l.node.target})[${f(l)}]${k}`;
          break;
        case 8:
          k = `/comment()[${f(e)}]${k}`;
      }
      return 9 === e.node.nodeType ? w.create(g(k || "/", 1)) : w.create(g("Q{http://www.w3.org/2005/xpath-functions}root()" + k, 1));
    }),
    we = (a, b, c, d) => d.map(e => g(e.value.node.namespaceURI || "", 20)),
    xe = (a, b, c, d) => d.X({
      default: () => d.map(e => 7 === e.value.node.nodeType ? g(e.value.node.target, 1) : g(e.value.node.localName || "", 1)),
      empty: () => w.m(g("", 1))
    });
  function ye(a, b, c) {
    if (2 === b.node.nodeType) return md(b, c);
    for (; c;) {
      if (md(b, c)) return !0;
      if (9 === c.node.nodeType) break;
      c = x(a, c, null);
    }
    return !1;
  }
  const ze = (a, b, c, d) => d.map(e => {
    if (!v(e.type, 53)) throw Error("XPTY0004 Argument passed to fn:root() should be of the type node()");
    let f;
    for (e = e.value; e;) f = e, e = x(b.h, f, null);
    return rb(f);
  });
  var Ae = [{
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: pe,
    localName: "name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "name", pe),
    localName: "name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 53,
      g: 3
    }],
    callFunction: we,
    localName: "namespace-uri",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 20,
      g: 3
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "namespace-uri", we),
    localName: "namespace-uri",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 20,
      g: 3
    }
  }, {
    j: [{
      type: 53,
      g: 2
    }],
    callFunction: (a, b, c, d) => d.N(e => {
      if (!e.length) return w.empty();
      e = td(b.h, e).reduceRight((f, h, k, l) => {
        if (k === l.length - 1) return f.push(h), f;
        if (ye(b.h, h.value, f[0].value)) return f;
        f.unshift(h);
        return f;
      }, []);
      return w.create(e);
    }),
    localName: "innermost",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 53,
      g: 2
    }
  }, {
    j: [{
      type: 53,
      g: 2
    }],
    callFunction: (a, b, c, d) => d.N(e => {
      if (!e.length) return w.empty();
      e = td(b.h, e).reduce((f, h, k) => {
        if (0 === k) return f.push(h), f;
        if (ye(b.h, f[f.length - 1].value, h.value)) return f;
        f.push(h);
        return f;
      }, []);
      return w.create(e);
    }, 1),
    localName: "outermost",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 53,
      g: 2
    }
  }, {
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: se,
    localName: "has-children",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "has-children", se),
    localName: "has-children",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: ve,
    localName: "path",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 0
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "path", ve),
    localName: "path",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 0
    }
  }, {
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: oe,
    localName: "node-name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 23,
      g: 0
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "node-name", oe),
    localName: "node-name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 23,
      g: 0
    }
  }, {
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: xe,
    localName: "local-name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "local-name", xe),
    localName: "local-name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: ze,
    localName: "root",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 53,
      g: 0
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "root", ze),
    localName: "root",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 53,
      g: 0
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "data", qe),
    localName: "data",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: qe,
    localName: "data",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 2
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }],
    callFunction: ue,
    localName: "lang",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 1,
      g: 0
    }, {
      type: 53,
      g: 3
    }],
    callFunction: ue,
    localName: "lang",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [],
    callFunction: ne.bind(null, "generate-id", re),
    localName: "generate-id",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }, {
    j: [{
      type: 53,
      g: 0
    }],
    callFunction: re,
    localName: "generate-id",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }];
  function Be(a, b) {
    let c = 0;
    const d = a.length;
    let e = !1,
      f = null;
    return {
      next: () => {
        if (!e) {
          for (; c < d;) {
            f ||= b(a[c], c, a);
            const h = f.next(0);
            f = null;
            if (h.value) c++;else return q(!1);
          }
          e = !0;
          return q(!0);
        }
        return p;
      }
    };
  }
  function Ce(a) {
    a = a.node.nodeType;
    return 1 === a || 3 === a;
  }
  function De(a, b) {
    if ((v(a.type, 4) || v(a.type, 6)) && (v(b.type, 4) || v(b.type, 6))) {
      var c = jd(a, 6),
        d = jd(b, 6);
      return c.value === d.value || isNaN(a.value) && isNaN(b.value);
    }
    return (v(a.type, 4) || v(a.type, 6) || v(a.type, 3)) && (v(b.type, 4) || v(b.type, 6) || v(b.type, 3)) ? (c = jd(a, 3), d = jd(b, 3), c.value === d.value || isNaN(a.value) && isNaN(b.value)) : v(a.type, 23) && v(b.type, 23) ? a.value.namespaceURI === b.value.namespaceURI && a.value.localName === b.value.localName : (v(a.type, 9) || v(a.type, 7) || v(a.type, 8) || v(a.type, 11) || v(a.type, 12) || v(a.type, 13) || v(a.type, 14) || v(a.type, 15)) && (v(b.type, 9) || v(b.type, 7) || v(b.type, 8) || v(b.type, 11) || v(b.type, 12) || v(b.type, 13) || v(b.type, 14) || v(b.type, 15)) ? Ob(a.value, b.value) : (v(a.type, 16) || v(a.type, 17) || v(a.type, 18)) && (v(b.type, 16) || v(b.type, 17) || v(b.type, 17)) ? vb(a.value, b.value) : a.value === b.value;
  }
  function Ee(a, b, c) {
    const [d, e] = [b, c].map(f => ({
      type: 1,
      value: f.reduce((h, k) => h += pc(k, a).first().value, "")
    }));
    return q(De(d, e));
  }
  function Fe(a, b, c, d) {
    for (; a.value && v(a.value.type, 56);) {
      b.push(a.value);
      const e = lb(d, a.value.value);
      a = c.next(0);
      if (e && 3 !== e.node.nodeType) break;
    }
    return a;
  }
  function Ge(a, b, c, d, e) {
    const f = b.h,
      h = d.value,
      k = e.value;
    let l = null,
      n = null,
      t = null,
      u;
    const z = [],
      y = [];
    return {
      next: () => {
        for (; !u;) if (l ||= h.next(0), l = Fe(l, z, h, f), n ||= k.next(0), n = Fe(n, y, k, f), z.length || y.length) {
          var G = Ee(b, z, y);
          z.length = 0;
          y.length = 0;
          if (!1 === G.value) return u = !0, G;
        } else {
          if (l.done || n.done) return u = !0, q(l.done === n.done);
          t ||= He(a, b, c, l.value, n.value);
          G = t.next(0);
          t = null;
          if (!1 === G.value) return u = !0, G;
          n = l = null;
        }
        return p;
      }
    };
  }
  function Ie(a, b, c, d, e) {
    return d.h.length !== e.h.length ? kd(!1) : Be(d.h, f => {
      const h = e.h.find(k => De(k.key, f.key));
      return h ? Ge(a, b, c, f.value(), h.value()) : kd(!1);
    });
  }
  function Je(a, b, c, d, e) {
    return d.h.length !== e.h.length ? kd(!1) : Be(d.h, (f, h) => {
      h = e.h[h];
      return Ge(a, b, c, f(), h());
    });
  }
  function Ke(a, b, c, d, e) {
    d = hb(b.h, d.value);
    e = hb(b.h, e.value);
    d = d.filter(f => Ce(f));
    e = e.filter(f => Ce(f));
    d = w.create(d.map(f => rb(f)));
    e = w.create(e.map(f => rb(f)));
    return Ge(a, b, c, d, e);
  }
  function Le(a, b, c, d, e) {
    const f = Ge(a, b, c, oe(a, b, c, w.m(d)), oe(a, b, c, w.m(e))),
      h = Ke(a, b, c, d, e);
    d = eb(b.h, d.value).filter(n => "http://www.w3.org/2000/xmlns/" !== n.node.namespaceURI).sort((n, t) => n.node.nodeName > t.node.nodeName ? 1 : -1).map(n => rb(n));
    e = eb(b.h, e.value).filter(n => "http://www.w3.org/2000/xmlns/" !== n.node.namespaceURI).sort((n, t) => n.node.nodeName > t.node.nodeName ? 1 : -1).map(n => rb(n));
    const k = Ge(a, b, c, w.create(d), w.create(e));
    let l = !1;
    return {
      next: () => {
        if (l) return p;
        var n = f.next(0);
        if (!n.done && !1 === n.value) return l = !0, n;
        n = k.next(0);
        if (!n.done && !1 === n.value) return l = !0, n;
        n = h.next(0);
        l = !0;
        return n;
      }
    };
  }
  function Me(a, b, c, d, e) {
    const f = Ge(a, b, c, oe(a, b, c, w.m(d)), oe(a, b, c, w.m(e)));
    let h = !1;
    return {
      next: () => {
        if (h) return p;
        const k = f.next(0);
        return k.done || !1 !== k.value ? q(De(pc(d, b).first(), pc(e, b).first())) : (h = !0, k);
      }
    };
  }
  function He(a, b, c, d, e) {
    if (v(d.type, 46) && v(e.type, 46)) return kd(De(d, e));
    if (v(d.type, 61) && v(e.type, 61)) return Ie(a, b, c, d, e);
    if (v(d.type, 62) && v(e.type, 62)) return Je(a, b, c, d, e);
    if (v(d.type, 53) && v(e.type, 53)) {
      if (v(d.type, 55) && v(e.type, 55)) return Ke(a, b, c, d, e);
      if (v(d.type, 54) && v(e.type, 54)) return Le(a, b, c, d, e);
      if (v(d.type, 47) && v(e.type, 47) || v(d.type, 57) && v(e.type, 57) || v(d.type, 58) && v(e.type, 58)) return Me(a, b, c, d, e);
    }
    return kd(!1);
  }
  var Ne = class extends cc {
    constructor() {
      super({
        M: null,
        Aa: -1,
        ta: w.empty(),
        ra: {}
      });
    }
  };
  var Oe = (a = "Can not execute an updating expression in a non-updating context.") => Error(`XUST0001: ${a}`),
    Pe = a => Error(`XUTY0004: The attribute ${a.name}="${a.value}" follows a node that is not an attribute node.`),
    Qe = () => Error("XUTY0005: The target of a insert expression with into must be a single element or document node."),
    Re = () => Error("XUTY0006: The target of a insert expression with before or after must be a single element, text, comment, or processing instruction node."),
    Se = () => Error("XUTY0008: The target of a replace expression must be a single element, attribute, text, comment, or processing instruction node."),
    Te = () => Error("XUTY0012: The target of a rename expression must be a single element, attribute, or processing instruction node."),
    Ue = a => Error(`XUDY0017: The target ${a.outerHTML} is used in more than one replace value of expression.`),
    Ve = a => Error(`XUDY0021: Applying the updates will result in the XDM instance violating constraint: '${a}'`),
    We = a => Error(`XUDY0023: The namespace binding ${a} is conflicting.`),
    Xe = a => Error(`XUDY0024: The namespace binding ${a} is conflicting.`),
    Ye = () => Error("XUDY0027: The target for an insert, replace, or rename expression expression should not be empty.");
  function C(a, b, c) {
    b && null !== b.M ? a.B ? (null === a.ob && (a.ob = Ra(a.h(new Ne(), c).hb())), a = a.ob()) : a = a.h(b, c) : a = a.h(b, c);
    return a;
  }
  var D = class {
    constructor(a, b, c = {
      B: !1,
      W: !1,
      R: "unsorted",
      subtree: !1
    }, d = !1, e) {
      this.o = a;
      this.ia = c.R || "unsorted";
      this.subtree = !!c.subtree;
      this.W = !!c.W;
      this.B = !!c.B;
      this.Fa = b;
      this.I = !1;
      this.ob = null;
      this.Qb = d;
      this.type = e;
    }
    D() {
      return null;
    }
    v(a) {
      this.Fa.forEach(b => b.v(a));
      if (!this.Qb && this.Fa.some(b => b.I)) throw Oe();
    }
  };
  var Ze = class {
    constructor(a, b) {
      this.J = a;
      this.da = b;
    }
  };
  var $e = class {
    constructor(a) {
      a && "object" === typeof a && "nodeType" in a && (a = a.ownerDocument || a, "function" === typeof a.createElementNS && "function" === typeof a.createProcessingInstruction && "function" === typeof a.createTextNode && "function" === typeof a.createComment && (this.h = a));
      this.h || (this.h = null);
    }
    createAttributeNS(a, b) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createAttributeNS(a, b);
    }
    createCDATASection(a) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createCDATASection(a);
    }
    createComment(a) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createComment(a);
    }
    createDocument() {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.implementation.createDocument(null, null, null);
    }
    createElementNS(a, b) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createElementNS(a, b);
    }
    createProcessingInstruction(a, b) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createProcessingInstruction(a, b);
    }
    createTextNode(a) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createTextNode(a);
    }
  };
  function af(a, b, c, d) {
    return eb(d, a, `name-${b}`).some(e => e.node.localName === b && e.node.namespaceURI === c);
  }
  var bf = (a, b, c, d) => {
      const e = x(c, a).node,
        f = (a = lb(c, a)) ? a.node : null;
      b.forEach(h => {
        d.insertBefore(e, h.node, f);
      });
    },
    cf = (a, b, c, d) => {
      const e = x(c, a).node;
      b.forEach(f => {
        d.insertBefore(e, f.node, a.node);
      });
    },
    df = (a, b, c, d) => {
      const e = (c = jb(c, a)) ? c.node : null;
      b.forEach(f => {
        d.insertBefore(a.node, f.node, e);
      });
    },
    ef = (a, b, c) => {
      b.forEach(d => {
        c.insertBefore(a.node, d.node, null);
      });
    },
    ff = (a, b, c, d) => {
      b.forEach(e => {
        const f = e.node.localName,
          h = e.node.namespaceURI;
        if (af(a, f, h, c)) throw Ve(`An attribute ${h ? `Q{${h}}${f}` : f} already exists.`);
        d.setAttributeNS(a.node, h, f, ib(c, e));
      });
    },
    hf = (a, b, c, d, e) => {
      d ||= new $e(a ? a.node : null);
      let f;
      switch (a.node.nodeType) {
        case 1:
          const h = c.getAllAttributes(a.node),
            k = c.getChildNodes(a.node),
            l = d.createElementNS(b.namespaceURI, b.za());
          f = {
            node: l,
            G: null
          };
          h.forEach(n => {
            e.setAttributeNS(l, n.namespaceURI, n.nodeName, n.value);
          });
          k.forEach(n => {
            e.insertBefore(l, n, null);
          });
          break;
        case 2:
          b = d.createAttributeNS(b.namespaceURI, b.za());
          b.value = ib(c, a);
          f = {
            node: b,
            G: null
          };
          break;
        case 7:
          f = {
            node: d.createProcessingInstruction(b.za(), ib(c, a)),
            G: null
          };
      }
      if (!x(c, a)) throw Error("Not supported: renaming detached nodes.");
      gf(a, [f], c, e);
    },
    jf = (a, b, c, d) => {
      c.getChildNodes(a.node).forEach(e => d.removeChild(a.node, e));
      b && d.insertBefore(a.node, b.node, null);
    },
    gf = (a, b, c, d) => {
      const e = x(c, a);
      var f = a.node.nodeType;
      if (2 === f) {
        if (b.some(k => 2 !== k.node.nodeType)) throw Error('Constraint "If $target is an attribute node, $replacement must consist of zero or more attribute nodes." failed.');
        const h = e ? e.node : null;
        d.removeAttributeNS(h, a.node.namespaceURI, a.node.localName);
        b.forEach(k => {
          const l = k.node.localName,
            n = k.node.namespaceURI;
          if (af(e, l, n, c)) throw Ve(`An attribute ${n ? `Q{${n}}${l}` : l} already exists.`);
          d.setAttributeNS(h, n, l, ib(c, k));
        });
      }
      if (1 === f || 3 === f || 8 === f || 7 === f) {
        const h = (f = lb(c, a)) ? f.node : null;
        d.removeChild(e.node, a.node);
        b.forEach(k => {
          d.insertBefore(e.node, k.node, h);
        });
      }
    };
  var lf = (a, b, c, d) => {
    kf(a, b);
    a.filter(e => -1 !== ["insertInto", "insertAttributes", "replaceValue", "rename"].indexOf(e.type)).forEach(e => {
      switch (e.type) {
        case "insertInto":
          ef(e.target, e.content, d);
          break;
        case "insertAttributes":
          ff(e.target, e.content, b, d);
          break;
        case "rename":
          hf(e.target, e.o, b, c, d);
          break;
        case "replaceValue":
          var f = e.target;
          e = e.o;
          if (2 === f.node.nodeType) {
            const h = x(b, f);
            h ? d.setAttributeNS(h.node, f.node.namespaceURI, f.node.localName, e) : f.node.value = e;
          } else d.setData(f.node, e);
      }
    });
    a.filter(e => -1 !== ["insertBefore", "insertAfter", "insertIntoAsFirst", "insertIntoAsLast"].indexOf(e.type)).forEach(e => {
      switch (e.type) {
        case "insertAfter":
          bf(e.target, e.content, b, d);
          break;
        case "insertBefore":
          cf(e.target, e.content, b, d);
          break;
        case "insertIntoAsFirst":
          df(e.target, e.content, b, d);
          break;
        case "insertIntoAsLast":
          ef(e.target, e.content, d);
      }
    });
    a.filter(e => "replaceNode" === e.type).forEach(e => {
      gf(e.target, e.o, b, d);
    });
    a.filter(e => "replaceElementContent" === e.type).forEach(e => {
      jf(e.target, e.text, b, d);
    });
    a.filter(e => "delete" === e.type).forEach(e => {
      e = e.target;
      var f = x(b, e);
      (f = f ? f.node : null) && (2 === e.node.nodeType ? d.removeAttributeNS(f, e.node.namespaceURI, e.node.localName) : d.removeChild(f, e.node));
    });
    if (a.some(e => "put" === e.type)) throw Error('Not implemented: the execution for pendingUpdate "put" is not yet implemented.');
  };
  const kf = (a, b) => {
    function c(f, h) {
      const k = new Set();
      a.filter(l => l.type === f).map(l => l.target).forEach(l => {
        l = l ? l.node : null;
        k.has(l) && h(l);
        k.add(l);
      });
    }
    c("rename", f => {
      throw Error(`XUDY0015: The target ${f.outerHTML} is used in more than one rename expression.`);
    });
    c("replaceNode", f => {
      throw Error(`XUDY0016: The target ${f.outerHTML} is used in more than one replace expression.`);
    });
    c("replaceValue", f => {
      throw Ue(f);
    });
    c("replaceElementContent", f => {
      throw Ue(f);
    });
    const d = new Map(),
      e = f => new Sa(f.node.prefix, f.node.namespaceURI, f.node.localName);
    a.filter(f => "replaceNode" === f.type && 2 === f.target.node.nodeType).forEach(f => {
      var h = x(b, f.target);
      h = h ? h.node : null;
      const k = d.get(h);
      k ? k.push(...f.o.map(e)) : d.set(h, f.o.map(e));
    });
    a.filter(f => "rename" === f.type && 2 === f.target.node.nodeType).forEach(f => {
      var h = x(b, f.target);
      if (h) {
        h = h.node;
        var k = d.get(h);
        k ? k.push(f.o) : d.set(h, [f.o]);
      }
    });
    d.forEach(f => {
      const h = {};
      f.forEach(k => {
        h[k.prefix] || (h[k.prefix] = k.namespaceURI);
        if (h[k.prefix] !== k.namespaceURI) throw Xe(k.namespaceURI);
      });
    });
  };
  var mf = (a, ...b) => a.concat(...b.filter(Boolean));
  function nf(a) {
    return a.I ? (b, c) => a.s(b, c) : (b, c) => {
      const d = a.h(b, c);
      return {
        next: () => {
          const e = d.O();
          return q({
            da: [],
            J: e
          });
        }
      };
    };
  }
  var of = class extends D {
    constructor(a, b, c, d) {
      super(a, b, c, !0, d);
      this.I = !0;
    }
    h() {
      throw Oe();
    }
  };
  function pf(a, b) {
    a = a.next(0);
    b(a.value.da);
    return w.create(a.value.J);
  }
  function qf(a) {
    a.Fa.some(b => b.I) && (a.I = !0);
  }
  var rf = class extends of {
    constructor(a, b, c, d) {
      super(a, b, c, d);
      this.I = this.Fa.some(e => e.I);
    }
    h(a, b) {
      return this.A(a, b, this.Fa.map(c => d => c.h(d, b)));
    }
    s(a, b) {
      let c = [];
      const d = this.A(a, b, this.Fa.map(f => f.I ? h => {
        h = f.s(h, b);
        return pf(h, k => c = mf(c, k));
      } : h => f.h(h, b)));
      let e = !1;
      return {
        next: () => {
          if (e) return p;
          const f = d.O();
          e = !0;
          return q(new Ze(f, c));
        }
      };
    }
    v(a) {
      super.v(a);
      qf(this);
    }
  };
  const sf = ["external", "attribute", "nodeName", "nodeType", "universal"],
    tf = sf.length;
  function uf(a, b) {
    for (let c = 0; c < tf; ++c) {
      if (b.h[c] < a.h[c]) return 1;
      if (b.h[c] > a.h[c]) return -1;
    }
    return 0;
  }
  var vf = class {
    constructor(a) {
      this.h = sf.map(b => a[b] || 0);
      if (Object.keys(a).some(b => !sf.includes(b))) throw Error("Invalid specificity kind passed");
    }
    add(a) {
      const b = sf.reduce((c, d, e) => {
        c[d] = this.h[e] + a.h[e];
        return c;
      }, Object.create(null));
      return new vf(b);
    }
  };
  const wf = () => mc("Expected base expression of a function call to evaluate to a sequence of single function item");
  function xf(a, b, c, d) {
    const e = [];
    for (let f = 0; f < b.length; ++f) {
      if (null === b[f]) {
        e.push(null);
        continue;
      }
      const h = Ad(a[f], b[f], c, d, !1);
      e.push(h);
    }
    return e;
  }
  function Df(a, b) {
    if (!v(a.type, 60)) throw mc("Expected base expression to evaluate to a function item");
    if (a.v !== b) throw wf();
    return a;
  }
  function Ef(a, b, c, d, e, f, h) {
    let k = 0;
    e = e.map(l => l ? null : f[k++](c));
    e = xf(a.o, e, d, a.D);
    if (0 <= e.indexOf(null)) return Ua(a, e);
    b = b.apply(void 0, [c, d, h, ...e]);
    return Ad(a.s, b, d, a.D, !0);
  }
  var Gf = class extends rf {
    constructor(a, b, c) {
      super(new vf({
        external: 1
      }), [a].concat(b.filter(d => !!d)), {
        R: "unsorted",
        W: !1,
        subtree: !1,
        B: !1
      }, c);
      this.ma = b.length;
      this.P = b.map(d => null === d);
      this.L = null;
      this.ya = a;
      this.La = b;
    }
    s(a, b) {
      if (!this.l || !this.l.I) return super.s(a, b);
      let c = [];
      const d = Ef(this.l, (f, h, k, ...l) => pf(this.l.value(f, h, k, ...l), n => {
        c = mf(c, n);
      }), a, b, this.P, this.La.map(f => () => f.I ? pf(f.s(a, b), h => {
        c = mf(c, h);
      }) : C(f, a, b)), this.L);
      let e = !1;
      return {
        next: () => {
          if (e) return p;
          const f = d.O();
          e = !0;
          return q({
            da: c,
            J: f
          });
        }
      };
    }
    A(a, b, [c, ...d]) {
      if (this.l) return Ef(this.l, (f, h, k, ...l) => this.l.value(f, h, k, ...l), a, b, this.P, d, this.L);
      const e = c(a);
      return e.X({
        default: () => {
          throw wf();
        },
        m: () => e.N(([f]) => {
          f = Df(f, this.ma);
          if (f.I) throw Error("XUDY0038: The function returned by the PrimaryExpr of a dynamic function invocation can not be an updating function");
          return Ef(f, f.value, a, b, this.P, d, this.L);
        })
      });
    }
    v(a) {
      this.L = Ff(a);
      super.v(a);
      if (this.ya.B) {
        a = C(this.ya, null, null);
        if (!a.oa()) throw wf();
        this.l = Df(a.first(), this.ma);
        this.l.I && (this.I = !0);
      }
    }
  };
  const Hf = (a, b, c, d, e, f) => A([d, e, f], ([h, k, l]) => {
      k = k.value;
      l = l.value;
      if (k > h.h.length || 0 >= k) throw Error("FOAY0001: subarray start out of bounds.");
      if (0 > l) throw Error("FOAY0002: subarray length out of bounds.");
      if (k + l > h.h.length + 1) throw Error("FOAY0001: subarray start + length out of bounds.");
      return w.m(new pb(h.h.slice(k - 1, l + k - 1)));
    }),
    If = (a, b, c, d, e) => A([d], ([f]) => e.N(h => {
      h = h.map(l => l.value).sort((l, n) => n - l).filter((l, n, t) => t[n - 1] !== l);
      const k = f.h.concat();
      for (let l = 0, n = h.length; l < n; ++l) {
        const t = h[l];
        if (t > f.h.length || 0 >= t) throw Error("FOAY0001: subarray position out of bounds.");
        k.splice(t - 1, 1);
      }
      return w.m(new pb(k));
    })),
    Jf = a => v(a, 1) || v(a, 20) || v(a, 19),
    Kf = (a, b, c, d, e) => 0 === d.length ? 0 !== e.length : 0 !== e.length && He(a, b, c, d[0], e[0]).next(0).value ? Kf(a, b, c, d.slice(1), e.slice(1)) : d[0].value !== d[0].value ? !0 : Jf(d[0].type) && 0 !== e.length && Jf(e[0].type) ? d[0].value < e[0].value : 0 === e.length ? !1 : d[0].value < e[0].value,
    Lf = (a, b, c, d) => {
      d.sort((e, f) => Ge(a, b, c, w.create(e), w.create(f)).next(0).value ? 0 : Kf(a, b, c, e, f) ? -1 : 1);
      return w.m(new pb(d.map(e => () => w.create(e))));
    };
  function Mf(a) {
    return v(a.type, 62) ? jc(a.h.map(b => b().N(c => jc(c.map(Mf))))) : w.m(a);
  }
  var Nf = [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "size",
    j: [{
      type: 62,
      g: 3
    }],
    i: {
      type: 5,
      g: 3
    },
    callFunction: (a, b, c, d) => A([d], ([e]) => w.m(g(e.h.length, 5)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "get",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 5,
      g: 3
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction: ob
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "put",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 5,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d, e, f) => A([e, d], ([h, k]) => {
      h = h.value;
      if (0 >= h || h > k.h.length) throw Error("FOAY0001: array position out of bounds.");
      k = k.h.concat();
      k.splice(h - 1, 1, Ra(f));
      return w.m(new pb(k));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "append",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d, e) => A([d], ([f]) => w.m(new pb(f.h.concat([Ra(e)]))))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "subarray",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 5,
      g: 3
    }, {
      type: 5,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: Hf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "subarray",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 5,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction(a, b, c, d, e) {
      const f = w.m(g(d.first().value.length - e.first().value + 1, 5));
      return Hf(a, b, c, d, e, f);
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "remove",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 5,
      g: 2
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: If
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "insert-before",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 5,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d, e, f) => A([d, e], ([h, k]) => {
      k = k.value;
      if (k > h.h.length + 1 || 0 >= k) throw Error("FOAY0001: subarray position out of bounds.");
      h = h.h.concat();
      h.splice(k - 1, 0, Ra(f));
      return w.m(new pb(h));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "head",
    j: [{
      type: 62,
      g: 3
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction(a, b, c, d) {
      return ob(a, b, c, d, w.m(g(1, 5)));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "tail",
    j: [{
      type: 62,
      g: 3
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction(a, b, c, d) {
      return If(a, b, c, d, w.m(g(1, 5)));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "reverse",
    j: [{
      type: 62,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d) => A([d], ([e]) => w.m(new pb(e.h.concat().reverse())))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "join",
    j: [{
      type: 62,
      g: 2
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d) => d.N(e => {
      e = e.reduce((f, h) => f.concat(h.h), []);
      return w.m(new pb(e));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "for-each",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 60,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => {
      if (1 !== h.v) throw mc("The callback passed into array:for-each has a wrong arity.");
      f = f.h.map(k => Ra(h.value.call(void 0, a, b, c, xf(h.o, [k()], b, "array:for-each")[0])));
      return w.m(new pb(f));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "filter",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 60,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => {
      if (1 !== h.v) throw mc("The callback passed into array:filter has a wrong arity.");
      const k = f.h.map(t => {
          t = xf(h.o, [t()], b, "array:filter")[0];
          const u = h.value;
          return u(a, b, c, t);
        }),
        l = [];
      let n = !1;
      return w.create({
        next: () => {
          if (n) return p;
          for (let u = 0, z = f.h.length; u < z; ++u) {
            var t = k[u].fa();
            l[u] = t;
          }
          t = f.h.filter((u, z) => l[z]);
          n = !0;
          return q(new pb(t));
        }
      });
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "fold-left",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 59,
      g: 2
    }, {
      type: 60,
      g: 3
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction: (a, b, c, d, e, f) => A([d, f], ([h, k]) => {
      if (2 !== k.v) throw mc("The callback passed into array:fold-left has a wrong arity.");
      return h.h.reduce((l, n) => {
        n = xf(k.o, [n()], b, "array:fold-left")[0];
        return k.value.call(void 0, a, b, c, l, n);
      }, e);
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "fold-right",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 59,
      g: 2
    }, {
      type: 60,
      g: 3
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction: (a, b, c, d, e, f) => A([d, f], ([h, k]) => {
      if (2 !== k.v) throw mc("The callback passed into array:fold-right has a wrong arity.");
      return h.h.reduceRight((l, n) => {
        n = xf(k.o, [n()], b, "array:fold-right")[0];
        return k.value.call(void 0, a, b, c, l, n);
      }, e);
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "for-each-pair",
    j: [{
      type: 62,
      g: 3
    }, {
      type: 62,
      g: 3
    }, {
      type: 60,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d, e, f) => A([d, e, f], ([h, k, l]) => {
      if (2 !== l.v) throw mc("The callback passed into array:for-each-pair has a wrong arity.");
      const n = [];
      for (let t = 0, u = Math.min(h.h.length, k.h.length); t < u; ++t) {
        const [z, y] = xf(l.o, [h.h[t](), k.h[t]()], b, "array:for-each-pair");
        n[t] = Ra(l.value.call(void 0, a, b, c, z, y));
      }
      return w.m(new pb(n));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "sort",
    j: [{
      type: 62,
      g: 3
    }],
    i: {
      type: 62,
      g: 3
    },
    callFunction: (a, b, c, d) => A([d], ([e]) => {
      e = e.h.map(f => f().O());
      return Lf(a, b, c, e);
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
    localName: "flatten",
    j: [{
      type: 59,
      g: 2
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction: (a, b, c, d) => d.N(e => jc(e.map(Mf)))
  }];
  function E(a, b, c, d, e) {
    return e.F() ? e : w.m(jd(e.first(), a));
  }
  var Of = [{
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "untypedAtomic",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 19,
      g: 0
    },
    callFunction: E.bind(null, 19)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "error",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 39,
      g: 0
    },
    callFunction: E.bind(null, 39)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "string",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 1,
      g: 0
    },
    callFunction: E.bind(null, 1)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "boolean",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 0,
      g: 0
    },
    callFunction: E.bind(null, 0)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "decimal",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 4,
      g: 0
    },
    callFunction: E.bind(null, 4)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "float",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 6,
      g: 0
    },
    callFunction: E.bind(null, 6)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "double",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: E.bind(null, 3)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "duration",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 18,
      g: 0
    },
    callFunction: E.bind(null, 18)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "dateTime",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 9,
      g: 0
    },
    callFunction: E.bind(null, 9)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "dateTimeStamp",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 10,
      g: 0
    },
    callFunction: E.bind(null, 10)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "time",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 8,
      g: 0
    },
    callFunction: E.bind(null, 8)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "date",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 7,
      g: 0
    },
    callFunction: E.bind(null, 7)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "gYearMonth",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 11,
      g: 0
    },
    callFunction: E.bind(null, 11)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "gYear",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 12,
      g: 0
    },
    callFunction: E.bind(null, 12)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "gMonthDay",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 13,
      g: 0
    },
    callFunction: E.bind(null, 13)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "gDay",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 15,
      g: 0
    },
    callFunction: E.bind(null, 15)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "gMonth",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 14,
      g: 0
    },
    callFunction: E.bind(null, 14)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "hexBinary",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 22,
      g: 0
    },
    callFunction: E.bind(null, 22)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "base64Binary",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 21,
      g: 0
    },
    callFunction: E.bind(null, 21)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "QName",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 23,
      g: 0
    },
    callFunction: (a, b, c, d) => {
      if (d.F()) return d;
      a = d.first();
      if (v(a.type, 2)) throw Error("XPTY0004: The provided QName is not a string-like value.");
      a = jd(a, 1).value;
      a = sc(a, 23);
      if (!tc(a, 23)) throw Error("FORG0001: The provided QName is invalid.");
      if (!a.includes(":")) return c = c.$(""), w.m(g(new Sa("", c, a), 23));
      const [e, f] = a.split(":");
      c = c.$(e);
      if (!c) throw Error(`FONS0004: The value ${a} can not be cast to a QName. Did you mean to use fn:QName?`);
      return w.m(g(new Sa(e, c, f), 23));
    }
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "anyURI",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 20,
      g: 0
    },
    callFunction: E.bind(null, 20)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "normalizedString",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 48,
      g: 0
    },
    callFunction: E.bind(null, 48)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "token",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 52,
      g: 0
    },
    callFunction: E.bind(null, 52)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "language",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 51,
      g: 0
    },
    callFunction: E.bind(null, 51)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "NMTOKEN",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 50,
      g: 0
    },
    callFunction: E.bind(null, 50)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "NMTOKENS",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 49,
      g: 2
    },
    callFunction: E.bind(null, 49)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "Name",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 25,
      g: 0
    },
    callFunction: E.bind(null, 25)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "NCName",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 24,
      g: 0
    },
    callFunction: E.bind(null, 24)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "ID",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 42,
      g: 0
    },
    callFunction: E.bind(null, 42)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "IDREF",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 41,
      g: 0
    },
    callFunction: E.bind(null, 41)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "IDREFS",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 43,
      g: 2
    },
    callFunction: E.bind(null, 43)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "ENTITY",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 26,
      g: 0
    },
    callFunction: E.bind(null, 26)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "ENTITIES",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 40,
      g: 2
    },
    callFunction: E.bind(null, 40)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "integer",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: E.bind(null, 5)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "nonPositiveInteger",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 27,
      g: 0
    },
    callFunction: E.bind(null, 27)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "negativeInteger",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 28,
      g: 0
    },
    callFunction: E.bind(null, 28)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "long",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 31,
      g: 0
    },
    callFunction: E.bind(null, 31)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "int",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 32,
      g: 0
    },
    callFunction: E.bind(null, 32)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "short",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 33,
      g: 0
    },
    callFunction: E.bind(null, 33)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "byte",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 34,
      g: 0
    },
    callFunction: E.bind(null, 34)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "nonNegativeInteger",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 30,
      g: 0
    },
    callFunction: E.bind(null, 30)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "unsignedLong",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 36,
      g: 0
    },
    callFunction: E.bind(null, 36)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "unsignedInt",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 35,
      g: 0
    },
    callFunction: E.bind(null, 35)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "unsignedShort",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 38,
      g: 0
    },
    callFunction: E.bind(null, 38)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "unsignedByte",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 37,
      g: 0
    },
    callFunction: E.bind(null, 37)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "positiveInteger",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 29,
      g: 0
    },
    callFunction: E.bind(null, 29)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "yearMonthDuration",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 16,
      g: 0
    },
    callFunction: E.bind(null, 16)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "dayTimeDuration",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 17,
      g: 0
    },
    callFunction: E.bind(null, 17)
  }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "dateTimeStamp",
    j: [{
      type: 46,
      g: 0
    }],
    i: {
      type: 10,
      g: 0
    },
    callFunction: E.bind(null, 10)
  }];
  const Pf = (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getYear(), 5)),
    Qf = (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getMonth(), 5)),
    Rf = (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getDay(), 5)),
    Sf = (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getHours(), 5)),
    Tf = (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getMinutes(), 5)),
    Uf = (a, b, c, d) => {
      d.F() || (a = w, b = a.m, d = d.first().value, d = b.call(a, g(d.D + d.qa, 4)));
      return d;
    },
    Vf = (a, b, c, d) => d.F() ? d : (a = d.first().value.Y) ? w.m(g(a, 17)) : w.empty();
  var Wf = [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "dateTime",
    j: [{
      type: 7,
      g: 0
    }, {
      type: 8,
      g: 0
    }],
    i: {
      type: 9,
      g: 0
    },
    callFunction: (a, b, c, d, e) => {
      if (d.F()) return d;
      if (e.F()) return e;
      a = d.first().value;
      e = e.first().value;
      b = a.Y;
      c = e.Y;
      if (b || c) {
        if (!b || c) if (!b && c) b = c;else if (!vb(b, c)) throw Error("FORG0008: fn:dateTime: got a date and time value with different timezones.");
      } else b = null;
      return w.m(g(new Kb(a.getYear(), a.getMonth(), a.getDay(), e.getHours(), e.getMinutes(), e.getSeconds(), e.qa, b), 9));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "year-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Pf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "month-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Qf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "day-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Rf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "hours-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Sf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "minutes-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Tf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "seconds-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 4,
      g: 0
    },
    callFunction: Uf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "timezone-from-dateTime",
    j: [{
      type: 9,
      g: 0
    }],
    i: {
      type: 17,
      g: 0
    },
    callFunction: Vf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "year-from-date",
    j: [{
      type: 7,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Pf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "month-from-date",
    j: [{
      type: 7,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Qf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "day-from-date",
    j: [{
      type: 7,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Rf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "timezone-from-date",
    j: [{
      type: 7,
      g: 0
    }],
    i: {
      type: 17,
      g: 0
    },
    callFunction: Vf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "hours-from-time",
    j: [{
      type: 8,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Sf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "minutes-from-time",
    j: [{
      type: 8,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: Tf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "seconds-from-time",
    j: [{
      type: 8,
      g: 0
    }],
    i: {
      type: 4,
      g: 0
    },
    callFunction: Uf
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "timezone-from-time",
    j: [{
      type: 8,
      g: 0
    }],
    i: {
      type: 17,
      g: 0
    },
    callFunction: Vf
  }];
  function Xf(a, b) {
    const c = b.h,
      d = b.Ja,
      e = b.Ma;
    switch (a.node.nodeType) {
      case 1:
        const h = d.createElementNS(a.node.namespaceURI, a.node.nodeName);
        c.getAllAttributes(a.node).forEach(k => e.setAttributeNS(h, k.namespaceURI, k.nodeName, k.value));
        for (var f of hb(c, a)) a = Xf(f, b), e.insertBefore(h, a.node, null);
        return {
          node: h,
          G: null
        };
      case 2:
        return b = d.createAttributeNS(a.node.namespaceURI, a.node.nodeName), b.value = ib(c, a), {
          node: b,
          G: null
        };
      case 4:
        return {
          node: d.createCDATASection(ib(c, a)),
          G: null
        };
      case 8:
        return {
          node: d.createComment(ib(c, a)),
          G: null
        };
      case 9:
        f = d.createDocument();
        for (const k of hb(c, a)) a = Xf(k, b), e.insertBefore(f, a.node, null);
        return {
          node: f,
          G: null
        };
      case 7:
        return {
          node: d.createProcessingInstruction(a.node.target, ib(c, a)),
          G: null
        };
      case 3:
        return {
          node: d.createTextNode(ib(c, a)),
          G: null
        };
    }
  }
  function Yf(a, b) {
    const c = b.Ma;
    var d = b.Ja;
    const e = b.h;
    if (cb(a.node)) switch (a.node.nodeType) {
      case 2:
        return d = d.createAttributeNS(a.node.namespaceURI, a.node.nodeName), d.value = ib(e, a), d;
      case 8:
        return d.createComment(ib(e, a));
      case 1:
        const f = a.node.prefix,
          h = a.node.localName,
          k = d.createElementNS(a.node.namespaceURI, f ? f + ":" + h : h);
        hb(e, a).forEach(l => {
          l = Yf(l, b);
          c.insertBefore(k, l, null);
        });
        eb(e, a).forEach(l => {
          c.setAttributeNS(k, l.node.namespaceURI, l.node.nodeName, ib(e, l));
        });
        k.normalize();
        return k;
      case 7:
        return d.createProcessingInstruction(a.node.target, ib(e, a));
      case 3:
        return d.createTextNode(ib(e, a));
    } else return Xf(a, b).node;
  }
  function Zf(a, b, c) {
    let d = a;
    for (a = x(c, d); null !== a;) {
      if (2 === d.node.nodeType) b.push(d.node.nodeName);else {
        const e = hb(c, a);
        b.push(e.findIndex(f => md(f, d)));
      }
      d = a;
      a = x(c, d);
    }
    return d;
  }
  function $f(a, b, c) {
    for (; 0 < b.length;) {
      const d = b.pop();
      "string" === typeof d ? a = eb(c, a).find(e => e.node.nodeName === d) : a = hb(c, a)[d];
    }
    return a.node;
  }
  function ag(a, b, c) {
    var d = a.node;
    if (!(cb(d) || c || a.G)) return d;
    d = b.v;
    const e = [];
    if (c) return Yf(a, b);
    a = Zf(a, e, b.h);
    c = d.get(a.node);
    c || (c = {
      node: Yf(a, b),
      G: null
    }, d.set(a.node, c));
    return $f(c, e, b.h);
  }
  const bg = (a, b, c, d, e) => d.N(f => {
    var h;
    let k = "";
    for (let l = 0; l < f.length; l++) {
      const n = f[l],
        t = b.Ua && v(n.type, 53) ? b.Ua.serializeToString(ag(n.value, b, !1)) : null === (h = qc(w.m(n), b).map(u => jd(u, 1)).first()) || void 0 === h ? void 0 : h.value;
      t && (k += `{type: ${Da[n.type]}, value: ${t}}\n`);
    }
    void 0 !== e && (k += e.first().value);
    b.jb.trace(k);
    return w.create(f);
  });
  var cg = [{
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: bg,
    localName: "trace",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 1,
      g: 3
    }],
    callFunction: bg,
    localName: "trace",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }];
  const dg = (a, b, c, d, e) => {
    a = void 0 === d || d.F() ? new Sa("err", "http://www.w3.org/2005/xqt-errors", "FOER0000") : d.first().value;
    b = "";
    void 0 === e || e.F() || (b = `: ${e.first().value}`);
    throw Error(`${a.localName}${b}`);
  };
  var eg = [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "error",
    j: [],
    i: {
      type: 63,
      g: 3
    },
    callFunction: dg
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "error",
    j: [{
      type: 23,
      g: 0
    }],
    i: {
      type: 63,
      g: 3
    },
    callFunction: dg
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "error",
    j: [{
      type: 23,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 63,
      g: 3
    },
    callFunction: dg
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "error",
    j: [{
      type: 23,
      g: 0
    }, {
      type: 1,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 63,
      g: 3
    },
    callFunction() {
      throw Error("Not implemented: Using an error object in error is not supported");
    }
  }];
  function fg(a) {
    return "string" === typeof a ? a : (a = new Za().getChildNodes(a).find(b => 8 === b.nodeType)) ? a.data : "some expression";
  }
  var gg = class extends Error {
    constructor(a, b) {
      super(a);
      this.position = {
        end: {
          ha: b.end.ha,
          line: b.end.line,
          offset: b.end.offset
        },
        start: {
          ha: b.start.ha,
          line: b.start.line,
          offset: b.start.offset
        }
      };
    }
  };
  function hg(a, b) {
    if (b instanceof Error) throw b;
    "string" !== typeof a && (a = fg(a));
    const c = ig(b);
    a = a.replace(/\r/g, "").split("\n");
    const d = Math.floor(Math.log10(Math.min(c.end.line + 2, a.length))) + 1;
    a = a.reduce((e, f, h) => {
      var k = h + 1;
      if (2 < c.start.line - k || 2 < k - c.end.line) return e;
      h = `${Array(d).fill(" ", 0, Math.floor(Math.log10(k)) + 1 - d).join("")}${k}: `;
      e.push(`${h}${f}`);
      if (k >= c.start.line && k <= c.end.line) {
        const l = k < c.end.line ? f.length + h.length : c.end.ha - 1 + h.length;
        k = k > c.start.line ? h.length : c.start.ha - 1 + h.length;
        f = " ".repeat(h.length) + Array.from(f.substring(0, k - h.length), n => "\t" === n ? "\t" : " ").join("") + "^".repeat(l - k);
        e.push(f);
      }
      return e;
    }, []);
    b = jg(b).join("\n");
    throw new gg(a.join("\n") + "\n\n" + b, c);
  }
  const kg = Object.create(null);
  function lg(a, b) {
    const c = new Map();
    for (let d = 0; d < a.length + 1; ++d) c.set(d, new Map());
    return function h(e, f) {
      if (0 === e) return f;
      if (0 === f) return e;
      if (c.get(e).has(f)) return c.get(e).get(f);
      var k = 0;
      a[e - 1] !== b[f - 1] && (k = 1);
      k = Math.min(h(e - 1, f) + 1, h(e, f - 1) + 1, h(e - 1, f - 1) + k);
      c.get(e).set(f, k);
      return k;
    }(a.length, b.length);
  }
  function mg(a) {
    const b = kg[a] ? kg[a] : Object.keys(kg).map(c => ({
      name: c,
      sb: lg(a, c.slice(c.lastIndexOf(":") + 1))
    })).sort((c, d) => c.sb - d.sb).slice(0, 5).filter(c => c.sb < a.length / 2).reduce((c, d) => c.concat(kg[d.name]), []).slice(0, 5);
    return b.length ? b.map(c => `"Q{${c.namespaceURI}}${c.localName} (${c.j.map(d => 4 === d ? "..." : Ha(d)).join(", ")})"`).reduce((c, d, e, f) => 0 === e ? c + d : c + ((e !== f.length - 1 ? ", " : " or ") + d), "Did you mean ") + "?" : "No similar functions found.";
  }
  function ng(a, b, c) {
    var d = kg[a + ":" + b];
    return d ? (d = d.find(e => e.j.some(f => 4 === f) ? e.j.length - 1 <= c : e.j.length === c)) ? {
      j: d.j,
      arity: c,
      callFunction: d.callFunction,
      I: d.I,
      localName: b,
      namespaceURI: a,
      i: d.i
    } : null : null;
  }
  function og(a, b, c, d, e) {
    kg[a + ":" + b] || (kg[a + ":" + b] = []);
    kg[a + ":" + b].push({
      j: c,
      arity: c.length,
      callFunction: e,
      I: !1,
      localName: b,
      namespaceURI: a,
      i: d
    });
  }
  var pg = {
    xml: "http://www.w3.org/XML/1998/namespace",
    xs: "http://www.w3.org/2001/XMLSchema",
    fn: "http://www.w3.org/2005/xpath-functions",
    map: "http://www.w3.org/2005/xpath-functions/map",
    array: "http://www.w3.org/2005/xpath-functions/array",
    math: "http://www.w3.org/2005/xpath-functions/math",
    fontoxpath: "http://fontoxml.com/fontoxpath",
    local: "http://www.w3.org/2005/xquery-local-functions"
  };
  var qg = class {
    constructor(a, b, c, d) {
      this.Da = [Object.create(null)];
      this.Ea = Object.create(null);
      this.s = a;
      this.ia = Object.keys(b).reduce((e, f) => {
        if (void 0 === b[f]) return e;
        e[f] = `Q{}${f}[0]`;
        return e;
      }, Object.create(null));
      this.o = Object.create(null);
      this.h = Object.create(null);
      this.v = c;
      this.l = d;
      this.D = [];
    }
    va(a, b, c) {
      return ng(a, b, c);
    }
    eb(a, b) {
      if (a) return null;
      a = this.ia[b];
      this.o[b] || (this.o[b] = {
        name: b
      });
      return a;
    }
    Sa(a, b) {
      const c = this.l(a, b);
      if (c) this.D.push({
        cc: a,
        arity: b,
        Db: c
      });else if ("" === a.prefix) {
        if (this.v) return {
          namespaceURI: this.v,
          localName: a.localName
        };
      } else if (b = this.$(a.prefix, !0)) return {
        namespaceURI: b,
        localName: a.localName
      };
      return c;
    }
    $(a, b = !0) {
      if (!b) return null;
      if (pg[a]) return pg[a];
      b = this.s(a);
      this.h[a] || (this.h[a] = {
        namespaceURI: b,
        prefix: a
      });
      return void 0 !== b || a ? b : null;
    }
  };
  var rg = (a, b) => {
      a = 2 === a.node.nodeType ? `${a.node.nodeName}="${ib(b, a)}"` : a.node.outerHTML;
      return Error(`XQTY0024: The node ${a} follows a node that is not an attribute node or a namespace node.`);
    },
    sg = a => Error(`XQDY0044: The node name "${a.za()}" is invalid for a computed attribute constructor.`),
    tg = () => Error("XQST0045: Functions and variables may not be declared in one of the reserved namespace URIs."),
    ug = (a, b) => Error(`XQST0049: The function or variable "Q{${a}}${b}" is declared more than once.`),
    vg = () => Error("XQST0060: Functions declared in a module or as an external function must reside in a namespace."),
    wg = () => Error("XQST0066: A Prolog may contain at most one default function namespace declaration."),
    xg = () => Error("XQST0070: The prefixes xml and xmlns may not be used in a namespace declaration or be bound to another namespaceURI."),
    yg = a => Error(`XQDY0074: The value "${a}" of a name expressions cannot be converted to an expanded QName.`),
    zg = a => Error(`XPST0081: The prefix "${a}" could not be resolved`);
  function Ag(a, b) {
    return `Q{${a || ""}}${b}`;
  }
  function Bg(a, b) {
    for (let c = a.length - 1; 0 <= c; --c) if (b in a[c]) return a[c][b];
  }
  function Ff(a) {
    const b = new Cg(a.o);
    for (let c = 0; c < a.h + 1; ++c) b.D = [Object.assign(Object.create(null), b.D[0], a.D[c])], b.Da = [Object.assign(Object.create(null), b.Da[0], a.Da[c])], b.l = Object.assign(Object.create(null), a.l), b.Ea = a.Ea, b.v = a.v;
    return b;
  }
  function Dg(a) {
    a.s++;
    a.h++;
    a.D[a.h] = Object.create(null);
    a.Da[a.h] = Object.create(null);
  }
  function Eg(a, b, c) {
    return (a = a.Ea[Ag(b, c)]) ? a : null;
  }
  function Fg(a, b, c, d, e) {
    d = Ag(b, c) + "~" + d;
    if (a.l[d]) throw ug(b, c);
    a.l[d] = e;
  }
  function Gg(a, b, c) {
    a.D[a.h][b] = c;
  }
  function Hg(a, b, c) {
    b = Ag(b || "", c);
    return a.Da[a.h][b] = `${b}[${a.s}]`;
  }
  function Ig(a, b, c, d) {
    a.Ea[`${Ag(b || "", c)}[${a.s}]`] = d;
  }
  function Jg(a) {
    a.D.length = a.h;
    a.Da.length = a.h;
    a.h--;
  }
  var Cg = class {
    constructor(a) {
      this.o = a;
      this.s = this.h = 0;
      this.D = [Object.create(null)];
      this.l = Object.create(null);
      this.v = null;
      this.Ea = a && a.Ea;
      this.Da = a && a.Da;
    }
    va(a, b, c, d = !1) {
      const e = this.l[Ag(a, b) + "~" + c];
      return !e || d && e.wb ? null === this.o ? null : this.o.va(a, b, c, d) : e;
    }
    eb(a, b) {
      const c = Bg(this.Da, Ag(a, b));
      return c ? c : null === this.o ? null : this.o.eb(a, b);
    }
    Sa(a, b) {
      var c = a.prefix;
      const d = a.localName;
      return "" === c && this.v ? {
        localName: d,
        namespaceURI: this.v
      } : c && (c = this.$(c, !1)) ? {
        localName: d,
        namespaceURI: c
      } : null === this.o ? null : this.o.Sa(a, b);
    }
    $(a, b = !0) {
      const c = Bg(this.D, a || "");
      return void 0 === c ? null === this.o ? void 0 : this.o.$(a || "", b) : c;
    }
  };
  function F(a, b) {
    "*" === b || Array.isArray(b) || (b = [b]);
    for (let c = 1; c < a.length; ++c) {
      if (!Array.isArray(a[c])) continue;
      const d = a[c];
      if ("*" === b || b.includes(d[0])) return d;
    }
    return null;
  }
  function H(a) {
    return 2 > a.length ? "" : "object" === typeof a[1] ? a[2] || "" : a[1] || "";
  }
  function I(a, b) {
    if (!Array.isArray(a)) return null;
    a = a[1];
    return "object" !== typeof a || Array.isArray(a) ? null : b in a ? a[b] : null;
  }
  function J(a, b) {
    return b.reduce(F, a);
  }
  function K(a, b) {
    const c = [];
    for (let d = 1; d < a.length; ++d) {
      if (!Array.isArray(a[d])) continue;
      const e = a[d];
      "*" !== b && e[0] !== b || c.push(e);
    }
    return c;
  }
  function Kg(a) {
    return {
      localName: H(a),
      namespaceURI: I(a, "URI"),
      prefix: I(a, "prefix")
    };
  }
  function Lg(a) {
    const b = F(a, "typeDeclaration");
    if (!b || F(b, "voidSequenceType")) return {
      type: 59,
      g: 2
    };
    const c = f => {
      switch (f[0]) {
        case "documentTest":
          return 55;
        case "elementTest":
          return 54;
        case "attributeTest":
          return 47;
        case "piTest":
          return 57;
        case "commentTest":
          return 58;
        case "textTest":
          return 56;
        case "anyKindTest":
          return 53;
        case "anyItemType":
          return 59;
        case "anyFunctionTest":
        case "functionTest":
        case "typedFunctionTest":
          return 60;
        case "anyMapTest":
        case "typedMapTest":
          return 61;
        case "anyArrayTest":
        case "typedArrayTest":
          return 62;
        case "atomicType":
          return Ia([I(f, "prefix"), H(f)].join(":"));
        case "parenthesizedItemType":
          return c(F(f, "*"));
        default:
          throw Error(`Type declaration "${F(b, "*")[0]}" is not supported.`);
      }
    };
    a = {
      type: c(F(b, "*")),
      g: 3
    };
    let d = null;
    const e = F(b, "occurrenceIndicator");
    e && (d = H(e));
    switch (d) {
      case "*":
        return a.g = 2, a;
      case "?":
        return a.g = 0, a;
      case "+":
        return a.g = 1, a;
      case "":
      case null:
        return a;
    }
  }
  function L(a, b, c) {
    if ("object" !== typeof a[1] || Array.isArray(a[1])) {
      const d = {};
      d[b] = c;
      a.splice(1, 0, d);
    } else a[1][b] = c;
  }
  function Mg(a) {
    const b = {
      type: 62,
      g: 3
    };
    L(a, "type", b);
    return b;
  }
  function Ng(a, b) {
    if (!b || !b.ga) return {
      type: 59,
      g: 2
    };
    var c = F(a, "EQName");
    if (!c) return {
      type: 59,
      g: 2
    };
    var d = Kg(c);
    c = d.localName;
    const e = d.prefix;
    d = K(F(a, "arguments"), "*");
    c = b.ga.Sa({
      localName: c,
      prefix: e
    }, d.length);
    if (!c) return {
      type: 59,
      g: 2
    };
    b = b.ga.va(c.namespaceURI, c.localName, d.length + 1);
    if (!b) return {
      type: 59,
      g: 2
    };
    59 !== b.i.type && L(a, "type", b.i);
    return b.i;
  }
  function M(a, b, c) {
    return (a << 20) + (b << 12) + (c.charCodeAt(0) << 8) + c.charCodeAt(1);
  }
  var Og = {
      [M(2, 2, "idivOp")]: 5,
      [M(16, 16, "addOp")]: 16,
      [M(16, 16, "subtractOp")]: 16,
      [M(16, 16, "divOp")]: 4,
      [M(16, 2, "multiplyOp")]: 16,
      [M(16, 2, "divOp")]: 16,
      [M(2, 16, "multiplyOp")]: 16,
      [M(17, 17, "addOp")]: 17,
      [M(17, 17, "subtractOp")]: 17,
      [M(17, 17, "divOp")]: 4,
      [M(17, 2, "multiplyOp")]: 17,
      [M(17, 2, "divOp")]: 17,
      [M(2, 17, "multiplyOp")]: 17,
      [M(9, 9, "subtractOp")]: 17,
      [M(7, 7, "subtractOp")]: 17,
      [M(8, 8, "subtractOp")]: 17,
      [M(9, 16, "addOp")]: 9,
      [M(9, 16, "subtractOp")]: 9,
      [M(9, 17, "addOp")]: 9,
      [M(9, 17, "subtractOp")]: 9,
      [M(7, 16, "addOp")]: 7,
      [M(7, 16, "subtractOp")]: 7,
      [M(7, 17, "addOp")]: 7,
      [M(7, 17, "subtractOp")]: 7,
      [M(8, 17, "addOp")]: 8,
      [M(8, 17, "subtractOp")]: 8,
      [M(9, 16, "addOp")]: 9,
      [M(9, 16, "subtractOp")]: 9,
      [M(9, 17, "addOp")]: 9,
      [M(9, 17, "subtractOp")]: 9,
      [M(7, 17, "addOp")]: 7,
      [M(7, 17, "subtractOp")]: 7,
      [M(7, 16, "addOp")]: 7,
      [M(7, 16, "subtractOp")]: 7,
      [M(8, 17, "addOp")]: 8,
      [M(8, 17, "subtractOp")]: 8
    },
    Pg = {
      [M(2, 2, "addOp")]: (a, b) => a + b,
      [M(2, 2, "subtractOp")]: (a, b) => a - b,
      [M(2, 2, "multiplyOp")]: (a, b) => a * b,
      [M(2, 2, "divOp")]: (a, b) => a / b,
      [M(2, 2, "modOp")]: (a, b) => a % b,
      [M(2, 2, "idivOp")]: (a, b) => Math.trunc(a / b),
      [M(16, 16, "addOp")]: function (a, b) {
        return new Kc(a.ea + b.ea);
      },
      [M(16, 16, "subtractOp")]: function (a, b) {
        return new Kc(a.ea - b.ea);
      },
      [M(16, 16, "divOp")]: function (a, b) {
        return a.ea / b.ea;
      },
      [M(16, 2, "multiplyOp")]: Mc,
      [M(16, 2, "divOp")]: function (a, b) {
        if (isNaN(b)) throw Error("FOCA0005: Cannot divide xs:yearMonthDuration by NaN");
        a = Math.round(a.ea / b);
        if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while dividing xs:yearMonthDuration");
        return new Kc(a < Number.MIN_SAFE_INTEGER || 0 === a ? 0 : a);
      },
      [M(2, 16, "multiplyOp")]: (a, b) => Mc(b, a),
      [M(17, 17, "addOp")]: function (a, b) {
        return new yb(a.ca + b.ca);
      },
      [M(17, 17, "subtractOp")]: function (a, b) {
        return new yb(a.ca - b.ca);
      },
      [M(17, 17, "divOp")]: function (a, b) {
        if (0 === b.ca) throw Error("FOAR0001: Division by 0");
        return a.ca / b.ca;
      },
      [M(17, 2, "multiplyOp")]: Cb,
      [M(17, 2, "divOp")]: function (a, b) {
        if (isNaN(b)) throw Error("FOCA0005: Cannot divide xs:dayTimeDuration by NaN");
        a = a.ca / b;
        if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while dividing xs:dayTimeDuration");
        return new yb(a < Number.MIN_SAFE_INTEGER || Object.is(-0, a) ? 0 : a);
      },
      [M(2, 17, "multiplyOp")]: (a, b) => Cb(b, a),
      [M(9, 9, "subtractOp")]: Pb,
      [M(7, 7, "subtractOp")]: Pb,
      [M(8, 8, "subtractOp")]: Pb,
      [M(9, 16, "addOp")]: Qb,
      [M(9, 16, "subtractOp")]: Rb,
      [M(9, 17, "addOp")]: Qb,
      [M(9, 17, "subtractOp")]: Rb,
      [M(7, 16, "addOp")]: Qb,
      [M(7, 16, "subtractOp")]: Rb,
      [M(7, 17, "addOp")]: Qb,
      [M(7, 17, "subtractOp")]: Rb,
      [M(8, 17, "addOp")]: Qb,
      [M(8, 17, "subtractOp")]: Rb,
      [M(9, 16, "addOp")]: Qb,
      [M(9, 16, "subtractOp")]: Rb,
      [M(9, 17, "addOp")]: Qb,
      [M(9, 17, "subtractOp")]: Rb,
      [M(7, 17, "addOp")]: Qb,
      [M(7, 17, "subtractOp")]: Rb,
      [M(7, 16, "addOp")]: Qb,
      [M(7, 16, "subtractOp")]: Rb,
      [M(8, 17, "addOp")]: Qb,
      [M(8, 17, "subtractOp")]: Rb
    };
  function Qg(a, b) {
    return v(a, 5) && v(b, 5) ? 5 : v(a, 4) && v(b, 4) ? 4 : v(a, 6) && v(b, 6) ? 6 : 3;
  }
  const Rg = [2, 16, 17, 9, 7, 8];
  function Sg(a, b, c) {
    function d(l, n) {
      return {
        U: e ? e(l) : l,
        V: f ? f(n) : n
      };
    }
    let e = null,
      f = null;
    v(b, 19) && (e = l => jd(l, 3), b = 3);
    v(c, 19) && (f = l => jd(l, 3), c = 3);
    const h = Rg.filter(l => v(b, l)),
      k = Rg.filter(l => v(c, l));
    if (h.includes(2) && k.includes(2)) {
      const l = Pg[M(2, 2, a)];
      let n = Og[M(2, 2, a)];
      n ||= Qg(b, c);
      "divOp" === a && 5 === n && (n = 4);
      return "idivOp" === a ? Tg(d, l)[0] : (t, u) => {
        const {
          U: z,
          V: y
        } = d(t, u);
        return g(l(z.value, y.value), n);
      };
    }
    for (const l of h) for (const n of k) {
      const t = Pg[M(l, n, a)],
        u = Og[M(l, n, a)];
      if (t && void 0 !== u) return (z, y) => {
        const {
          U: G,
          V: N
        } = d(z, y);
        return g(t(G.value, N.value), u);
      };
    }
  }
  function Ug(a, b, c) {
    function d(n, t) {
      return {
        U: f ? f(n) : n,
        V: h ? h(t) : t
      };
    }
    var e = [2, 53, 59, 46, 47];
    if (e.includes(b) || e.includes(c)) return 2;
    let f = null,
      h = null;
    v(b, 19) && (f = n => jd(n, 3), b = 3);
    v(c, 19) && (h = n => jd(n, 3), c = 3);
    var k = Rg.filter(n => v(b, n));
    e = Rg.filter(n => v(c, n));
    if (k.includes(2) && e.includes(2)) {
      var l = Og[M(2, 2, a)];
      void 0 === l && (l = Qg(b, c));
      "divOp" === a && 5 === l && (l = 4);
      return "idivOp" === a ? Tg(d, (n, t) => Math.trunc(n / t))[1] : l;
    }
    for (l of k) for (const n of e) if (k = Og[M(l, n, a)], void 0 !== k) return k;
  }
  function Tg(a, b) {
    return [(c, d) => {
      const {
        U: e,
        V: f
      } = a(c, d);
      if (0 === f.value) throw Error("FOAR0001: Divisor of idiv operator cannot be (-)0");
      if (Number.isNaN(e.value) || Number.isNaN(f.value) || !Number.isFinite(e.value)) throw Error("FOAR0002: One of the operands of idiv is NaN or the first operand is (-)INF");
      return Number.isFinite(e.value) && !Number.isFinite(f.value) ? g(0, 5) : g(b(e.value, f.value), 5);
    }, 5];
  }
  const Vg = Object.create(null);
  var Wg = class extends D {
    constructor(a, b, c, d, e) {
      super(b.o.add(c.o), [b, c], {
        B: !1
      }, !1, d);
      this.A = b;
      this.L = c;
      this.l = a;
      this.s = e;
    }
    h(a, b) {
      return qc(C(this.A, a, b), b).N(c => 0 === c.length ? w.empty() : qc(C(this.L, a, b), b).N(d => {
        if (0 === d.length) return w.empty();
        if (1 < c.length || 1 < d.length) throw Error('XPTY0004: the operands of the "' + this.l + '" operator should be empty or singleton.');
        const e = c[0];
        d = d[0];
        if (this.s && this.type) return w.m(this.s(e, d));
        var f = e.type;
        var h = d.type,
          k = this.l;
        const l = `${f}~${h}~${k}`;
        let n = Vg[l];
        n ||= Vg[l] = Sg(k, f, h);
        f = n;
        if (!f) throw Error(`XPTY0004: ${this.l} not available for types ${Da[e.type]} and ${Da[d.type]}`);
        return w.m(f(e, d));
      }));
    }
  };
  function Xg(a, b) {
    var c = O;
    let d = !1;
    for (var e = 1; e < a.length; e++) switch (a[e][0]) {
      case "letClause":
        Yg(b);
        var f = a[e],
          h = b,
          k = c,
          l = J(f, ["letClauseItem", "typedVariableBinding", "varName"]);
        l = Kg(l);
        f = J(f, ["letClauseItem", "letExpr"]);
        k = k(f[1], h);
        Zg(h, l.localName, k);
        break;
      case "forClause":
        d = !0;
        Yg(b);
        $g(a[e], b, c);
        break;
      case "whereClause":
        Yg(b);
        h = a[e];
        c(h, b);
        L(h, "type", {
          type: 0,
          g: 3
        });
        break;
      case "orderByClause":
        Yg(b);
        break;
      case "returnClause":
        e = a[e];
        h = c;
        c = J(e, ["*"]);
        b = h(c, b);
        L(c, "type", b);
        L(e, "type", b);
        c = b;
        if (!c) return {
          type: 59,
          g: 2
        };
        d && (c = {
          type: c.type,
          g: 2
        });
        59 !== c.type && L(a, "type", c);
        return c;
      default:
        c = c(a[e], b);
        if (!c) return {
          type: 59,
          g: 2
        };
        d && (c = {
          type: c.type,
          g: 2
        });
        59 !== c.type && L(a, "type", c);
        return c;
    }
    if (0 < b.h) b.h--, b.o.pop(), b.v.pop();else throw Error("Variable scope out of bound");
  }
  function $g(a, b, c) {
    const d = Kg(J(a, ["forClauseItem", "typedVariableBinding", "varName"]));
    if (a = J(a, ["forClauseItem", "forExpr", "sequenceExpr"])) a = K(a, "*").map(e => c(e, b)), a.includes(void 0) || a.includes(null) || (a = ah(a), 1 === a.length && Zg(b, d.localName, a[0]));
  }
  function ah(a) {
    return a.filter((b, c, d) => d.findIndex(e => e.type === b.type && e.g === b.g) === c);
  }
  function bh(a, b) {
    if (!b || !b.ga) return {
      type: 59,
      g: 2
    };
    const c = F(a, "functionName");
    var d = Kg(c);
    let e = d.localName;
    var f = d.prefix;
    let h = d.namespaceURI;
    d = K(F(a, "arguments"), "*");
    if (null === h) {
      f = b.ga.Sa({
        localName: e,
        prefix: f
      }, d.length);
      if (!f) return {
        type: 59,
        g: 2
      };
      e = f.localName;
      h = f.namespaceURI;
      L(c, "URI", h);
      c[2] = e;
    }
    b = b.ga.va(h, e, d.length);
    if (!b || 63 === b.i.type) return {
      type: 59,
      g: 2
    };
    59 !== b.i.type && L(a, "type", b.i);
    return b.i;
  }
  function ch(a) {
    const b = {
      type: 61,
      g: 3
    };
    L(a, "type", b);
    return b;
  }
  function dh(a, b) {
    if (!b || !b.ga) return {
      type: 59,
      g: 2
    };
    const c = F(a, "functionName");
    var d = Kg(c);
    let e = d.localName;
    var f = d.namespaceURI;
    const h = d.prefix;
    d = Number(J(a, ["integerConstantExpr", "value"])[1]);
    if (!f) {
      f = b.ga.Sa({
        localName: e,
        prefix: h
      }, d);
      if (!f) return {
        type: 59,
        g: 2
      };
      e = f.localName;
      f = f.namespaceURI;
      L(c, "URI", f);
    }
    b = b.ga.va(f, e, d) || null;
    if (!b) return {
      type: 59,
      g: 2
    };
    59 !== b.i.type && 63 !== b.i.type && L(a, "type", b.i);
    return b.i;
  }
  function eh(a, b) {
    var c = K(a, "stepExpr");
    if (!c) return {
      type: 59,
      g: 2
    };
    for (const f of c) {
      a: {
        c = f;
        var d = b;
        let h = null;
        if (!c) break a;
        var e = K(c, "*");
        let k = "";
        for (const l of e) switch (l[0]) {
          case "filterExpr":
            h = I(J(l, ["*"]), "type");
            break;
          case "xpathAxis":
            k = l[1];
            b: {
              switch (k) {
                case "attribute":
                  h = {
                    type: 47,
                    g: 2
                  };
                  break b;
                case "child":
                case "decendant":
                case "self":
                case "descendant-or-self":
                case "following-sibling":
                case "following":
                case "namespace":
                case "parent":
                case "ancestor":
                case "preceding-sibling":
                case "preceding":
                case "ancestor-or-self":
                  h = {
                    type: 53,
                    g: 2
                  };
                  break b;
              }
              h = void 0;
            }
            break;
          case "nameTest":
            e = Kg(l);
            if (null !== e.namespaceURI) break;
            if ("attribute" === k && !e.prefix) break;
            e = d.$(e.prefix || "");
            void 0 !== e && L(l, "URI", e);
            break;
          case "lookup":
            h = {
              type: 59,
              g: 2
            };
        }
        h && 59 !== h.type && L(c, "type", h);
      }
      d = I(f, "type");
    }
    d && 59 !== d.type && L(a, "type", d);
    return d;
  }
  function fh(a) {
    const b = {
      type: 0,
      g: 3
    };
    L(a, "type", b);
    return b;
  }
  function gh(a, b, c) {
    0 === b ? b = {
      type: 53,
      g: 2
    } : 1 === b ? b = c[0] : c.includes(void 0) || c.includes(null) ? b = {
      type: 59,
      g: 2
    } : (b = ah(c), b = 1 < b.length ? {
      type: 59,
      g: 2
    } : {
      type: b[0].type,
      g: 2
    });
    b && 59 !== b.type && L(a, "type", b);
    return b;
  }
  function hh(a, b, c, d) {
    if (!b || c.includes(void 0)) return {
      type: 59,
      g: 2
    };
    var e = K(a, "typeswitchExprCaseClause");
    for (let h = 0; h < c.length; h++) {
      var f = F(e[h], "*");
      switch (f[0]) {
        case "sequenceType":
          if (f = ih(f, b, c[h])) return 59 !== f.type && L(a, "type", f), f;
          continue;
        case "sequenceTypeUnion":
          for (d = K(f, "*"), e = 0; 2 > e; e++) if (f = ih(d[e], b, c[h])) return 59 !== f.type && L(a, "type", f), f;
        default:
          return {
            type: 59,
            g: 2
          };
      }
    }
    59 !== d.type && L(a, "type", d);
    return d;
  }
  function ih(a, b, c) {
    const d = K(a, "*"),
      e = F(a, "atomicType");
    if (!e) return {
      type: 59,
      g: 2
    };
    if (Ia(I(e, "prefix") + ":" + e[2]) === b.type) if (1 === d.length) {
      if (3 === b.g) return c;
    } else if (a = F(a, "occurrenceIndicator")[1], b.g === Ka(a)) return c;
  }
  function jh(a, b) {
    O(a, b);
  }
  function O(a, b) {
    var c = kh.get(a[0]);
    if (c) return c(a, b);
    for (c = 1; c < a.length; c++) a[c] && O(a[c], b);
  }
  const lh = (a, b) => {
      var c = O(F(a, "firstOperand")[1], b);
      const d = O(F(a, "secondOperand")[1], b);
      var e = a[0];
      if (c && d) {
        if (b = Ug(e, c.type, d.type)) c = {
          type: b,
          g: c.g
        }, 2 !== b && 59 !== b && L(a, "type", c), a = c;else throw Error(`XPTY0004: ${e} not available for types ${Ha(c)} and ${Ha(d)}`);
      } else a = {
        type: 2,
        g: 3
      };
      return a;
    },
    mh = (a, b) => {
      O(F(a, "firstOperand")[1], b);
      O(F(a, "secondOperand")[1], b);
      a: {
        switch (a[0]) {
          case "orOp":
            b = {
              type: 0,
              g: 3
            };
            L(a, "type", b);
            a = b;
            break a;
          case "andOp":
            b = {
              type: 0,
              g: 3
            };
            L(a, "type", b);
            a = b;
            break a;
        }
        a = void 0;
      }
      return a;
    },
    nh = (a, b) => {
      O(F(a, "firstOperand")[1], b);
      O(F(a, "secondOperand")[1], b);
      a: {
        switch (a[0]) {
          case "unionOp":
            b = {
              type: 53,
              g: 2
            };
            L(a, "type", b);
            a = b;
            break a;
          case "intersectOp":
            b = {
              type: 53,
              g: 2
            };
            L(a, "type", b);
            a = b;
            break a;
          case "exceptOp":
            b = {
              type: 53,
              g: 2
            };
            L(a, "type", b);
            a = b;
            break a;
        }
        a = void 0;
      }
      return a;
    },
    oh = (a, b) => {
      O(F(a, "firstOperand")[1], b);
      O(F(a, "secondOperand")[1], b);
      b = {
        type: 0,
        g: 3
      };
      L(a, "type", b);
      return b;
    },
    ph = (a, b) => {
      O(F(a, "firstOperand")[1], b);
      O(F(a, "secondOperand")[1], b);
      b = I(J(a, ["firstOperand", "*"]), "type");
      const c = I(J(a, ["secondOperand", "*"]), "type");
      b = {
        type: 0,
        g: wc(b) || wc(c) ? 0 : 3
      };
      L(a, "type", b);
      return b;
    },
    qh = (a, b) => {
      O(F(a, "firstOperand")[1], b);
      O(F(a, "secondOperand")[1], b);
      b = I(J(a, ["firstOperand", "*"]), "type");
      const c = I(J(a, ["secondOperand", "*"]), "type");
      b = {
        type: 0,
        g: wc(b) || wc(c) ? 0 : 3
      };
      L(a, "type", b);
      return b;
    },
    kh = new Map([["unaryMinusOp", (a, b) => {
      b = O(F(a, "operand")[1], b);
      b ? v(b.type, 2) ? (b = {
        type: b.type,
        g: b.g
      }, L(a, "type", b), a = b) : (b = {
        type: 3,
        g: 3
      }, L(a, "type", b), a = b) : (b = {
        type: 2,
        g: 2
      }, L(a, "type", b), a = b);
      return a;
    }], ["unaryPlusOp", (a, b) => {
      b = O(F(a, "operand")[1], b);
      b ? v(b.type, 2) ? (b = {
        type: b.type,
        g: b.g
      }, L(a, "type", b), a = b) : (b = {
        type: 3,
        g: 3
      }, L(a, "type", b), a = b) : (b = {
        type: 2,
        g: 2
      }, L(a, "type", b), a = b);
      return a;
    }], ["addOp", lh], ["subtractOp", lh], ["divOp", lh], ["idivOp", lh], ["modOp", lh], ["multiplyOp", lh], ["andOp", mh], ["orOp", mh], ["sequenceExpr", (a, b) => {
      const c = K(a, "*"),
        d = c.map(e => O(e, b));
      return gh(a, c.length, d);
    }], ["unionOp", nh], ["intersectOp", nh], ["exceptOp", nh], ["stringConcatenateOp", (a, b) => {
      O(F(a, "firstOperand")[1], b);
      O(F(a, "secondOperand")[1], b);
      b = {
        type: 1,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["rangeSequenceExpr", (a, b) => {
      O(F(a, "startExpr")[1], b);
      O(F(a, "endExpr")[1], b);
      b = {
        type: 5,
        g: 1
      };
      L(a, "type", b);
      return b;
    }], ["equalOp", oh], ["notEqualOp", oh], ["lessThanOrEqualOp", oh], ["lessThanOp", oh], ["greaterThanOrEqualOp", oh], ["greaterThanOp", oh], ["eqOp", ph], ["neOp", ph], ["ltOp", ph], ["leOp", ph], ["gtOp", ph], ["geOp", ph], ["isOp", qh], ["nodeBeforeOp", qh], ["nodeAfterOp", qh], ["pathExpr", (a, b) => {
      const c = F(a, "rootExpr");
      c && c[1] && O(c[1], b);
      K(a, "stepExpr").map(d => O(d, b));
      return eh(a, b);
    }], ["contextItemExpr", () => ({
      type: 59,
      g: 2
    })], ["ifThenElseExpr", (a, b) => {
      var c = F(a, "ifClause") || F(K(a, "x:stackTrace")[0], "ifClause");
      const d = F(a, "thenClause") || F(K(a, "x:stackTrace")[1], "thenClause"),
        e = F(a, "elseClause") || F(K(a, "x:stackTrace")[2], "elseClause");
      O(F(c, "*"), b);
      c = O(F(d, "*"), b);
      b = O(F(e, "*"), b);
      c && b ? c.type === b.type && c.g === b.g ? (59 !== c.type && L(a, "type", c), a = c) : a = {
        type: 59,
        g: 2
      } : a = {
        type: 59,
        g: 2
      };
      return a;
    }], ["instanceOfExpr", (a, b) => {
      O(F(a, "argExpr"), b);
      O(F(a, "sequenceType"), b);
      b = {
        type: 0,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["integerConstantExpr", a => {
      const b = {
        type: 5,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["doubleConstantExpr", a => {
      const b = {
        type: 3,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["decimalConstantExpr", a => {
      const b = {
        type: 4,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["stringConstantExpr", a => {
      const b = {
        type: 1,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["functionCallExpr", (a, b) => {
      const c = F(a, "arguments");
      K(c, "*").map(d => O(d, b));
      return bh(a, b);
    }], ["arrowExpr", (a, b) => {
      O(F(a, "argExpr")[1], b);
      return Ng(a, b);
    }], ["dynamicFunctionInvocationExpr", (a, b) => {
      O(J(a, ["functionItem", "*"]), b);
      (a = F(a, "arguments")) && O(a, b);
      return {
        type: 59,
        g: 2
      };
    }], ["namedFunctionRef", (a, b) => dh(a, b)], ["inlineFunctionExpr", (a, b) => {
      O(F(a, "functionBody")[1], b);
      b = {
        type: 60,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["castExpr", a => {
      var b = J(a, ["singleType", "atomicType"]);
      b = {
        type: Ia(I(b, "prefix") + ":" + b[2]),
        g: 3
      };
      59 !== b.type && L(a, "type", b);
      return b;
    }], ["castableExpr", a => {
      const b = {
        type: 0,
        g: 3
      };
      L(a, "type", b);
      return b;
    }], ["simpleMapExpr", (a, b) => {
      const c = K(a, "pathExpr");
      let d;
      for (let e = 0; e < c.length; e++) d = O(c[e], b);
      void 0 !== d && null !== d ? ((b = {
        type: d.type,
        g: 2
      }, 59 !== b.type) && L(a, "type", b), a = b) : a = {
        type: 59,
        g: 2
      };
      return a;
    }], ["mapConstructor", (a, b) => {
      K(a, "mapConstructorEntry").map(c => ({
        key: O(J(c, ["mapKeyExpr", "*"]), b),
        value: O(J(c, ["mapValueExpr", "*"]), b)
      }));
      return ch(a);
    }], ["arrayConstructor", (a, b) => {
      K(F(a, "*"), "arrayElem").map(c => O(c, b));
      return Mg(a);
    }], ["unaryLookup", a => {
      F(a, "NCName");
      return {
        type: 59,
        g: 2
      };
    }], ["typeswitchExpr", (a, b) => {
      const c = O(F(a, "argExpr")[1], b),
        d = K(a, "typeswitchExprCaseClause").map(f => O(J(f, ["resultExpr"])[1], b)),
        e = O(J(a, ["typeswitchExprDefaultClause", "resultExpr"])[1], b);
      return hh(a, c, d, e);
    }], ["quantifiedExpr", (a, b) => {
      K(a, "*").map(c => O(c, b));
      return fh(a);
    }], ["x:stackTrace", (a, b) => {
      a = K(a, "*");
      return O(a[0], b);
    }], ["queryBody", (a, b) => O(a[1], b)], ["flworExpr", (a, b) => Xg(a, b)], ["varRef", (a, b) => {
      const c = Kg(F(a, "name"));
      var d;
      a: {
        for (d = b.h; 0 <= d; d--) {
          const e = b.o[d][c.localName];
          if (e) {
            d = e;
            break a;
          }
        }
        d = void 0;
      }
      d && 59 !== d.type && L(a, "type", d);
      null === c.namespaceURI && (b = b.$(c.prefix), void 0 !== b && L(a, "URI", b));
      return d;
    }]]);
  function Yg(a) {
    a.h++;
    a.o.push({});
    a.v.push({});
  }
  function Zg(a, b, c) {
    if (a.o[a.h][b]) throw Error(`Another variable of in the scope ${a.h} with the same name ${b} already exists`);
    a.o[a.h][b] = c;
  }
  var rh = class {
    constructor(a) {
      this.h = 0;
      this.ga = a;
      this.o = [{}];
      this.v = [{}];
    }
    $(a) {
      for (let b = this.h; 0 <= b; b--) {
        const c = this.v[b][a];
        if (void 0 !== c) return c;
      }
      return this.ga ? this.ga.$(a) : void 0;
    }
  };
  var sh = class extends D {
    constructor(a, b) {
      super(new vf({
        external: 1
      }), a, {
        B: a.every(c => c.B)
      }, !1, b);
      this.l = a;
    }
    h(a, b) {
      return 0 === this.l.length ? w.m(new pb([])) : C(this.l[0], a, b).N(c => w.m(new pb(c.map(d => Ra(w.m(d))))));
    }
  };
  var th = class extends D {
    constructor(a, b) {
      super(new vf({
        external: 1
      }), a, {
        B: a.every(c => c.B)
      }, !1, b);
      this.l = a;
    }
    h(a, b) {
      return w.m(new pb(this.l.map(c => Ra(C(c, a, b)))));
    }
  };
  function uh(a) {
    if (null === a) throw lc("context is absent, it needs to be present to use axes.");
    if (!v(a.type, 53)) throw Error("XPTY0020: Axes can only be applied to nodes.");
    return a.value;
  }
  function vh(a, b, c) {
    let d = b;
    return {
      next: () => {
        if (!d) return p;
        const e = d;
        d = x(a, e, c);
        return q(rb(e));
      }
    };
  }
  var wh = class extends D {
    constructor(a, b) {
      b = b || {
        Qa: !1
      };
      super(a.o, [a], {
        R: "reverse-sorted",
        W: !1,
        subtree: !1,
        B: !1
      });
      this.l = a;
      this.s = !!b.Qa;
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      var c = this.l.D();
      c = c && (c.startsWith("name-") || "type-1" === c) ? "type-1" : null;
      return w.create(vh(b, this.s ? a : x(b, a, c), c)).filter(d => this.l.l(d));
    }
  };
  const xh = new Map([["type-1-or-type-2", ["name", "type-1", "type-2"]], ["type-1", ["name"]], ["type-2", ["name"]]]);
  function yh(a, b) {
    if (null === a) return b;
    if (null === b || a === b) return a;
    const c = a.startsWith("name-") ? "name" : a,
      d = b.startsWith("name-") ? "name" : b,
      e = xh.get(c);
    if (void 0 !== e && e.includes(d)) return b;
    b = xh.get(d);
    return void 0 !== b && b.includes(c) ? a : "empty";
  }
  var zh = class extends D {
    constructor(a, b) {
      super(new vf({
        attribute: 1
      }), [a], {
        R: "unsorted",
        subtree: !0,
        W: !0,
        B: !1
      });
      this.l = a;
      this.s = yh(this.l.D(), b);
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      if (1 !== a.node.nodeType) return w.empty();
      a = eb(b, a, this.s).filter(c => "http://www.w3.org/2000/xmlns/" !== c.node.namespaceURI).map(c => rb(c)).filter(c => this.l.l(c));
      return w.create(a);
    }
    D() {
      return "type-1";
    }
  };
  var Ah = class extends D {
    constructor(a, b) {
      super(a.o, [a], {
        R: "sorted",
        subtree: !0,
        W: !0,
        B: !1
      });
      this.s = a;
      this.l = yh(b, a.D());
    }
    h(a, b) {
      const c = b.h,
        d = uh(a.M);
      a = d.node.nodeType;
      if (1 !== a && 9 !== a) return w.empty();
      let e = null,
        f = !1;
      return w.create({
        next: () => {
          for (; !f;) {
            if (!e) {
              e = jb(c, d, this.l);
              if (!e) {
                f = !0;
                continue;
              }
              return q(rb(e));
            }
            if (e = lb(c, e, this.l)) return q(rb(e));
            f = !0;
          }
          return p;
        }
      }).filter(h => this.s.l(h));
    }
  };
  function Bh(a, b, c) {
    const d = b.node.nodeType;
    if (1 !== d && 9 !== d) return {
      next: () => p
    };
    let e = jb(a, b, c);
    return {
      next() {
        if (!e) return p;
        const f = e;
        e = lb(a, e, c);
        return q(f);
      }
    };
  }
  function Ch(a, b, c) {
    const d = [kd(b)];
    return {
      next: e => {
        0 < d.length && 0 !== (e & 1) && d.shift();
        if (!d.length) return p;
        for (e = d[0].next(0); e.done;) {
          d.shift();
          if (!d.length) return p;
          e = d[0].next(0);
        }
        d.unshift(Bh(a, e.value, c));
        return q(rb(e.value));
      }
    };
  }
  var Dh = class extends D {
    constructor(a, b) {
      b = b || {
        Qa: !1
      };
      super(a.o, [a], {
        B: !1,
        W: !1,
        R: "sorted",
        subtree: !0
      });
      this.l = a;
      this.s = !!b.Qa;
      this.A = (a = this.l.D()) && (a.startsWith("name-") || "type-1" === a) || "type-1-or-type-2" === a ? "type-1" : null;
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      a = Ch(b, a, this.A);
      this.s || a.next(0);
      return w.create(a).filter(c => this.l.l(c));
    }
  };
  function Eh(a, b, c) {
    var d = a.node.nodeType;
    if (1 !== d && 9 !== d) return a;
    for (d = kb(b, a, c); null !== d;) {
      if (1 !== d.node.nodeType) return d;
      a = d;
      d = kb(b, a, c);
    }
    return a;
  }
  function Fh(a, b, c = !1, d) {
    if (c) {
      let f = b,
        h = !1;
      return {
        next: () => {
          if (h) return p;
          if (md(f, b)) return f = Eh(b, a, d), md(f, b) ? (h = !0, p) : q(rb(f));
          const k = f.node.nodeType,
            l = 9 === k || 2 === k ? null : mb(a, f, d);
          if (null !== l) return f = Eh(l, a, d), q(rb(f));
          f = 9 === k ? null : x(a, f, d);
          return md(f, b) ? (h = !0, p) : q(rb(f));
        }
      };
    }
    const e = [Bh(a, b, d)];
    return {
      next: () => {
        if (!e.length) return p;
        let f = e[0].next(0);
        for (; f.done;) {
          e.shift();
          if (!e.length) return p;
          f = e[0].next(0);
        }
        e.unshift(Bh(a, f.value, d));
        return q(rb(f.value));
      }
    };
  }
  function Gh(a, b, c) {
    const d = [];
    for (; b && 9 !== b.node.nodeType; b = x(a, b, null)) {
      const f = lb(a, b, c);
      f && d.push(f);
    }
    let e = null;
    return {
      next: () => {
        for (; e || d.length;) {
          if (!e) {
            e = Fh(a, d[0], !1, c);
            var f = q(rb(d[0]));
            const h = lb(a, d[0], c);
            h ? d[0] = h : d.shift();
            return f;
          }
          f = e.next(0);
          if (f.done) e = null;else return f;
        }
        return p;
      }
    };
  }
  var Hh = class extends D {
    constructor(a) {
      super(a.o, [a], {
        R: "sorted",
        W: !0,
        subtree: !1,
        B: !1
      });
      this.l = a;
      this.s = (a = this.l.D()) && (a.startsWith("name-") || "type-1" === a) ? "type-1" : null;
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      return w.create(Gh(b, a, this.s)).filter(c => this.l.l(c));
    }
  };
  function Ih(a, b, c) {
    return {
      next: () => (b = b && lb(a, b, c)) ? q(rb(b)) : p
    };
  }
  var Jh = class extends D {
    constructor(a, b) {
      super(a.o, [a], {
        R: "sorted",
        W: !0,
        subtree: !1,
        B: !1
      });
      this.l = a;
      this.s = yh(this.l.D(), b);
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      return w.create(Ih(b, a, this.s)).filter(c => this.l.l(c));
    }
  };
  var Kh = class extends D {
    constructor(a, b) {
      super(a.o, [a], {
        R: "reverse-sorted",
        W: !0,
        subtree: !0,
        B: !1
      });
      this.l = a;
      this.s = yh(b, this.l.D());
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      a = x(b, a, this.s);
      if (!a) return w.empty();
      a = rb(a);
      return this.l.l(a) ? w.m(a) : w.empty();
    }
  };
  function Lh(a, b, c) {
    const d = [];
    for (; b && 9 !== b.node.nodeType; b = x(a, b, null)) {
      const f = mb(a, b, c);
      null !== f && d.push(f);
    }
    let e = null;
    return {
      next: () => {
        for (; e || d.length;) {
          e ||= Fh(a, d[0], !0, c);
          var f = e.next(0);
          if (f.done) {
            e = null;
            f = mb(a, d[0], c);
            const h = q(rb(d[0]));
            null === f ? d.shift() : d[0] = f;
            return h;
          }
          return f;
        }
        return p;
      }
    };
  }
  var Mh = class extends D {
    constructor(a) {
      super(a.o, [a], {
        B: !1,
        W: !0,
        R: "reverse-sorted",
        subtree: !1
      });
      this.l = a;
      this.s = (a = this.l.D()) && (a.startsWith("name-") || "type-1" === a) ? "type-1" : null;
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      return w.create(Lh(b, a, this.s)).filter(c => this.l.l(c));
    }
  };
  function Nh(a, b, c) {
    return {
      next: () => (b = b && mb(a, b, c)) ? q(rb(b)) : p
    };
  }
  var Oh = class extends D {
    constructor(a, b) {
      super(a.o, [a], {
        B: !1,
        W: !0,
        R: "reverse-sorted",
        subtree: !1
      });
      this.l = a;
      this.s = yh(this.l.D(), b);
    }
    h(a, b) {
      b = b.h;
      a = uh(a.M);
      return w.create(Nh(b, a, this.s)).filter(c => this.l.l(c));
    }
  };
  var Ph = class extends D {
    constructor(a, b) {
      super(a.o, [a], {
        R: "sorted",
        subtree: !0,
        W: !0,
        B: !1
      });
      this.l = a;
      this.s = yh(this.l.D(), b);
    }
    h(a) {
      uh(a.M);
      return this.l.l(a.M) ? w.m(a.M) : w.empty();
    }
    D() {
      return this.s;
    }
  };
  var Qh = class extends rf {
    constructor(a, b, c, d) {
      super(a.o.add(b.o).add(c.o), [a, b, c], {
        B: a.B && b.B && c.B,
        W: b.W === c.W && b.W,
        R: b.ia === c.ia ? b.ia : "unsorted",
        subtree: b.subtree === c.subtree && b.subtree
      }, d);
      this.l = a;
    }
    A(a, b, c) {
      let d = null;
      const e = c[0](a);
      return w.create({
        next: f => {
          d || (d = (e.fa() ? c[1](a) : c[2](a)).value);
          return d.next(f);
        }
      });
    }
    v(a) {
      super.v(a);
      if (this.l.I) throw Oe();
    }
  };
  function ig(a) {
    return a.h instanceof Error ? a.location : ig(a.h);
  }
  function jg(a) {
    let b;
    b = a.h instanceof gg ? ["Inner error:", a.h.message] : a.h instanceof Error ? [a.h.toString()] : jg(a.h);
    b.push(`  at <${a.o}${a.Wa ? ` (${a.Wa})` : ""}>:${a.location.start.line}:${a.location.start.ha} - ${a.location.end.line}:${a.location.end.ha}`);
    return b;
  }
  var Rh = class {
    constructor(a, b, c, d) {
      this.location = a;
      this.o = b;
      this.Wa = c;
      this.h = d;
    }
  };
  var Sh = class extends rf {
    constructor(a, b, c, d) {
      super(c.o, [c], {
        B: c.B,
        W: c.W,
        R: c.ia,
        subtree: c.subtree
      });
      this.L = b;
      this.P = {
        end: {
          ha: a.end.ha,
          line: a.end.line,
          offset: a.end.offset
        },
        start: {
          ha: a.start.ha,
          line: a.start.line,
          offset: a.start.offset
        }
      };
      this.l = d;
    }
    A(a, b, [c]) {
      let d;
      try {
        d = c(a);
      } catch (e) {
        throw new Rh(this.P, this.L, this.l, e);
      }
      return w.create({
        next: e => {
          try {
            return d.value.next(e);
          } catch (f) {
            throw new Rh(this.P, this.L, this.l, f);
          }
        }
      });
    }
    v(a) {
      try {
        super.v(a);
      } catch (b) {
        throw new Rh(this.P, this.L, this.l, b);
      }
    }
    D() {
      return this.Fa[0].D();
    }
  };
  function Th(a, b, c, d) {
    let e = [];
    const f = a.L(b, c, d, k => {
      if (a.l instanceof Uh) {
        const n = Th(a.l, b, k, d);
        return pf(n, t => e = t);
      }
      let l = null;
      return w.create({
        next: () => {
          for (;;) {
            if (!l) {
              var n = k.next(0);
              if (n.done) return p;
              n = a.l.s(n.value, d);
              l = pf(n, t => e = mf(e, t)).value;
            }
            n = l.next(0);
            if (n.done) l = null;else return n;
          }
        }
      });
    });
    let h = !1;
    return {
      next: () => {
        if (h) return p;
        const k = f.O();
        h = !0;
        return q(new Ze(k, e));
      }
    };
  }
  function Vh(a, b, c, d) {
    return a.L(b, c, d, e => {
      if (a.l instanceof Uh) return Vh(a.l, b, e, d);
      let f = null;
      return w.create({
        next: () => {
          for (;;) {
            if (!f) {
              var h = e.next(0);
              if (h.done) return p;
              f = C(a.l, h.value, d).value;
            }
            h = f.next(0);
            if (h.done) f = null;else return h;
          }
        }
      });
    });
  }
  var Uh = class extends D {
    constructor(a, b, c, d) {
      super(a, b, c, !0);
      this.l = d;
      this.I = this.l.I;
    }
    h(a, b) {
      return this.L(a, kd(a), b, c => {
        if (this.l instanceof Uh) return Vh(this.l, a, c, b);
        let d = null;
        return w.create({
          next: e => {
            for (;;) {
              if (!d) {
                var f = c.next(0);
                if (f.done) return p;
                d = C(this.l, f.value, b).value;
              }
              f = d.next(e);
              if (f.done) d = null;else return f;
            }
          }
        });
      });
    }
    s(a, b) {
      return Th(this, a, kd(a), b);
    }
    v(a) {
      super.v(a);
      this.I = this.l.I;
      for (const b of this.Fa) if (b !== this.l && b.I) throw Oe();
    }
  };
  var Wh = class extends Uh {
    constructor(a, b, c, d) {
      super(b.o.add(d.o), [b, d], {
        B: !1
      }, d);
      this.P = a.prefix;
      this.ma = a.namespaceURI;
      this.Pb = a.localName;
      this.yb = null;
      this.A = c;
      this.La = null;
      this.ya = b;
    }
    L(a, b, c, d) {
      let e = null,
        f = null,
        h = 0;
      return d({
        next: () => {
          for (;;) {
            if (!e) {
              var k = b.next(0);
              if (k.done) return p;
              f = k.value;
              h = 0;
              e = C(this.ya, f, c).value;
            }
            const l = e.next(0);
            if (l.done) e = null;else return h++, k = {
              [this.yb]: () => w.m(l.value)
            }, this.La && (k[this.La] = () => w.m(new Ca(5, h))), q(hc(f, k));
          }
        }
      });
    }
    v(a) {
      if (this.P && (this.ma = a.$(this.P), !this.ma && this.P)) throw Error(`XPST0081: Could not resolve namespace for prefix ${this.P} in a for expression`);
      this.ya.v(a);
      Dg(a);
      this.yb = Hg(a, this.ma, this.Pb);
      if (this.A) {
        if (this.A.prefix && (this.A.namespaceURI = a.$(this.A.prefix), !this.A.namespaceURI && this.A.prefix)) throw Error(`XPST0081: Could not resolve namespace for prefix ${this.P} in the positionalVariableBinding in a for expression`);
        this.La = Hg(a, this.A.namespaceURI, this.A.localName);
      }
      this.l.v(a);
      Jg(a);
      if (this.ya.I) throw Oe();
      this.l.I && (this.I = !0);
    }
  };
  var Xh = class extends D {
    constructor(a, b, c) {
      super(new vf({
        external: 1
      }), [c], {
        B: !1,
        R: "unsorted"
      });
      this.P = a.map(({
        name: d
      }) => d);
      this.A = a.map(({
        type: d
      }) => d);
      this.s = null;
      this.L = b;
      this.l = c;
    }
    h(a, b) {
      const c = new Va({
        j: this.A,
        arity: this.A.length,
        Ya: !0,
        I: this.l.I,
        localName: "dynamic-function",
        namespaceURI: "",
        i: this.L,
        value: (d, e, f, ...h) => {
          d = hc(bc(a, -1, null, w.empty()), this.s.reduce((k, l, n) => {
            k[l] = Ra(h[n]);
            return k;
          }, Object.create(null)));
          return C(this.l, d, b);
        }
      });
      return w.m(c);
    }
    v(a) {
      Dg(a);
      this.s = this.P.map(b => Hg(a, b.namespaceURI, b.localName));
      this.l.v(a);
      Jg(a);
      if (this.l.I) throw Error("Not implemented: inline functions can not yet be updating.");
    }
  };
  var Yh = class extends Uh {
    constructor(a, b, c) {
      super(b.o.add(c.o), [b, c], {
        B: !1,
        W: c.W,
        R: c.ia,
        subtree: c.subtree
      }, c);
      if (a.prefix || a.namespaceURI) throw Error("Not implemented: let expressions with namespace usage.");
      this.A = a.prefix;
      this.P = a.namespaceURI;
      this.La = a.localName;
      this.ma = b;
      this.ya = null;
    }
    L(a, b, c, d) {
      return d({
        next: () => {
          var e = b.next(0);
          if (e.done) return p;
          e = e.value;
          e = hc(e, {
            [this.ya]: Ra(C(this.ma, e, c))
          });
          return q(e);
        }
      });
    }
    v(a) {
      if (this.A && (this.P = a.$(this.A), !this.P && this.A)) throw Error(`XPST0081: Could not resolve namespace for prefix ${this.A} using in a for expression`);
      this.ma.v(a);
      Dg(a);
      this.ya = Hg(a, this.P, this.La);
      this.l.v(a);
      Jg(a);
      this.I = this.l.I;
      if (this.ma.I) throw Oe();
    }
  };
  var Zh = class extends D {
    constructor(a, b) {
      super(new vf({}), [], {
        B: !0,
        R: "sorted"
      }, !1, b);
      let c;
      switch (b.type) {
        case 5:
          c = g(parseInt(a, 10), b.type);
          break;
        case 1:
          c = g(a, b.type);
          break;
        case 4:
        case 3:
          c = g(parseFloat(a), b.type);
          break;
        default:
          throw new TypeError("Type " + b + " not expected in a literal");
      }
      this.l = () => w.m(c);
    }
    h() {
      return this.l();
    }
  };
  var $h = class extends D {
    constructor(a, b) {
      super(new vf({
        external: 1
      }), a.reduce((c, {
        key: d,
        value: e
      }) => c.concat(d, e), []), {
        B: !1
      }, !1, b);
      this.l = a;
    }
    h(a, b) {
      const c = this.l.map(d => qc(C(d.key, a, b), b).X({
        default: () => {
          throw Error("XPTY0004: A key of a map should be a single atomizable value.");
        },
        m: e => e
      }));
      return A(c, d => w.m(new ub(d.map((e, f) => ({
        key: e,
        value: Ra(C(this.l[f].value, a, b))
      })))));
    }
  };
  var ai = class extends D {
    constructor(a, b, c) {
      super(new vf({
        external: 1
      }), [], {
        B: !0
      }, !1, c);
      this.s = b;
      this.A = a;
      this.l = null;
    }
    h() {
      const a = new Va({
        j: this.l.j,
        I: this.l.I,
        arity: this.s,
        localName: this.l.localName,
        namespaceURI: this.l.namespaceURI,
        i: this.l.i,
        value: this.l.callFunction
      });
      return w.m(a);
    }
    v(a) {
      let b = this.A.namespaceURI,
        c = this.A.localName;
      const d = this.A.prefix;
      if (null === b) {
        const e = a.Sa({
          localName: c,
          prefix: d
        }, this.s);
        if (!e) throw Error(`XPST0017: The function ${d ? d + ":" : ""}${c} with arity ${this.s} could not be resolved. ${mg(c)}`);
        b = e.namespaceURI;
        c = e.localName;
      }
      this.l = a.va(b, c, this.s) || null;
      if (!this.l) throw a = this.A, Error(`XPST0017: Function ${`${a.namespaceURI ? `Q{${a.namespaceURI}}` : a.prefix ? `${a.prefix}:` : ""}${a.localName}`} with arity of ${this.s} not registered. ${mg(c)}`);
      super.v(a);
    }
  };
  const bi = {
    [5]: 5,
    [27]: 5,
    [28]: 5,
    [31]: 5,
    [32]: 5,
    [33]: 5,
    [34]: 5,
    [30]: 5,
    [36]: 5,
    [35]: 5,
    [38]: 5,
    [37]: 5,
    [29]: 5,
    [4]: 4,
    [6]: 6,
    [3]: 3
  };
  var ci = class extends D {
    constructor(a, b, c) {
      super(b.o, [b], {
        B: !1
      }, !1, c);
      this.s = b;
      this.l = a;
    }
    h(a, b) {
      return qc(C(this.s, a, b), b).N(c => {
        if (0 === c.length) return w.empty();
        var d = c[0];
        if (this.type) return c = "+" === this.l ? +d.value : -d.value, 0 === d.type && (c = Number.NaN), w.m(g(c, this.type.type));
        if (1 < c.length) throw Error("XPTY0004: The operand to a unary operator must be a sequence with a length less than one");
        return v(d.type, 19) ? (d = jd(d, 3).value, w.m(g("+" === this.l ? d : -d, 3))) : v(d.type, 2) ? "+" === this.l ? w.m(d) : w.m(g(-1 * d.value, bi[d.type])) : w.m(g(Number.NaN, 3));
      });
    }
  };
  var di = class extends D {
    constructor(a, b) {
      super(a.reduce((c, d) => c.add(d.o), new vf({})), a, {
        B: a.every(c => c.B)
      }, !1, b);
      this.l = a;
      this.s = a.reduce((c, d) => yh(c, d.D()), null);
    }
    h(a, b) {
      let c = 0,
        d = null,
        e = !1,
        f = null;
      if (null !== a) {
        const h = a.M;
        null !== h && v(h.type, 53) && (f = Xa(h.value));
      }
      return w.create({
        next: () => {
          if (!e) {
            for (; c < this.l.length;) {
              if (!d) {
                const h = this.l[c];
                if (null !== f && null !== h.D() && !f.includes(h.D())) return c++, e = !0, q(wa);
                d = C(h, a, b);
              }
              if (!1 === d.fa()) return e = !0, q(wa);
              d = null;
              c++;
            }
            e = !0;
            return q(va);
          }
          return p;
        }
      });
    }
    D() {
      return this.s;
    }
  };
  var ei = class extends D {
    constructor(a, b) {
      super(a.reduce((d, e) => 0 < uf(d, e.o) ? d : e.o, new vf({})), a, {
        B: a.every(d => d.B)
      }, !1, b);
      let c;
      for (b = 0; b < a.length; ++b) {
        void 0 === c && (c = a[b].D());
        if (null === c) break;
        if (c !== a[b].D()) {
          c = null;
          break;
        }
      }
      this.s = c;
      this.l = a;
    }
    h(a, b) {
      let c = 0,
        d = null,
        e = !1,
        f = null;
      if (null !== a) {
        const h = a.M;
        null !== h && v(h.type, 53) && (f = Xa(h.value));
      }
      return w.create({
        next: () => {
          if (!e) {
            for (; c < this.l.length;) {
              if (!d) {
                const h = this.l[c];
                if (null !== f && null !== h.D() && !f.includes(h.D())) {
                  c++;
                  continue;
                }
                d = C(h, a, b);
              }
              if (!0 === d.fa()) return e = !0, q(va);
              d = null;
              c++;
            }
            e = !0;
            return q(wa);
          }
          return p;
        }
      });
    }
    D() {
      return this.s;
    }
  };
  function fi(a, b) {
    let c;
    return w.create({
      next: d => {
        for (;;) {
          if (!c) {
            var e = a.value.next(d);
            if (e.done) return p;
            c = pc(e.value, b);
          }
          e = c.value.next(d);
          if (e.done) c = null;else return e;
        }
      }
    });
  }
  function gi(a, b) {
    if ("eqOp" === a) return (c, d) => {
      const {
        U: e,
        V: f
      } = b(c, d);
      return e.value.namespaceURI === f.value.namespaceURI && e.value.localName === f.value.localName;
    };
    if ("neOp" === a) return (c, d) => {
      const {
        U: e,
        V: f
      } = b(c, d);
      return e.value.namespaceURI !== f.value.namespaceURI || e.value.localName !== f.value.localName;
    };
    throw Error('XPTY0004: Only the "eq" and "ne" comparison is defined for xs:QName');
  }
  function hi(a, b) {
    switch (a) {
      case "eqOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value === f.value;
        };
      case "neOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value !== f.value;
        };
      case "ltOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value < f.value;
        };
      case "leOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value <= f.value;
        };
      case "gtOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value > f.value;
        };
      case "geOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value >= f.value;
        };
    }
  }
  function ii(a, b) {
    switch (a) {
      case "ltOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value.ea < f.value.ea;
        };
      case "leOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return vb(e.value, f.value) || e.value.ea < f.value.ea;
        };
      case "gtOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value.ea > f.value.ea;
        };
      case "geOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return vb(e.value, f.value) || e.value.ea > f.value.ea;
        };
    }
  }
  function ji(a, b) {
    switch (a) {
      case "eqOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return vb(e.value, f.value);
        };
      case "ltOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value.ca < f.value.ca;
        };
      case "leOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return vb(e.value, f.value) || e.value.ca < f.value.ca;
        };
      case "gtOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return e.value.ca > f.value.ca;
        };
      case "geOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return vb(e.value, f.value) || e.value.ca > f.value.ca;
        };
    }
  }
  function ki(a, b) {
    switch (a) {
      case "eqOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return vb(e.value, f.value);
        };
      case "neOp":
        return (c, d) => {
          const {
            U: e,
            V: f
          } = b(c, d);
          return !vb(e.value, f.value);
        };
    }
  }
  function li(a, b) {
    switch (a) {
      case "eqOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          return Ob(f.value, h.value, fc(e));
        };
      case "neOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          return !Ob(f.value, h.value, fc(e));
        };
      case "ltOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          c = fc(e);
          return 0 > Nb(f.value, h.value, c);
        };
      case "leOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          (c = Ob(f.value, h.value, fc(e))) || (e = fc(e), c = 0 > Nb(f.value, h.value, e));
          return c;
        };
      case "gtOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          c = fc(e);
          return 0 < Nb(f.value, h.value, c);
        };
      case "geOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          (c = Ob(f.value, h.value, fc(e))) || (e = fc(e), c = 0 < Nb(f.value, h.value, e));
          return c;
        };
    }
  }
  function mi(a, b) {
    switch (a) {
      case "eqOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          return Ob(f.value, h.value, fc(e));
        };
      case "neOp":
        return (c, d, e) => {
          const {
            U: f,
            V: h
          } = b(c, d);
          return !Ob(f.value, h.value, fc(e));
        };
    }
  }
  function ni(a, b, c) {
    function d(n, t) {
      return {
        U: h ? h(n) : n,
        V: k ? k(t) : t
      };
    }
    function e(n) {
      return v(b, n) && v(c, n);
    }
    function f(n) {
      return 0 < n.filter(t => v(b, t)).length && 0 < n.filter(t => v(c, t)).length;
    }
    let h = null,
      k = null;
    v(b, 19) && v(c, 19) ? b = c = 1 : v(b, 19) ? (h = n => jd(n, c), b = c) : v(c, 19) && (k = n => jd(n, b), c = b);
    if (v(b, 23) && v(c, 23)) return gi(a, d);
    if (e(0) || f([1, 47, 61]) || f([2, 47, 61]) || e(20) || e(22) || e(21) || f([1, 20])) {
      var l = hi(a, d);
      if (void 0 !== l) return l;
    }
    if (e(16) && (l = ii(a, d), void 0 !== l) || e(17) && (l = ji(a, d), void 0 !== l) || e(18) && (l = ki(a, d), void 0 !== l)) return l;
    if (e(9) || e(7) || e(8)) if (l = li(a, d), void 0 !== l) return l;
    if (e(11) || e(12) || e(13) || e(14) || e(15)) if (l = mi(a, d), void 0 !== l) return l;
    throw Error(`XPTY0004: ${a} not available for ${Da[b]} and ${Da[c]}`);
  }
  const oi = Object.create(null);
  function pi(a, b, c) {
    const d = `${b}~${c}~${a}`;
    let e = oi[d];
    e ||= oi[d] = ni(a, b, c);
    return e;
  }
  var qi = class extends D {
    constructor(a, b, c) {
      super(b.o.add(c.o), [b, c], {
        B: !1
      });
      this.l = b;
      this.A = c;
      this.s = a;
    }
    h(a, b) {
      const c = C(this.l, a, b),
        d = C(this.A, a, b),
        e = fi(c, b),
        f = fi(d, b);
      return e.X({
        empty: () => w.empty(),
        m: () => f.X({
          empty: () => w.empty(),
          m: () => {
            const h = e.first(),
              k = f.first();
            return pi(this.s, h.type, k.type)(h, k, a) ? w.aa() : w.T();
          },
          multiple: () => {
            throw Error("XPTY0004: Sequences to compare are not singleton.");
          }
        }),
        multiple: () => {
          throw Error("XPTY0004: Sequences to compare are not singleton.");
        }
      });
    }
  };
  const ri = {
    equalOp: "eqOp",
    notEqualOp: "neOp",
    lessThanOrEqualOp: "leOp",
    lessThanOp: "ltOp",
    greaterThanOrEqualOp: "geOp",
    greaterThanOp: "gtOp"
  };
  function si(a, b, c, d) {
    a = ri[a];
    return c.N(e => b.filter(f => {
      for (let l = 0, n = e.length; l < n; ++l) {
        let t = e[l],
          u = void 0,
          z = void 0;
        var h = f.type,
          k = t.type;
        if (v(h, 19) || v(k, 19)) v(h, 2) ? u = 3 : v(k, 2) ? z = 3 : v(h, 17) ? u = 17 : v(k, 17) ? z = 17 : v(h, 16) ? u = 16 : v(k, 16) ? z = 16 : v(h, 19) ? z = k : v(k, 19) && (u = h);
        const [y, G] = [z, u];
        h = y;
        k = G;
        h ? f = jd(f, h) : k && (t = jd(t, k));
        if (pi(a, f.type, t.type)(f, t, d)) return !0;
      }
      return !1;
    }).X({
      default: () => w.aa(),
      empty: () => w.T()
    }));
  }
  var ti = class extends D {
    constructor(a, b, c) {
      super(b.o.add(c.o), [b, c], {
        B: !1
      });
      this.l = b;
      this.A = c;
      this.s = a;
    }
    h(a, b) {
      const c = C(this.l, a, b),
        d = C(this.A, a, b);
      return c.X({
        empty: () => w.T(),
        default: () => d.X({
          empty: () => w.T(),
          default: () => {
            const e = fi(c, b),
              f = fi(d, b);
            return si(this.s, e, f, a);
          }
        })
      });
    }
  };
  function ui(a, b, c, d) {
    if (!v(c, 53) || !v(d, 53)) throw Error("XPTY0004: Sequences to compare are not nodes");
    switch (a) {
      case "isOp":
        return vi(c, d);
      case "nodeBeforeOp":
        return b ? (e, f) => 0 > sd(b, e.first(), f.first()) : void 0;
      case "nodeAfterOp":
        return b ? (e, f) => 0 < sd(b, e.first(), f.first()) : void 0;
      default:
        throw Error("Unexpected operator");
    }
  }
  function vi(a, b) {
    return a !== b || 47 !== a && 53 !== a && 54 !== a && 55 !== a && 56 !== a && 57 !== a && 58 !== a ? () => !1 : (c, d) => md(c.first().value, d.first().value);
  }
  var wi = class extends D {
    constructor(a, b, c) {
      super(b.o.add(c.o), [b, c], {
        B: !1
      });
      this.l = b;
      this.A = c;
      this.s = a;
    }
    h(a, b) {
      const c = C(this.l, a, b),
        d = C(this.A, a, b);
      return c.X({
        empty: () => w.empty(),
        multiple: () => {
          throw Error("XPTY0004: Sequences to compare are not singleton");
        },
        m: () => d.X({
          empty: () => w.empty(),
          multiple: () => {
            throw Error("XPTY0004: Sequences to compare are not singleton");
          },
          m: () => {
            const e = c.first(),
              f = d.first();
            return ui(this.s, b.h, e.type, f.type)(c, d, a) ? w.aa() : w.T();
          }
        })
      });
    }
  };
  function xi(a, b, c, d) {
    return c.N(e => {
      if (e.some(f => !v(f.type, 53))) throw Error(`XPTY0004: Sequences given to ${a} should only contain nodes.`);
      return "sorted" === d ? w.create(e) : "reverse-sorted" === d ? w.create(e.reverse()) : w.create(td(b, e));
    });
  }
  var yi = class extends D {
    constructor(a, b, c, d) {
      super(0 < uf(b.o, c.o) ? b.o : c.o, [b, c], {
        B: b.B && c.B
      }, !1, d);
      this.l = a;
      this.s = b;
      this.A = c;
    }
    h(a, b) {
      const c = xi(this.l, b.h, C(this.s, a, b), this.s.ia);
      a = xi(this.l, b.h, C(this.A, a, b), this.A.ia);
      const d = c.value,
        e = a.value;
      let f = null,
        h = null,
        k = !1,
        l = !1;
      return w.create({
        next: () => {
          if (k) return p;
          for (; !l;) {
            if (!f) {
              var n = d.next(0);
              if (n.done) return k = !0, p;
              f = n.value;
            }
            if (!h) {
              n = e.next(0);
              if (n.done) {
                l = !0;
                break;
              }
              h = n.value;
            }
            if (md(f.value, h.value)) {
              if (n = q(f), h = f = null, "intersectOp" === this.l) return n;
            } else if (0 > sd(b.h, f, h)) {
              if (n = q(f), f = null, "exceptOp" === this.l) return n;
            } else h = null;
          }
          if ("exceptOp" === this.l) return null !== f ? (n = q(f), f = null, n) : d.next(0);
          k = !0;
          return p;
        }
      });
    }
  };
  var zi = class extends rf {
    constructor(a, b) {
      super(a.reduce((c, d) => c.add(d.o), new vf({})), a, {
        R: "unsorted",
        B: a.every(c => c.B)
      }, b);
    }
    A(a, b, c) {
      return c.length ? jc(c.map(d => d(a))) : w.empty();
    }
  };
  var Ai = class extends D {
    constructor(a, b, c) {
      super(new vf({}).add(a.o), [a, b], {
        B: a.B && b.B
      }, !1, c);
      this.l = a;
      this.s = b;
    }
    h(a, b) {
      const c = C(this.l, a, b),
        d = dc(a, c);
      let e = null,
        f = null,
        h = !1;
      return w.create({
        next: k => {
          for (; !h;) {
            if (!e && (e = d.next(k), e.done)) return h = !0, p;
            f ||= C(this.s, e.value, b);
            const l = f.value.next(k);
            if (l.done) e = f = null;else return l;
          }
        }
      });
    }
  };
  var Bi = class extends D {
    constructor(a, b, c) {
      super(a.o, [a], {
        B: !1
      });
      this.l = Ia(b.prefix ? `${b.prefix}:${b.localName}` : b.localName);
      if (46 === this.l || 45 === this.l || 44 === this.l) throw Error("XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.");
      if (b.namespaceURI) throw Error("Not implemented: castable as expressions with a namespace URI.");
      this.A = a;
      this.s = c;
    }
    h(a, b) {
      const c = qc(C(this.A, a, b), b);
      return c.X({
        empty: () => this.s ? w.aa() : w.T(),
        m: () => c.map(d => id(d, this.l).u ? va : wa),
        multiple: () => w.T()
      });
    }
  };
  var Ci = class extends D {
    constructor(a, b, c) {
      super(a.o, [a], {
        B: !1
      });
      this.l = Ia(b.prefix ? `${b.prefix}:${b.localName}` : b.localName);
      if (46 === this.l || 45 === this.l || 44 === this.l) throw Error("XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.");
      if (b.namespaceURI) throw Error("Not implemented: casting expressions with a namespace URI.");
      this.A = a;
      this.s = c;
    }
    h(a, b) {
      const c = qc(C(this.A, a, b), b);
      return c.X({
        empty: () => {
          if (!this.s) throw Error("XPTY0004: Sequence to cast is empty while target type is singleton.");
          return w.empty();
        },
        m: () => c.map(d => jd(d, this.l)),
        multiple: () => {
          throw Error("XPTY0004: Sequence to cast is not singleton or empty.");
        }
      });
    }
  };
  function Di(a, b) {
    const c = a.value;
    let d = null,
      e = !1;
    return w.create({
      next: () => {
        for (; !e;) {
          if (!d) {
            var f = c.next(0);
            if (f.done) return e = !0, q(va);
            d = b(f.value);
          }
          f = d.fa();
          d = null;
          if (!1 === f) return e = !0, q(wa);
        }
        return p;
      }
    });
  }
  var Ei = class extends D {
    constructor(a, b, c, d) {
      super(a.o, [a], {
        B: !1
      }, !1, d);
      this.A = a;
      this.s = b;
      this.l = c;
    }
    h(a, b) {
      const c = C(this.A, a, b);
      return c.X({
        empty: () => "?" === this.l || "*" === this.l ? w.aa() : w.T(),
        multiple: () => "+" === this.l || "*" === this.l ? Di(c, d => {
          const e = w.m(d);
          d = bc(a, 0, d, e);
          return C(this.s, d, b);
        }) : w.T(),
        m: () => Di(c, d => {
          const e = w.m(d);
          d = bc(a, 0, d, e);
          return C(this.s, d, b);
        })
      });
    }
  };
  function Fi(a, b) {
    return null !== a && null !== b && v(a.type, 53) && v(b.type, 53) ? md(a.value, b.value) : !1;
  }
  function Gi(a) {
    let b = a.next(0);
    if (b.done) return w.empty();
    let c = null,
      d = null;
    return w.create({
      next(e) {
        if (b.done) return p;
        c || (c = b.value.value);
        let f;
        do if (f = c.next(e), f.done) {
          b = a.next(0);
          if (b.done) return f;
          c = b.value.value;
        } while (f.done || Fi(f.value, d));
        d = f.value;
        return f;
      }
    });
  }
  function Hi(a, b) {
    const c = [];
    (function () {
      for (var f = b.next(0); !f.done;) {
        const h = f.value.value;
        f = {
          current: h.next(0),
          next: k => h.next(k)
        };
        f.current.done || c.push(f);
        f = b.next(0);
      }
    })();
    let d = null,
      e = !1;
    return w.create({
      [Symbol.iterator]() {
        return this;
      },
      next: () => {
        e || (e = !0, c.every(h => v(h.current.value.type, 53)) && c.sort((h, k) => sd(a, h.current.value, k.current.value)));
        let f;
        do {
          if (!c.length) return p;
          const h = c.shift();
          f = h.current;
          h.current = h.next(0);
          if (!v(f.value.type, 53)) return f;
          if (!h.current.done) {
            let k = 0,
              l = c.length - 1,
              n = 0;
            for (; k <= l;) {
              n = Math.floor((k + l) / 2);
              const t = sd(a, h.current.value, c[n].current.value);
              if (0 === t) {
                k = n;
                break;
              }
              0 < t ? k = n + 1 : l = n - 1;
            }
            c.splice(k, 0, h);
          }
        } while (Fi(f.value, d));
        d = f.value;
        return f;
      }
    });
  }
  var Ii = class extends D {
    constructor(a, b) {
      super(a.reduce((c, d) => 0 < uf(c, d.o) ? c : d.o, new vf({})), a, {
        B: a.every(c => c.B)
      }, !1, b);
      this.l = a;
    }
    h(a, b) {
      if (this.l.every(c => "sorted" === c.ia)) {
        let c = 0;
        return Hi(b.h, {
          next: () => c >= this.l.length ? p : q(C(this.l[c++], a, b))
        }).map(d => {
          if (!v(d.type, 53)) throw Error("XPTY0004: The sequences to union are not of type node()*");
          return d;
        });
      }
      return jc(this.l.map(c => C(c, a, b))).N(c => {
        if (c.some(d => !v(d.type, 53))) throw Error("XPTY0004: The sequences to union are not of type node()*");
        c = td(b.h, c);
        return w.create(c);
      });
    }
  };
  function Ji(a) {
    return a.every(b => null === b || v(b.type, 5) || v(b.type, 4)) || null !== a.map(b => b ? rc(b.type) : null).reduce((b, c) => null === c ? b : c === b ? b : null) ? a : a.every(b => null === b || v(b.type, 1) || v(b.type, 20)) ? a.map(b => b ? jd(b, 1) : null) : a.every(b => null === b || v(b.type, 4) || v(b.type, 6)) ? a.map(b => b ? jd(b, 6) : b) : a.every(b => null === b || v(b.type, 4) || v(b.type, 6) || v(b.type, 3)) ? a.map(b => b ? jd(b, 3) : b) : null;
  }
  function Ki(a) {
    return (a = a.find(b => !!b)) ? rc(a.type) : null;
  }
  var Li = class extends Uh {
    constructor(a, b) {
      super(new vf({}), [b, ...a.map(c => c.ba)], {
        B: !1,
        W: !1,
        R: "unsorted",
        subtree: !1
      }, b);
      this.A = a;
    }
    L(a, b, c, d) {
      if (this.A[1]) throw Error("More than one order spec is not supported for the order by clause.");
      const e = [];
      let f = !1,
        h,
        k,
        l = null;
      const n = this.A[0];
      return w.create({
        next: () => {
          if (!f) {
            for (var t = b.next(0); !t.done;) e.push(t.value), t = b.next(0);
            t = e.map(z => n.ba.h(z, c)).map(z => qc(z, c));
            if (t.find(z => !z.F() && !z.oa())) throw Error("XPTY0004: Order by only accepts empty or singleton sequences");
            h = t.map(z => z.first());
            h = h.map(z => null === z ? z : v(19, z.type) ? jd(z, 1) : z);
            if (Ki(h) && (h = Ji(h), !h)) throw Error("XPTY0004: Could not cast values");
            t = h.length;
            k = h.map((z, y) => y);
            for (let z = 0; z < t; z++) if (z + 1 !== t) for (let y = z; 0 <= y; y--) {
              const G = y,
                N = y + 1;
              if (N === t) continue;
              const U = h[k[G]],
                ca = h[k[N]];
              if (null !== ca || null !== U) {
                if (n.bc) {
                  if (null === U) continue;
                  if (null === ca && null !== U) {
                    [k[G], k[N]] = [k[N], k[G]];
                    continue;
                  }
                  if (isNaN(ca.value) && null !== U && !isNaN(U.value)) {
                    [k[G], k[N]] = [k[N], k[G]];
                    continue;
                  }
                } else {
                  if (null === ca) continue;
                  if (null === U && null !== ca) {
                    [k[G], k[N]] = [k[N], k[G]];
                    continue;
                  }
                  if (isNaN(U.value) && null !== ca && !isNaN(ca.value)) {
                    [k[G], k[N]] = [k[N], k[G]];
                    continue;
                  }
                }
                pi("gtOp", U.type, ca.type)(U, ca, a) && ([k[G], k[N]] = [k[N], k[G]]);
              }
            }
            let u = n.Bb ? 0 : h.length - 1;
            l = d({
              next: () => n.Bb ? u >= h.length ? p : q(e[k[u++]]) : 0 > u ? p : q(e[k[u--]])
            }).value;
            f = !0;
          }
          return l.next(0);
        }
      });
    }
  };
  var Mi = class extends D {
    constructor(a) {
      super(a ? a.o : new vf({}), a ? [a] : [], {
        R: "sorted",
        subtree: !1,
        W: !1,
        B: !1
      });
      this.l = a;
    }
    h(a, b) {
      if (null === a.M) throw lc("context is absent, it needs to be present to use paths.");
      var c = b.h;
      let d = a.M.value;
      for (; 9 !== d.node.nodeType;) if (d = x(c, d), null === d) throw Error("XPDY0050: the root node of the context node is not a document node.");
      c = w.m(rb(d));
      return this.l ? C(this.l, bc(a, 0, c.first(), c), b) : c;
    }
  };
  var Ni = class extends D {
    constructor(a) {
      super(new vf({}), [], {
        R: "sorted"
      }, !1, a);
    }
    h(a) {
      if (null === a.M) throw lc('context is absent, it needs to be present to use the "." operator');
      return w.m(a.M);
    }
  };
  function Oi(a, b) {
    let c = !1,
      d = !1;
    b.forEach(e => {
      v(e.type, 53) ? c = !0 : d = !0;
    });
    if (d && c) throw Error("XPTY0018: The path operator should either return nodes or non-nodes. Mixed sequences are not allowed.");
    return c ? td(a, b) : b;
  }
  var Pi = class extends D {
    constructor(a, b) {
      const c = a.every(e => e.W),
        d = a.every(e => e.subtree);
      super(a.reduce((e, f) => e.add(f.o), new vf({})), a, {
        B: !1,
        W: c,
        R: b ? "sorted" : "unsorted",
        subtree: d
      });
      this.l = a;
      this.s = b;
    }
    h(a, b) {
      let c = !0;
      return this.l.reduce((d, e, f) => {
        const h = null === d ? kd(a) : dc(a, d);
        d = {
          next: l => {
            l = h.next(l);
            if (l.done) return p;
            if (null !== l.value.M && !v(l.value.M.type, 53) && 0 < f) throw Error("XPTY0019: The result of E1 in a path expression E1/E2 should not evaluate to a sequence of nodes.");
            return q(C(e, l.value, b));
          }
        };
        let k;
        if (this.s) switch (e.ia) {
          case "reverse-sorted":
            const l = d;
            d = {
              next: n => {
                n = l.next(n);
                return n.done ? n : q(n.value.N(t => w.create(t.reverse())));
              }
            };
          case "sorted":
            if (e.subtree && c) {
              k = Gi(d);
              break;
            }
            k = Hi(b.h, d);
            break;
          case "unsorted":
            return Gi(d).N(n => w.create(Oi(b.h, n)));
        } else k = Gi(d);
        c = c && e.W;
        return k;
      }, null);
    }
    D() {
      return this.l[0].D();
    }
  };
  var Qi = class extends D {
    constructor(a, b) {
      super(a.o.add(b.o), [a, b], {
        B: a.B && b.B,
        W: a.W,
        R: a.ia,
        subtree: a.subtree
      });
      this.s = a;
      this.l = b;
    }
    h(a, b) {
      const c = C(this.s, a, b);
      if (this.l.B) {
        const k = C(this.l, a, b);
        if (k.F()) return k;
        const l = k.first();
        if (v(l.type, 2)) {
          let n = l.value;
          if (!Number.isInteger(n)) return w.empty();
          const t = c.value;
          let u = !1;
          return w.create({
            next: () => {
              if (!u) {
                for (let z = t.next(0); !z.done; z = t.next(0)) if (1 === n--) return u = !0, z;
                u = !0;
              }
              return p;
            }
          });
        }
        return k.fa() ? c : w.empty();
      }
      const d = c.value;
      let e = null,
        f = 0,
        h = null;
      return w.create({
        next: k => {
          let l = !1;
          for (; !e || !e.done;) {
            e || (e = d.next(l ? 0 : k), l = !0);
            if (e.done) break;
            h ||= C(this.l, bc(a, f, e.value, c), b);
            var n = h.first();
            n = null === n ? !1 : v(n.type, 2) ? n.value === f + 1 : h.fa();
            h = null;
            const t = e.value;
            e = null;
            f++;
            if (n) return q(t);
          }
          return e;
        }
      });
    }
    D() {
      return this.s.D();
    }
  };
  function Ri(a, b, c) {
    c = [c];
    if (v(a.type, 62)) {
      if ("*" === b) c.push(...a.h.map(d => d()));else if (v(b.type, 5)) {
        const d = b.value;
        if (a.h.length < d || 0 >= d) throw Error("FOAY0001: Array index out of bounds");
        c.push(a.h[d - 1]());
      } else throw Error("XPTY0004: The key specifier is not an integer.");
    } else if (v(a.type, 61)) "*" === b ? c.push(...a.h.map(d => d.value())) : (a = a.h.find(d => sb(d.key, b))) && c.push(a.value());else throw Error("XPTY0004: The provided context item is not a map or an array.");
    return jc(c);
  }
  function Si(a, b, c, d, e) {
    if ("*" === b) return Ri(a, b, c);
    b = C(b, d, e);
    b = Ra(b)().N(f => f.reduce((h, k) => Ri(a, k, h), new Ba()));
    return jc([c, b]);
  }
  var Ti = class extends D {
    constructor(a, b) {
      super(a.o, [a].concat("*" === b ? [] : [b]), {
        B: a.B,
        R: a.ia,
        subtree: a.subtree
      });
      this.l = a;
      this.s = b;
    }
    h(a, b) {
      return C(this.l, a, b).N(c => c.reduce((d, e) => Si(e, this.s, d, a, b), new Ba()));
    }
    D() {
      return this.l.D();
    }
  };
  var Ui = class extends D {
    constructor(a, b) {
      super(new vf({
        external: 1
      }), "*" === a ? [] : [a], {
        B: !1
      }, !1, b);
      this.l = a;
    }
    h(a, b) {
      return Si(a.M, this.l, new Ba(), a, b);
    }
  };
  var Vi = class extends D {
    constructor(a, b, c, d) {
      const e = b.map(f => f.fb);
      b = b.map(f => f.name);
      super(e.reduce((f, h) => f.add(h.o), c.o), e.concat(c), {
        B: !1
      }, !1, d);
      this.s = a;
      this.A = b;
      this.L = e;
      this.P = c;
      this.l = null;
    }
    h(a, b) {
      let c = a;
      const d = this.l.map((k, l) => {
        const n = C(this.L[l], c, b).O();
        c = hc(a, {
          [k]: () => w.create(n)
        });
        return n;
      });
      if (d.some(k => 0 === k.length)) return "every" === this.s ? w.aa() : w.T();
      const e = Array(d.length).fill(0);
      e[0] = -1;
      for (var f = !0; f;) {
        f = !1;
        for (let k = 0, l = e.length; k < l; ++k) {
          var h = d[k];
          if (++e[k] > h.length - 1) e[k] = 0;else {
            f = Object.create(null);
            for (h = 0; h < e.length; h++) {
              const n = d[h][e[h]];
              f[this.l[h]] = () => w.m(n);
            }
            f = hc(a, f);
            f = C(this.P, f, b);
            if (f.fa() && "some" === this.s) return w.aa();
            if (!f.fa() && "every" === this.s) return w.T();
            f = !0;
            break;
          }
        }
      }
      return "every" === this.s ? w.aa() : w.T();
    }
    v(a) {
      this.l = [];
      for (let c = 0, d = this.A.length; c < d; ++c) {
        this.L[c].v(a);
        Dg(a);
        var b = this.A[c];
        const e = b.prefix ? a.$(b.prefix) : null;
        b = Hg(a, e, b.localName);
        this.l[c] = b;
      }
      this.P.v(a);
      for (let c = 0, d = this.A.length; c < d; ++c) Jg(a);
    }
  };
  var Wi = class extends D {
    constructor(a) {
      super(a, [], {
        B: !1
      });
    }
    h(a) {
      return this.l(a.M) ? w.aa() : w.T();
    }
  };
  var Xi = class extends Wi {
    constructor(a) {
      super(new vf({
        nodeType: 1
      }));
      this.s = a;
    }
    l(a) {
      if (!v(a.type, 53)) return !1;
      a = a.value.node.nodeType;
      return 3 === this.s && 4 === a ? !0 : this.s === a;
    }
    D() {
      return `type-${this.s}`;
    }
  };
  var Yi = class extends Wi {
    constructor(a, b = {
      kind: null
    }) {
      const c = a.prefix,
        d = a.namespaceURI;
      a = a.localName;
      const e = {};
      "*" !== a && (e.nodeName = 1);
      e.nodeType = 1;
      super(new vf(e));
      this.s = a;
      this.L = d;
      this.A = c;
      this.P = b.kind;
    }
    l(a) {
      const b = v(a.type, 54),
        c = v(a.type, 47);
      if (!b && !c) return !1;
      a = a.value;
      return null !== this.P && (1 === this.P && !b || 2 === this.P && !c) ? !1 : null === this.A && "" !== this.L && "*" === this.s ? !0 : "*" === this.A ? "*" === this.s ? !0 : this.s === a.node.localName : "*" !== this.s && this.s !== a.node.localName ? !1 : (a.node.namespaceURI || null) === (("" === this.A ? b ? this.L : null : this.L) || null);
    }
    D() {
      return "*" === this.s ? null === this.P ? "type-1-or-type-2" : `type-${this.P}` : `name-${this.s}`;
    }
    v(a) {
      if (null === this.L && "*" !== this.A && (this.L = a.$(this.A || "") || null, !this.L && this.A)) throw Error(`XPST0081: The prefix ${this.A} could not be resolved.`);
    }
  };
  var Zi = class extends Wi {
    constructor(a) {
      super(new vf({
        nodeName: 1
      }));
      this.s = a;
    }
    l(a) {
      return v(a.type, 57) && a.value.node.target === this.s;
    }
    D() {
      return "type-7";
    }
  };
  var $i = class extends Wi {
    constructor(a) {
      super(new vf({}));
      this.s = a;
    }
    l(a) {
      return v(a.type, Ia(this.s.prefix ? this.s.prefix + ":" + this.s.localName : this.s.localName));
    }
  };
  var aj = class extends D {
    constructor(a, b, c) {
      super(new vf({}), [], {
        B: !1,
        R: "unsorted"
      });
      this.A = c;
      this.s = b;
      this.L = a;
      this.l = null;
    }
    h(a, b) {
      if (!a.ra[this.l]) {
        if (this.P) return this.P(a, b);
        throw Error("XQDY0054: The variable " + this.A + " is declared but not in scope.");
      }
      return a.ra[this.l]();
    }
    v(a) {
      null === this.s && this.L && (this.s = a.$(this.L));
      this.l = a.eb(this.s || "", this.A);
      if (!this.l) throw Error("XPST0008, The variable " + this.A + " is not in scope.");
      if (a = a.Ea[this.l]) this.P = a;
    }
  };
  var bj = class extends Uh {
    constructor(a, b) {
      super(new vf({}), [a, b], {
        B: !1,
        W: !1,
        R: "unsorted",
        subtree: !1
      }, b);
      this.A = a;
    }
    L(a, b, c, d) {
      let e = null,
        f = null;
      return d({
        next: () => {
          for (;;) {
            if (!f) {
              var h = b.next(0);
              if (h.done) return p;
              e = h.value;
              f = C(this.A, e, c);
            }
            h = f.fa();
            const k = e;
            f = e = null;
            if (h) return q(k);
          }
        }
      });
    }
  };
  var cj = class {
    constructor(a) {
      this.type = a;
    }
  };
  var dj = class extends cj {
    constructor(a) {
      super("delete");
      this.target = a;
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1)
      };
    }
  };
  var ej = class extends cj {
    constructor(a, b, c) {
      super(c);
      this.target = a;
      this.content = b;
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1),
        content: this.content.map(b => ag(b, a, !0))
      };
    }
  };
  var fj = class extends ej {
    constructor(a, b) {
      super(a, b, "insertAfter");
    }
  };
  var gj = class extends cj {
    constructor(a, b) {
      super("insertAttributes");
      this.target = a;
      this.content = b;
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1),
        content: this.content.map(b => ag(b, a, !0))
      };
    }
  };
  var hj = class extends ej {
    constructor(a, b) {
      super(a, b, "insertBefore");
    }
  };
  var ij = class extends ej {
    constructor(a, b) {
      super(a, b, "insertIntoAsFirst");
    }
  };
  var jj = class extends ej {
    constructor(a, b) {
      super(a, b, "insertIntoAsLast");
    }
  };
  var kj = class extends ej {
    constructor(a, b) {
      super(a, b, "insertInto");
    }
  };
  var lj = class extends cj {
    constructor(a, b) {
      super("rename");
      this.target = a;
      this.o = b.za ? b : new Sa(b.prefix, b.namespaceURI, b.localName);
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1),
        newName: {
          prefix: this.o.prefix,
          namespaceURI: this.o.namespaceURI,
          localName: this.o.localName
        }
      };
    }
  };
  var mj = class extends cj {
    constructor(a, b) {
      super("replaceElementContent");
      this.target = a;
      this.text = b;
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1),
        text: this.text ? ag(this.text, a, !0) : null
      };
    }
  };
  var nj = class extends cj {
    constructor(a, b) {
      super("replaceNode");
      this.target = a;
      this.o = b;
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1),
        replacement: this.o.map(b => ag(b, a, !0))
      };
    }
  };
  var oj = class extends cj {
    constructor(a, b) {
      super("replaceValue");
      this.target = a;
      this.o = b;
    }
    h(a) {
      return {
        type: this.type,
        target: ag(this.target, a, !1),
        ["string-value"]: this.o
      };
    }
  };
  var pj = (a, b) => new nj(a, b);
  var qj = class extends of {
    constructor(a) {
      super(new vf({}), [a], {
        B: !1,
        R: "unsorted"
      });
      this.l = a;
    }
    s(a, b) {
      const c = nf(this.l)(a, b),
        d = b.h;
      let e, f;
      return {
        next: () => {
          if (!e) {
            const h = c.next(0);
            if (h.value.J.some(k => !v(k.type, 53))) throw Error("XUTY0007: The target of a delete expression must be a sequence of zero or more nodes.");
            e = h.value.J;
            f = h.value.da;
          }
          e = e.filter(h => x(d, h.value));
          return q({
            da: mf(e.map(h => new dj(h.value)), f),
            J: []
          });
        }
      };
    }
  };
  function rj(a, b, c, d, e, f) {
    const h = b.h;
    a.reduce(function t(l, n) {
      if (v(n.type, 62)) return n.h.forEach(u => u().O().forEach(z => t(l, z))), l;
      l.push(n);
      return l;
    }, []).forEach((l, n, t) => {
      if (v(l.type, 47)) {
        if (e) throw f(l.value, h);
        c.push(l.value.node);
      } else if (v(l.type, 46) || v(l.type, 53) && 3 === l.value.node.nodeType) {
        const u = v(l.type, 46) ? jd(pc(l, b).first(), 1).value : ib(h, l.value);
        0 !== n && v(t[n - 1].type, 46) && v(l.type, 46) ? (d.push({
          data: " " + u,
          Ra: !0,
          nodeType: 3
        }), e = !0) : u && (d.push({
          data: "" + u,
          Ra: !0,
          nodeType: 3
        }), e = !0);
      } else if (v(l.type, 55)) {
        const u = [];
        hb(h, l.value).forEach(z => u.push(rb(z)));
        e = rj(u, b, c, d, e, f);
      } else if (v(l.type, 53)) d.push(l.value.node), e = !0;else {
        if (v(l.type, 60)) throw nc(l.type);
        throw Error(`Atomizing ${l.type} is not implemented.`);
      }
    });
    return e;
  }
  function sj(a, b, c) {
    const d = [],
      e = [];
    let f = !1;
    a.forEach(h => {
      f = rj(h, b, d, e, f, c);
    });
    return {
      attributes: d,
      Xa: e
    };
  }
  function tj(a, b, c, d, e) {
    const f = [];
    switch (a) {
      case 4:
        d.length && f.push(new gj(b, d));
        e.length && f.push(new ij(b, e));
        break;
      case 5:
        d.length && f.push(new gj(b, d));
        e.length && f.push(new jj(b, e));
        break;
      case 3:
        d.length && f.push(new gj(b, d));
        e.length && f.push(new kj(b, e));
        break;
      case 2:
        d.length && f.push(new gj(c, d));
        e.length && f.push(new hj(b, e));
        break;
      case 1:
        d.length && f.push(new gj(c, d)), e.length && f.push(new fj(b, e));
    }
    return f;
  }
  var uj = class extends of {
    constructor(a, b, c) {
      super(new vf({}), [a, c], {
        B: !1,
        R: "unsorted"
      });
      this.L = a;
      this.l = b;
      this.A = c;
    }
    s(a, b) {
      const c = nf(this.L)(a, b),
        d = nf(this.A)(a, b),
        e = b.h;
      let f, h, k, l, n, t;
      return {
        next: () => {
          if (!f) {
            var u = c.next(0);
            const z = sj([u.value.J], b, Pe);
            f = z.attributes.map(y => ({
              node: y,
              G: null
            }));
            h = z.Xa.map(y => ({
              node: y,
              G: null
            }));
            k = u.value.da;
          }
          if (!l) {
            u = d.next(0);
            if (0 === u.value.J.length) throw Ye();
            if (3 <= this.l) {
              if (1 !== u.value.J.length) throw Qe();
              if (!v(u.value.J[0].type, 54) && !v(u.value.J[0].type, 55)) throw Qe();
            } else {
              if (1 !== u.value.J.length) throw Re();
              if (!(v(u.value.J[0].type, 54) || v(u.value.J[0].type, 56) || v(u.value.J[0].type, 58) || v(u.value.J[0].type, 57))) throw Re();
              t = x(e, u.value.J[0].value, null);
              if (null === t) throw Error(`XUDY0029: The target ${u.value.J[0].value.outerHTML} for inserting a node before or after must have a parent.`);
            }
            l = u.value.J[0];
            n = u.value.da;
          }
          if (f.length) {
            if (3 <= this.l) {
              if (!v(l.type, 54)) throw Error("XUTY0022: An insert expression specifies the insertion of an attribute node into a document node.");
            } else if (1 !== t.node.nodeType) throw Error("XUDY0030: An insert expression specifies the insertion of an attribute node before or after a child of a document node.");
            f.reduce((z, y) => {
              const G = y.node.prefix || "";
              var N = y.node.prefix || "";
              const U = y.node.namespaceURI,
                ca = N ? l.value.node.lookupNamespaceURI(N) : null;
              if (ca && ca !== U) throw We(U);
              if ((N = z[N]) && U !== N) throw Xe(U);
              z[G] = y.node.namespaceURI;
              return z;
            }, {});
          }
          return q({
            J: [],
            da: mf(tj(this.l, l.value, t ? t : null, f, h), k, n)
          });
        }
      };
    }
  };
  const vj = () => mc("Casting not supported from given type to a single xs:string or xs:untypedAtomic or any of its derived types."),
    wj = /([A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])/,
    xj = new RegExp(`${wj.source}${new RegExp(`(${wj.source}|[-.0-9\xB7\u0300-\u036F\u203F\u2040])`).source}*`, "g"),
    yj = a => (a = a.match(xj)) ? 1 === a.length : !1;
  function zj(a, b) {
    return qc(b, a).X({
      m: c => {
        c = c.first();
        if (v(c.type, 1) || v(c.type, 19)) {
          if (!yj(c.value)) throw Error(`XQDY0041: The value "${c.value}" of a name expressions cannot be converted to a NCName.`);
          return w.m(c);
        }
        throw vj();
      },
      default: () => {
        throw vj();
      }
    }).value;
  }
  function Aj(a, b, c) {
    return qc(c, b).X({
      m: d => {
        d = d.first();
        if (v(d.type, 23)) return w.m(d);
        if (v(d.type, 1) || v(d.type, 19)) {
          let e, f;
          d = d.value.split(":");
          1 === d.length ? d = d[0] : (e = d[0], f = a.$(e), d = d[1]);
          if (!yj(d) || e && !yj(e)) throw yg(e ? `${e}:${d}` : d);
          if (e && !f) throw yg(`${e}:${d}`);
          return w.m({
            type: 23,
            value: new Sa(e, f, d)
          });
        }
        throw vj();
      },
      default: () => {
        throw vj();
      }
    }).value;
  }
  var Nj = class extends of {
    constructor(a, b) {
      super(new vf({}), [a, b], {
        B: !1,
        R: "unsorted"
      });
      this.A = a;
      this.L = b;
      this.l = void 0;
    }
    s(a, b) {
      const c = nf(this.A)(a, b),
        d = nf(this.L)(a, b);
      return {
        next: () => {
          const e = c.next(0);
          var f = e.value.J;
          if (0 === f.length) throw Ye();
          if (1 !== f.length) throw Te();
          if (!v(f[0].type, 54) && !v(f[0].type, 47) && !v(f[0].type, 57)) throw Te();
          f = f[0];
          const h = d.next(0);
          a: {
            var k = this.l;
            var l = w.create(h.value.J);
            switch (f.type) {
              case 54:
                k = Aj(k, b, l).next(0).value.value;
                if ((l = f.value.node.lookupNamespaceURI(k.prefix)) && l !== k.namespaceURI) throw We(k.namespaceURI);
                break a;
              case 47:
                k = Aj(k, b, l).next(0).value.value;
                if (k.namespaceURI && (l = f.value.node.lookupNamespaceURI(k.prefix)) && l !== k.namespaceURI) throw We(k.namespaceURI);
                break a;
              case 57:
                k = zj(b, l).next(0).value.value;
                k = new Sa("", null, k);
                break a;
            }
            k = void 0;
          }
          return q({
            J: [],
            da: mf([new lj(f.value, k)], e.value.da, h.value.da)
          });
        }
      };
    }
    v(a) {
      this.l = Ff(a);
      super.v(a);
    }
  };
  function Oj(a, b, c) {
    let d, e, f;
    return {
      next: () => {
        if (!d) {
          var h = c.next(0),
            k = sj([h.value.J], a, Xe);
          d = {
            attributes: k.attributes.map(l => ({
              node: l,
              G: null
            })),
            Xa: k.Xa.map(l => ({
              node: l,
              G: null
            }))
          };
          e = h.value.da;
        }
        k = b.next(0);
        if (0 === k.value.J.length) throw Ye();
        if (1 !== k.value.J.length) throw Se();
        if (!(v(k.value.J[0].type, 54) || v(k.value.J[0].type, 47) || v(k.value.J[0].type, 56) || v(k.value.J[0].type, 58) || v(k.value.J[0].type, 57))) throw Se();
        f = x(a.h, k.value.J[0].value, null);
        if (null === f) throw Error(`XUDY0009: The target ${k.value.J[0].value.outerHTML} for replacing a node must have a parent.`);
        h = k.value.J[0];
        k = k.value.da;
        if (v(h.type, 47)) {
          if (d.Xa.length) throw Error("XUTY0011: When replacing an attribute the new value must be zero or more attribute nodes.");
          d.attributes.reduce((l, n) => {
            const t = n.node.prefix || "";
            n = n.node.namespaceURI;
            var u = f.node.lookupNamespaceURI(t);
            if (u && u !== n) throw We(n);
            if ((u = l[t]) && n !== u) throw Xe(n);
            l[t] = n;
            return l;
          }, {});
        } else if (d.attributes.length) throw Error("XUTY0010: When replacing an an element, text, comment, or processing instruction node the new value must be a single node.");
        return q({
          J: [],
          da: mf([pj(h.value, [].concat(d.attributes, d.Xa))], e, k)
        });
      }
    };
  }
  function Pj(a, b, c) {
    let d,
      e,
      f,
      h,
      k = !1;
    return {
      next: () => {
        if (k) return p;
        if (!f) {
          var l = c.next(0);
          const n = qc(w.create(l.value.J), a).map(t => jd(t, 1)).O().map(t => t.value).join(" ");
          f = 0 === n.length ? null : {
            node: a.Ja.createTextNode(n),
            G: null
          };
          h = l.value.da;
        }
        if (!d) {
          l = b.next(0);
          if (0 === l.value.J.length) throw Ye();
          if (1 !== l.value.J.length) throw Se();
          if (!(v(l.value.J[0].type, 54) || v(l.value.J[0].type, 47) || v(l.value.J[0].type, 56) || v(l.value.J[0].type, 58) || v(l.value.J[0].type, 57))) throw Se();
          d = l.value.J[0];
          e = l.value.da;
        }
        if (v(d.type, 54)) return k = !0, q({
          J: [],
          da: mf([new mj(d.value, f)], h, e)
        });
        if (v(d.type, 47) || v(d.type, 56) || v(d.type, 58) || v(d.type, 57)) {
          l = f ? ib(a.h, f) : "";
          if (v(d.type, 58) && (l.includes("--") || l.endsWith("-"))) throw Error(`XQDY0072: The content "${l}" for a comment node contains two adjacent hyphens or ends with a hyphen.`);
          if (v(d.type, 57) && l.includes("?>")) throw Error(`XQDY0026: The content "${l}" for a processing instruction node contains "?>".`);
          k = !0;
          return q({
            J: [],
            da: mf([new oj(d.value, l)], h, e)
          });
        }
      }
    };
  }
  var Qj = class extends of {
    constructor(a, b, c) {
      super(new vf({}), [b, c], {
        B: !1,
        R: "unsorted"
      });
      this.L = a;
      this.l = b;
      this.A = c;
    }
    s(a, b) {
      const c = nf(this.l)(a, b);
      a = nf(this.A)(a, b);
      return this.L ? Pj(b, c, a) : Oj(b, c, a);
    }
  };
  function Rj(a) {
    switch (a.type) {
      case "delete":
        return new dj({
          node: a.target,
          G: null
        });
      case "insertAfter":
        return new fj({
          node: a.target,
          G: null
        }, a.content.map(b => ({
          node: b,
          G: null
        })));
      case "insertBefore":
        return new hj({
          node: a.target,
          G: null
        }, a.content.map(b => ({
          node: b,
          G: null
        })));
      case "insertInto":
        return new kj({
          node: a.target,
          G: null
        }, a.content.map(b => ({
          node: b,
          G: null
        })));
      case "insertIntoAsFirst":
        return new ij({
          node: a.target,
          G: null
        }, a.content.map(b => ({
          node: b,
          G: null
        })));
      case "insertIntoAsLast":
        return new jj({
          node: a.target,
          G: null
        }, a.content.map(b => ({
          node: b,
          G: null
        })));
      case "insertAttributes":
        return new gj({
          node: a.target,
          G: null
        }, a.content.map(b => ({
          node: b,
          G: null
        })));
      case "rename":
        return new lj({
          node: a.target,
          G: null
        }, a.newName);
      case "replaceNode":
        return new nj({
          node: a.target,
          G: null
        }, a.replacement.map(b => ({
          node: b,
          G: null
        })));
      case "replaceValue":
        return new oj({
          node: a.target,
          G: null
        }, a["string-value"]);
      case "replaceElementContent":
        return new mj({
          node: a.target,
          G: null
        }, a.text ? {
          node: a.text,
          G: null
        } : null);
      default:
        throw Error(`Unexpected type "${a.type}" when parsing a transferable pending update.`);
    }
  }
  function Sj(a, b, c) {
    if (b.find(e => md(e, a))) return !0;
    const d = x(c, a);
    return d ? Sj(d, b, c) : !1;
  }
  var Tj = class extends of {
    constructor(a, b, c) {
      super(new vf({}), a.reduce((d, e) => {
        d.push(e.fb);
        return d;
      }, [b, c]), {
        B: !1,
        R: "unsorted"
      });
      this.l = a;
      this.L = b;
      this.A = c;
      this.I = null;
    }
    h(a, b) {
      a = this.s(a, b);
      return pf(a, () => {});
    }
    s(a, b) {
      const c = b.h,
        d = b.Ja,
        e = b.Ma,
        f = [];
      let h, k, l;
      const n = [],
        t = [];
      return {
        next: () => {
          if (n.length !== this.l.length) for (var u = n.length; u < this.l.length; u++) {
            const y = this.l[u];
            var z = f[u];
            z || (f[u] = z = nf(y.fb)(a, b));
            z = z.next(0);
            if (1 !== z.value.J.length || !v(z.value.J[0].type, 53)) throw Error("XUTY0013: The source expression of a copy modify expression must return a single node.");
            const G = rb(Xf(z.value.J[0].value, b));
            n.push(G.value);
            t.push(z.value.da);
            a = hc(a, {
              [y.fc]: () => w.m(G)
            });
          }
          l || (h ||= nf(this.L)(a, b), l = h.next(0).value.da);
          l.forEach(y => {
            if (y.target && !Sj(y.target, n, c)) throw Error(`XUDY0014: The target ${y.target.node.outerHTML} must be a node created by the copy clause.`);
            if ("put" === y.type) throw Error("XUDY0037: The modify expression of a copy modify expression can not contain a fn:put.");
          });
          u = l.map(y => {
            y = y.h(b);
            return Rj(y);
          });
          lf(u, c, d, e);
          k ||= nf(this.A)(a, b);
          u = k.next(0);
          return q({
            J: u.value.J,
            da: mf(u.value.da, ...t)
          });
        }
      };
    }
    v(a) {
      Dg(a);
      this.l.forEach(b => b.fc = Hg(a, b.Jb.namespaceURI, b.Jb.localName));
      super.v(a);
      Jg(a);
      this.I = this.l.some(b => b.fb.I) || this.A.I;
    }
  };
  function Uj(a, b) {
    return {
      node: {
        nodeType: 2,
        Ra: !0,
        nodeName: a.za(),
        namespaceURI: a.namespaceURI,
        prefix: a.prefix,
        localName: a.localName,
        name: a.za(),
        value: b
      },
      G: null
    };
  }
  var Vj = class extends D {
    constructor(a, b) {
      let c = b.nb || [];
      c = c.concat(a.Na || []);
      super(new vf({}), c, {
        B: !1,
        R: "unsorted"
      });
      a.Na ? this.s = a.Na : this.name = new Sa(a.prefix, a.namespaceURI, a.localName);
      this.l = b;
      this.A = void 0;
    }
    h(a, b) {
      let c,
        d,
        e,
        f = !1;
      return w.create({
        next: () => {
          if (f) return p;
          if (!d) {
            if (this.s) {
              if (!c) {
                var h = this.s.h(a, b);
                c = Aj(this.A, b, h);
              }
              d = c.next(0).value.value;
            } else d = this.name;
            if (d) {
              if ("xmlns" === d.prefix) throw sg(d);
              if ("" === d.prefix && "xmlns" === d.localName) throw sg(d);
              if ("http://www.w3.org/2000/xmlns/" === d.namespaceURI) throw sg(d);
              if ("xml" === d.prefix && "http://www.w3.org/XML/1998/namespace" !== d.namespaceURI) throw sg(d);
              if ("" !== d.prefix && "xml" !== d.prefix && "http://www.w3.org/XML/1998/namespace" === d.namespaceURI) throw sg(d);
            }
          }
          if (this.l.nb) return h = this.l.nb, e || (e = jc(h.map(k => qc(k.h(a, b), b).N(l => w.m(g(l.map(n => n.value).join(" "), 1))))).N(k => w.m(rb(Uj(d, k.map(l => l.value).join(""))))).value), e.next(0);
          f = !0;
          return q(rb(Uj(d, this.l.value)));
        }
      });
    }
    v(a) {
      this.A = Ff(a);
      if (this.name && this.name.prefix && !this.name.namespaceURI) {
        const b = a.$(this.name.prefix);
        if (void 0 === b && this.name.prefix) throw oc(this.name.prefix);
        this.name.namespaceURI = b || null;
      }
      super.v(a);
    }
  };
  var Wj = class extends D {
    constructor(a) {
      super(a ? a.o : new vf({}), a ? [a] : [], {
        B: !1,
        R: "unsorted"
      });
      this.l = a;
    }
    h(a, b) {
      const c = {
          data: "",
          Ra: !0,
          nodeType: 8
        },
        d = {
          node: c,
          G: null
        };
      if (!this.l) return w.m(rb(d));
      a = C(this.l, a, b);
      return qc(a, b).N(e => {
        e = e.map(f => jd(f, 1).value).join(" ");
        if (-1 !== e.indexOf("--\x3e")) throw Error('XQDY0072: The contents of the data of a comment may not include "--\x3e"');
        c.data = e;
        return w.m(rb(d));
      });
    }
  };
  var Xj = class extends D {
    constructor(a, b, c, d) {
      super(new vf({}), d.concat(b).concat(a.Na || []), {
        B: !1,
        R: "unsorted"
      });
      a.Na ? this.s = a.Na : this.l = new Sa(a.prefix, a.namespaceURI, a.localName);
      this.P = c.reduce((e, f) => {
        if (f.prefix in e) throw Error(`XQST0071: The namespace declaration with the prefix ${f.prefix} has already been declared on the constructed element.`);
        e[f.prefix || ""] = f.uri;
        return e;
      }, {});
      this.L = b;
      this.ma = d;
      this.A = void 0;
    }
    h(a, b) {
      let c = !1,
        d,
        e,
        f = !1,
        h,
        k,
        l,
        n = !1;
      return w.create({
        next: () => {
          if (n) return p;
          c || (d ||= jc(this.L.map(G => C(G, a, b))), e = d.O(), c = !0);
          if (!f) {
            h ||= this.ma.map(G => C(G, a, b));
            var t = [];
            for (var u = 0; u < h.length; u++) {
              var z = h[u].O();
              t.push(z);
            }
            k = t;
            f = !0;
          }
          this.s && (l || (t = this.s.h(a, b), l = Aj(this.A, b, t)), this.l = l.next(0).value.value);
          if ("xmlns" === this.l.prefix || "http://www.w3.org/2000/xmlns/" === this.l.namespaceURI || "xml" === this.l.prefix && "http://www.w3.org/XML/1998/namespace" !== this.l.namespaceURI || this.l.prefix && "xml" !== this.l.prefix && "http://www.w3.org/XML/1998/namespace" === this.l.namespaceURI) throw Error(`XQDY0096: The node name "${this.l.za()}" is invalid for a computed element constructor.`);
          const y = {
            nodeType: 1,
            Ra: !0,
            attributes: [],
            childNodes: [],
            nodeName: this.l.za(),
            namespaceURI: this.l.namespaceURI,
            prefix: this.l.prefix,
            localName: this.l.localName
          };
          t = {
            node: y,
            G: null
          };
          e.forEach(G => {
            y.attributes.push(G.value.node);
          });
          u = sj(k, b, rg);
          u.attributes.forEach(G => {
            if (y.attributes.find(N => N.namespaceURI === G.namespaceURI && N.localName === G.localName)) throw Error(`XQDY0025: The attribute ${G.name} does not have an unique name in the constructed element.`);
            y.attributes.push(G);
          });
          u.Xa.forEach(G => {
            y.childNodes.push(G);
          });
          for (u = 0; u < y.childNodes.length; u++) {
            z = y.childNodes[u];
            if (!cb(z) || 3 !== z.nodeType) continue;
            const G = y.childNodes[u - 1];
            G && cb(G) && 3 === G.nodeType && (G.data += z.data, y.childNodes.splice(u, 1), u--);
          }
          n = !0;
          return q(rb(t));
        }
      });
    }
    v(a) {
      Dg(a);
      Object.keys(this.P).forEach(b => Gg(a, b, this.P[b]));
      this.Fa.forEach(b => b.v(a));
      this.L.reduce((b, c) => {
        if (c.name) {
          c = `Q{${null === c.name.namespaceURI ? a.$(c.name.prefix) : c.name.namespaceURI}}${c.name.localName}`;
          if (b.includes(c)) throw Error(`XQST0040: The attribute ${c} does not have an unique name in the constructed element.`);
          b.push(c);
        }
        return b;
      }, []);
      if (this.l && null === this.l.namespaceURI) {
        const b = a.$(this.l.prefix);
        if (void 0 === b && this.l.prefix) throw oc(this.l.prefix);
        this.l.namespaceURI = b;
      }
      this.A = Ff(a);
      Jg(a);
    }
  };
  function Yj(a) {
    if (/^xml$/i.test(a)) throw Error(`XQDY0064: The target of a created PI may not be "${a}"`);
  }
  function Zj(a, b) {
    return {
      node: {
        data: b,
        Ra: !0,
        nodeName: a,
        nodeType: 7,
        target: a
      },
      G: null
    };
  }
  var ak = class extends D {
    constructor(a, b) {
      const c = a.xb ? [a.xb].concat(b) : [b];
      super(c.reduce((d, e) => d.add(e.o), new vf({})), c, {
        B: !1,
        R: "unsorted"
      });
      this.l = a;
      this.s = b;
    }
    h(a, b) {
      const c = C(this.s, a, b);
      return qc(c, b).N(d => {
        const e = d.map(h => jd(h, 1).value).join(" ");
        if (-1 !== e.indexOf("?>")) throw Error('XQDY0026: The contents of the data of a processing instruction may not include "?>"');
        if (null !== this.l.Fb) return d = this.l.Fb, Yj(d), w.m(rb(Zj(d, e)));
        d = C(this.l.xb, a, b);
        const f = zj(b, d);
        return w.create({
          next: () => {
            var h = f.next(0);
            if (h.done) return h;
            h = h.value.value;
            Yj(h);
            return q(rb(Zj(h, e)));
          }
        });
      });
    }
  };
  var bk = class extends D {
    constructor(a) {
      super(a ? a.o : new vf({}), a ? [a] : [], {
        B: !1,
        R: "unsorted"
      });
      this.l = a;
    }
    h(a, b) {
      if (!this.l) return w.empty();
      a = C(this.l, a, b);
      return qc(a, b).N(c => {
        if (0 === c.length) return w.empty();
        c = {
          node: {
            data: c.map(d => jd(d, 1).value).join(" "),
            Ra: !0,
            nodeType: 3
          },
          G: null
        };
        return w.m(rb(c));
      });
    }
  };
  var ck = class extends rf {
    constructor(a, b, c, d) {
      super(new vf({}), [a, ...b.map(e => e.pb), c].concat(...b.map(e => e.Ib.map(f => f.Hb))), {
        B: !1,
        W: !1,
        R: "unsorted",
        subtree: !1
      }, d);
      this.L = a;
      this.l = b.length;
      this.P = b.map(e => e.Ib);
    }
    A(a, b, c) {
      return c[0](a).N(d => {
        for (let e = 0; e < this.l; e++) if (this.P[e].some(f => {
          switch (f.dc) {
            case "?":
              if (1 < d.length) return !1;
              break;
            case "*":
              break;
            case "+":
              if (1 > d.length) return !1;
              break;
            default:
              if (1 !== d.length) return !1;
          }
          const h = w.create(d);
          return d.every((k, l) => {
            k = bc(a, l, k, h);
            return C(f.Hb, k, b).fa();
          });
        })) return c[e + 1](a);
        return c[this.l + 1](a);
      });
    }
    v(a) {
      super.v(a);
      if (this.L.I) throw Oe();
    }
  };
  var dk = class extends rf {
    constructor(a, b, c, d) {
      super(new vf({}), [a, c, ...b.map(e => e.pb)].concat(...b.map(e => e.Gb.map(f => f))), {
        B: !1,
        W: !1,
        R: "unsorted",
        subtree: !1
      }, d);
      this.L = a;
      this.l = b.length;
      this.P = b.map(e => e.Gb);
    }
    A(a, b, c) {
      const d = fi(c[0](a), b),
        [, e, ...f] = c;
      return d.X({
        multiple: () => {
          throw Error("XPTY0004: The operand for a switch expression should result in zero or one item");
        },
        default: () => {
          const h = d.first(),
            k = !h;
          for (let n = 0; n < this.l; n++) {
            var l = this.P[n].map(t => C(t, a, b));
            for (const t of l) if (l = fi(t, b), l.F()) {
              if (k) return f[n](a);
            } else {
              if (!l.oa()) throw Error("XPTY0004: The operand for a switch case should result in zero or one item");
              if (!k && (l = l.first(), He(a, b, null, h, l).next(0).value)) return f[n](a);
            }
          }
          return e(a);
        }
      });
    }
    v(a) {
      super.v(a);
      if (this.L.I) throw Oe();
    }
  };
  var ek = {
      Z: !1,
      sa: !1
    },
    fk = {
      Z: !0,
      sa: !1
    },
    gk = {
      Z: !0,
      sa: !0
    };
  function P(a) {
    return a.Z ? a.sa ? gk : fk : ek;
  }
  function Q(a, b) {
    switch (a[0]) {
      case "andOp":
        var c = I(a, "type");
        return new di(hk("andOp", a, P(b)), c);
      case "orOp":
        return c = I(a, "type"), new ei(hk("orOp", a, P(b)), c);
      case "unaryPlusOp":
        return c = F(F(a, "operand"), "*"), a = I(a, "type"), new ci("+", Q(c, b), a);
      case "unaryMinusOp":
        return c = F(F(a, "operand"), "*"), a = I(a, "type"), new ci("-", Q(c, b), a);
      case "addOp":
      case "subtractOp":
      case "multiplyOp":
      case "divOp":
      case "idivOp":
      case "modOp":
        var d = a[0],
          e = Q(J(a, ["firstOperand", "*"]), P(b));
        b = Q(J(a, ["secondOperand", "*"]), P(b));
        const f = I(a, "type"),
          h = I(J(a, ["firstOperand", "*"]), "type"),
          k = I(J(a, ["secondOperand", "*"]), "type");
        h && k && I(a, "type") && (c = Sg(d, h.type, k.type));
        return new Wg(d, e, b, f, c);
      case "sequenceExpr":
        return ik(a, b);
      case "unionOp":
        return c = I(a, "type"), new Ii([Q(J(a, ["firstOperand", "*"]), P(b)), Q(J(a, ["secondOperand", "*"]), P(b))], c);
      case "exceptOp":
      case "intersectOp":
        return c = I(a, "type"), new yi(a[0], Q(J(a, ["firstOperand", "*"]), P(b)), Q(J(a, ["secondOperand", "*"]), P(b)), c);
      case "stringConcatenateOp":
        return jk(a, b);
      case "rangeSequenceExpr":
        return kk(a, b);
      case "equalOp":
      case "notEqualOp":
      case "lessThanOrEqualOp":
      case "lessThanOp":
      case "greaterThanOrEqualOp":
      case "greaterThanOp":
        return lk("generalCompare", a, b);
      case "eqOp":
      case "neOp":
      case "ltOp":
      case "leOp":
      case "gtOp":
      case "geOp":
        return lk("valueCompare", a, b);
      case "isOp":
      case "nodeBeforeOp":
      case "nodeAfterOp":
        return lk("nodeCompare", a, b);
      case "pathExpr":
        return mk(a, b);
      case "contextItemExpr":
        return new Ni(I(a, "type"));
      case "functionCallExpr":
        return nk(a, b);
      case "inlineFunctionExpr":
        return ok(a, b);
      case "arrowExpr":
        return pk(a, b);
      case "dynamicFunctionInvocationExpr":
        return qk(a, b);
      case "namedFunctionRef":
        return b = F(a, "functionName"), c = I(a, "type"), a = H(J(a, ["integerConstantExpr", "value"])), new ai(Kg(b), parseInt(a, 10), c);
      case "integerConstantExpr":
        return new Zh(H(F(a, "value")), {
          type: 5,
          g: 3
        });
      case "stringConstantExpr":
        return new Zh(H(F(a, "value")), {
          type: 1,
          g: 3
        });
      case "decimalConstantExpr":
        return new Zh(H(F(a, "value")), {
          type: 4,
          g: 3
        });
      case "doubleConstantExpr":
        return new Zh(H(F(a, "value")), {
          type: 3,
          g: 3
        });
      case "varRef":
        const {
          prefix: l,
          namespaceURI: n,
          localName: t
        } = Kg(F(a, "name"));
        return new aj(l, n, t);
      case "flworExpr":
        return rk(a, b);
      case "quantifiedExpr":
        return sk(a, b);
      case "ifThenElseExpr":
        return c = I(a, "type"), d = F(a, "ifClause") || K(a, "x:stackTrace")[0], e = F(a, "thenClause") || K(a, "x:stackTrace")[1], a = F(a, "elseClause") || K(a, "x:stackTrace")[2], new Qh(Q(d, P(b)), Q(e, b), Q(a, b), c);
      case "instanceOfExpr":
        return c = Q(J(a, ["argExpr", "*"]), b), d = J(a, ["sequenceType", "*"]), e = J(a, ["sequenceType", "occurrenceIndicator"]), a = I(a, "type"), new Ei(c, Q(d, P(b)), e ? H(e) : "", a);
      case "castExpr":
        return b = Q(F(F(a, "argExpr"), "*"), P(b)), c = F(a, "singleType"), a = Kg(F(c, "atomicType")), c = null !== F(c, "optional"), new Ci(b, a, c);
      case "castableExpr":
        return b = Q(F(F(a, "argExpr"), "*"), P(b)), c = F(a, "singleType"), a = Kg(F(c, "atomicType")), c = null !== F(c, "optional"), new Bi(b, a, c);
      case "simpleMapExpr":
        return tk(a, b);
      case "mapConstructor":
        return uk(a, b);
      case "arrayConstructor":
        return vk(a, b);
      case "unaryLookup":
        return c = I(a, "type"), new Ui(wk(a, b), c);
      case "typeswitchExpr":
        return xk(a, b);
      case "switchExpr":
        return yk(a, b);
      case "elementConstructor":
        return zk(a, b);
      case "attributeConstructor":
        return Ak(a, b);
      case "computedAttributeConstructor":
        return (c = F(a, "tagName")) ? c = Kg(c) : (c = F(a, "tagNameExpr"), c = {
          Na: Q(F(c, "*"), P(b))
        }), b = Q(F(F(a, "valueExpr"), "*"), P(b)), new Vj(c, {
          nb: [b]
        });
      case "computedCommentConstructor":
        if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
        b = (a = F(a, "argExpr")) ? Q(F(a, "*"), P(b)) : null;
        return new Wj(b);
      case "computedTextConstructor":
        if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
        b = (a = F(a, "argExpr")) ? Q(F(a, "*"), P(b)) : null;
        return new bk(b);
      case "computedElementConstructor":
        return Bk(a, b);
      case "computedPIConstructor":
        if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
        c = F(a, "piTargetExpr");
        d = F(a, "piTarget");
        e = F(a, "piValueExpr");
        a = I(a, "type");
        return new ak({
          xb: c ? Q(F(c, "*"), P(b)) : null,
          Fb: d ? H(d) : null
        }, e ? Q(F(e, "*"), P(b)) : new zi([], a));
      case "CDataSection":
        return new Zh(H(a), {
          type: 1,
          g: 3
        });
      case "deleteExpr":
        return b = Q(J(a, ["targetExpr", "*"]), b), new qj(b);
      case "insertExpr":
        c = Q(J(a, ["sourceExpr", "*"]), b);
        e = K(a, "*")[1];
        switch (e[0]) {
          case "insertAfter":
            d = 1;
            break;
          case "insertBefore":
            d = 2;
            break;
          case "insertInto":
            d = (d = F(e, "*")) ? "insertAsFirst" === d[0] ? 4 : 5 : 3;
        }
        b = Q(J(a, ["targetExpr", "*"]), b);
        return new uj(c, d, b);
      case "renameExpr":
        return c = Q(J(a, ["targetExpr", "*"]), b), b = Q(J(a, ["newNameExpr", "*"]), b), new Nj(c, b);
      case "replaceExpr":
        return c = !!F(a, "replaceValue"), d = Q(J(a, ["targetExpr", "*"]), b), b = Q(J(a, ["replacementExpr", "*"]), b), new Qj(c, d, b);
      case "transformExpr":
        return Ck(a, b);
      case "x:stackTrace":
        c = a;
        for (a = c[2]; "x:stackTrace" === a[0];) c = a, a = a[2];
        c = c[1];
        return new Sh(c, a[0], Q(a, b), c.Wa);
      case "ifClause":
      case "thenClause":
      case "elseClause":
        return Q(F(a, "*"), b);
      default:
        return Dk(a);
    }
  }
  function Dk(a) {
    switch (a[0]) {
      case "nameTest":
        return new Yi(Kg(a));
      case "piTest":
        return (a = F(a, "piTarget")) ? new Zi(H(a)) : new Xi(7);
      case "commentTest":
        return new Xi(8);
      case "textTest":
        return new Xi(3);
      case "documentTest":
        return new Xi(9);
      case "attributeTest":
        var b = (a = F(a, "attributeName")) && F(a, "star");
        return !a || b ? new Xi(2) : new Yi(Kg(F(a, "QName")), {
          kind: 2
        });
      case "elementTest":
        return b = (a = F(a, "elementName")) && F(a, "star"), !a || b ? new Xi(1) : new Yi(Kg(F(a, "QName")), {
          kind: 1
        });
      case "anyKindTest":
        return new $i({
          prefix: "",
          namespaceURI: null,
          localName: "node()"
        });
      case "anyMapTest":
        return new $i({
          prefix: "",
          namespaceURI: null,
          localName: "map(*)"
        });
      case "anyArrayTest":
        return new $i({
          prefix: "",
          namespaceURI: null,
          localName: "array(*)"
        });
      case "Wildcard":
        return F(a, "star") ? (b = F(a, "uri")) ? a = new Yi({
          localName: "*",
          namespaceURI: H(b),
          prefix: ""
        }) : (b = F(a, "NCName"), a = "star" === F(a, "*")[0] ? new Yi({
          localName: H(b),
          namespaceURI: null,
          prefix: "*"
        }) : new Yi({
          localName: "*",
          namespaceURI: null,
          prefix: H(b)
        })) : a = new Yi({
          localName: "*",
          namespaceURI: null,
          prefix: "*"
        }), a;
      case "atomicType":
        return new $i(Kg(a));
      case "anyItemType":
        return new $i({
          prefix: "",
          namespaceURI: null,
          localName: "item()"
        });
      default:
        throw Error("No selector counterpart for: " + a[0] + ".");
    }
  }
  function vk(a, b) {
    const c = I(a, "type");
    a = F(a, "*");
    const d = K(a, "arrayElem").map(e => Q(F(e, "*"), P(b)));
    switch (a[0]) {
      case "curlyArray":
        return new sh(d, c);
      case "squareArray":
        return new th(d, c);
      default:
        throw Error("Unrecognized arrayType: " + a[0]);
    }
  }
  function uk(a, b) {
    const c = I(a, "type");
    return new $h(K(a, "mapConstructorEntry").map(d => ({
      key: Q(J(d, ["mapKeyExpr", "*"]), P(b)),
      value: Q(J(d, ["mapValueExpr", "*"]), P(b))
    })), c);
  }
  function hk(a, b, c) {
    function d(f) {
      const h = F(F(f, "firstOperand"), "*");
      f = F(F(f, "secondOperand"), "*");
      h[0] === a ? d(h) : e.push(Q(h, c));
      f[0] === a ? d(f) : e.push(Q(f, c));
    }
    const e = [];
    d(b);
    return e;
  }
  function wk(a, b) {
    a = F(a, "*");
    switch (a[0]) {
      case "NCName":
        return new Zh(H(a), {
          type: 1,
          g: 3
        });
      case "star":
        return "*";
      default:
        return Q(a, P(b));
    }
  }
  function lk(a, b, c) {
    var d = J(b, ["firstOperand", "*"]);
    const e = J(b, ["secondOperand", "*"]);
    d = Q(d, P(c));
    c = Q(e, P(c));
    switch (a) {
      case "valueCompare":
        return new qi(b[0], d, c);
      case "nodeCompare":
        return new wi(b[0], d, c);
      case "generalCompare":
        return new ti(b[0], d, c);
    }
  }
  function Ek(a, b, c) {
    a = K(a, "*");
    return new Li(a.filter(d => "stable" !== d[0]).map(d => {
      var e = F(d, "orderModifier"),
        f = e ? F(e, "orderingKind") : null;
      e = e ? F(e, "emptyOrderingMode") : null;
      f = f ? "ascending" === H(f) : !0;
      e = e ? "empty least" === H(e) : !0;
      return {
        ba: Q(J(d, ["orderByExpr", "*"]), b),
        Bb: f,
        bc: e
      };
    }), c);
  }
  function rk(a, b) {
    var c = K(a, "*");
    a = F(c[c.length - 1], "*");
    c = c.slice(0, -1);
    if (1 < c.length && !b.Z) throw Error("XPST0003: Use of XQuery FLWOR expressions in XPath is no allowed");
    return c.reduceRight((d, e) => {
      switch (e[0]) {
        case "forClause":
          e = K(e, "*");
          for (var f = e.length - 1; 0 <= f; --f) {
            var h = e[f],
              k = J(h, ["forExpr", "*"]);
            const l = F(h, "positionalVariableBinding");
            d = new Wh(Kg(J(h, ["typedVariableBinding", "varName"])), Q(k, P(b)), l ? Kg(l) : null, d);
          }
          return d;
        case "letClause":
          e = K(e, "*");
          for (f = e.length - 1; 0 <= f; --f) h = e[f], k = J(h, ["letExpr", "*"]), d = new Yh(Kg(J(h, ["typedVariableBinding", "varName"])), Q(k, P(b)), d);
          return d;
        case "whereClause":
          e = K(e, "*");
          for (f = e.length - 1; 0 <= f; --f) d = new bj(Q(e[f], b), d);
          return d;
        case "windowClause":
          throw Error(`Not implemented: ${e[0]} is not implemented yet.`);
        case "groupByClause":
          throw Error(`Not implemented: ${e[0]} is not implemented yet.`);
        case "orderByClause":
          return Ek(e, b, d);
        case "countClause":
          throw Error(`Not implemented: ${e[0]} is not implemented yet.`);
        default:
          throw Error(`Not implemented: ${e[0]} is not supported in a flwor expression`);
      }
    }, Q(a, b));
  }
  function nk(a, b) {
    const c = F(a, "functionName"),
      d = K(F(a, "arguments"), "*");
    a = I(a, "type");
    return new Gf(new ai(Kg(c), d.length, a), d.map(e => "argumentPlaceholder" === e[0] ? null : Q(e, b)), a);
  }
  function pk(a, b) {
    const c = I(a, "type");
    var d = J(a, ["argExpr", "*"]);
    a = K(a, "*").slice(1);
    d = [Q(d, b)];
    for (let f = 0; f < a.length; f++) if ("arguments" !== a[f][0]) {
      if ("arguments" === a[f + 1][0]) {
        var e = K(a[f + 1], "*");
        d = d.concat(e.map(h => "argumentPlaceholder" === h[0] ? null : Q(h, b)));
      }
      e = "EQName" === a[f][0] ? new ai(Kg(a[f]), d.length, c) : Q(a[f], P(b));
      d = [new Gf(e, d, c)];
    }
    return d[0];
  }
  function qk(a, b) {
    const c = J(a, ["functionItem", "*"]),
      d = I(a, "type");
    a = F(a, "arguments");
    let e = [];
    a && (e = K(a, "*").map(f => "argumentPlaceholder" === f[0] ? null : Q(f, b)));
    return new Gf(Q(c, b), e, d);
  }
  function ok(a, b) {
    const c = K(F(a, "paramList"), "*"),
      d = J(a, ["functionBody", "*"]),
      e = I(a, "type");
    return new Xh(c.map(f => ({
      name: Kg(F(f, "varName")),
      type: Lg(f)
    })), Lg(a), d ? Q(d, b) : new zi([], e));
  }
  function mk(a, b) {
    const c = I(a, "type");
    var d = K(a, "stepExpr");
    let e = !1;
    var f = d.map(h => {
      var k = F(h, "xpathAxis");
      let l;
      var n = K(h, "*");
      const t = [];
      let u = null,
        z = !1;
      for (const y of n) switch (y[0]) {
        case "lookup":
          t.push(["lookup", wk(y, b)]);
          break;
        case "predicate":
        case "predicates":
          for (const G of K(y, "*")) {
            n = Q(G, P(b));
            if (!z) {
              const N = n.D();
              null === N ? z = !0 : u = yh(u, N);
            }
            t.push(["predicate", n]);
          }
      }
      if (k) switch (e = !0, h = F(h, "attributeTest anyElementTest piTest documentTest elementTest commentTest namespaceTest anyKindTest textTest anyFunctionTest typedFunctionTest schemaAttributeTest atomicType anyItemType parenthesizedItemType typedMapTest typedArrayTest nameTest Wildcard".split(" ")), h = Dk(h), H(k)) {
        case "ancestor":
          l = new wh(h, {
            Qa: !1
          });
          break;
        case "ancestor-or-self":
          l = new wh(h, {
            Qa: !0
          });
          break;
        case "attribute":
          l = new zh(h, u);
          break;
        case "child":
          l = new Ah(h, u);
          break;
        case "descendant":
          l = new Dh(h, {
            Qa: !1
          });
          break;
        case "descendant-or-self":
          l = new Dh(h, {
            Qa: !0
          });
          break;
        case "parent":
          l = new Kh(h, u);
          break;
        case "following-sibling":
          l = new Jh(h, u);
          break;
        case "preceding-sibling":
          l = new Oh(h, u);
          break;
        case "following":
          l = new Hh(h);
          break;
        case "preceding":
          l = new Mh(h);
          break;
        case "self":
          l = new Ph(h, u);
      } else k = J(h, ["filterExpr", "*"]), l = Q(k, P(b));
      for (const y of t) switch (y[0]) {
        case "lookup":
          l = new Ti(l, y[1]);
          break;
        case "predicate":
          l = new Qi(l, y[1]);
      }
      l.type = c;
      return l;
    });
    a = F(a, "rootExpr");
    d = e || null !== a || 1 < d.length;
    if (!d && 1 === f.length || !a && 1 === f.length && "sorted" === f[0].ia) return f[0];
    if (a && 0 === f.length) return new Mi(null);
    f = new Pi(f, d);
    return a ? new Mi(f) : f;
  }
  function sk(a, b) {
    const c = I(a, "type"),
      d = H(F(a, "quantifier")),
      e = J(a, ["predicateExpr", "*"]);
    a = K(a, "quantifiedExprInClause").map(f => {
      const h = Kg(J(f, ["typedVariableBinding", "varName"]));
      f = J(f, ["sourceExpr", "*"]);
      return {
        name: h,
        fb: Q(f, P(b))
      };
    });
    return new Vi(d, a, Q(e, P(b)), c);
  }
  function ik(a, b) {
    var c = K(a, "*").map(d => Q(d, b));
    if (1 === c.length) return c[0];
    c = I(a, "type");
    return new zi(K(a, "*").map(d => Q(d, b)), c);
  }
  function tk(a, b) {
    const c = I(a, "type");
    return K(a, "*").reduce((d, e) => null === d ? Q(e, P(b)) : new Ai(d, Q(e, P(b)), c), null);
  }
  function jk(a, b) {
    const c = I(a, "type");
    a = [J(a, ["firstOperand", "*"]), J(a, ["secondOperand", "*"])];
    return new Gf(new ai({
      localName: "concat",
      namespaceURI: "http://www.w3.org/2005/xpath-functions",
      prefix: ""
    }, a.length, c), a.map(d => Q(d, P(b))), c);
  }
  function kk(a, b) {
    const c = I(a, "type");
    a = [F(F(a, "startExpr"), "*"), F(F(a, "endExpr"), "*")];
    const d = new ai({
      localName: "to",
      namespaceURI: "http://fontoxpath/operators",
      prefix: ""
    }, a.length, c);
    return new Gf(d, a.map(e => Q(e, P(b))), c);
  }
  function zk(a, b) {
    if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = Kg(F(a, "tagName"));
    var d = F(a, "attributeList");
    const e = d ? K(d, "attributeConstructor").map(f => Q(f, P(b))) : [];
    d = d ? K(d, "namespaceDeclaration").map(f => {
      const h = F(f, "prefix");
      return {
        prefix: h ? H(h) : "",
        uri: H(F(f, "uri"))
      };
    }) : [];
    a = (a = F(a, "elementContent")) ? K(a, "*").map(f => Q(f, P(b))) : [];
    return new Xj(c, e, d, a);
  }
  function Ak(a, b) {
    if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = Kg(F(a, "attributeName"));
    var d = F(a, "attributeValue");
    d = d ? H(d) : null;
    a = (a = F(a, "attributeValueExpr")) ? K(a, "*").map(e => Q(e, P(b))) : null;
    return new Vj(c, {
      value: d,
      nb: a
    });
  }
  function Bk(a, b) {
    var c = F(a, "tagName");
    c ? c = Kg(c) : (c = F(a, "tagNameExpr"), c = {
      Na: Q(F(c, "*"), P(b))
    });
    a = (a = F(a, "contentExpr")) ? K(a, "*").map(d => Q(d, P(b))) : [];
    return new Xj(c, [], [], a);
  }
  function Ck(a, b) {
    const c = K(F(a, "transformCopies"), "transformCopy").map(e => {
        const f = Kg(F(F(e, "varRef"), "name"));
        return {
          fb: Q(F(F(e, "copySource"), "*"), b),
          Jb: new Sa(f.prefix, f.namespaceURI, f.localName)
        };
      }),
      d = Q(F(F(a, "modifyExpr"), "*"), b);
    a = Q(F(F(a, "returnExpr"), "*"), b);
    return new Tj(c, d, a);
  }
  function xk(a, b) {
    if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = I(a, "type"),
      d = Q(F(F(a, "argExpr"), "*"), b),
      e = K(a, "typeswitchExprCaseClause").map(f => {
        const h = 0 === K(f, "sequenceTypeUnion").length ? [F(f, "sequenceType")] : K(F(f, "sequenceTypeUnion"), "sequenceType");
        return {
          pb: Q(J(f, ["resultExpr", "*"]), b),
          Ib: h.map(k => {
            const l = F(k, "occurrenceIndicator");
            return {
              dc: l ? H(l) : "",
              Hb: Q(F(k, "*"), b)
            };
          })
        };
      });
    a = Q(J(a, ["typeswitchExprDefaultClause", "resultExpr", "*"]), b);
    return new ck(d, e, a, c);
  }
  function yk(a, b) {
    if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = I(a, "type"),
      d = Q(F(F(a, "argExpr"), "*"), b),
      e = K(a, "switchExprCaseClause").map(f => {
        const h = K(f, "switchCaseExpr");
        return {
          pb: Q(J(f, ["resultExpr", "*"]), b),
          Gb: h.map(k => Q(F(k, "*"), b))
        };
      });
    a = Q(J(a, ["switchExprDefaultClause", "resultExpr", "*"]), b);
    return new dk(d, e, a, c);
  }
  function Fk(a, b) {
    return Q(a, b);
  }
  const Gk = new Map();
  class Hk {
    constructor(a, b, c, d, e, f) {
      this.v = a;
      this.D = b;
      this.h = c;
      this.kb = d;
      this.o = e;
      this.l = f;
    }
  }
  function Ik(a, b, c, d, e, f, h, k) {
    a = Gk.get(a);
    if (!a) return null;
    b = a[b + (f ? "_DEBUG" : "")];
    return b ? (b = b.find(l => l.o === h && l.v.every(n => c(n.prefix) === n.namespaceURI) && l.D.every(n => void 0 !== d[n.name]) && l.kb.every(n => e[n.prefix] === n.namespaceURI) && l.l.every(n => {
      const t = k(n.cc, n.arity);
      return t && t.namespaceURI === n.Db.namespaceURI && t.localName === n.Db.localName;
    }))) ? {
      ba: b.h,
      hc: !1
    } : null : null;
  }
  function Jk(a, b, c, d, e, f, h) {
    let k = Gk.get(a);
    k || (k = Object.create(null), Gk.set(a, k));
    a = b + (f ? "_DEBUG" : "");
    (b = k[a]) || (b = k[a] = []);
    b.push(new Hk(Object.values(c.h), Object.values(c.o), e, Object.keys(d).map(l => ({
      namespaceURI: d[l],
      prefix: l
    })), h, c.D));
  }
  function Kk(a) {
    var b = new Za();
    if ("http://www.w3.org/2005/XQueryX" !== a.namespaceURI && "http://www.w3.org/2005/XQueryX" !== a.namespaceURI && "http://fontoxml.com/fontoxpath" !== a.namespaceURI && "http://www.w3.org/2007/xquery-update-10" !== a.namespaceURI) throw mc("The XML structure passed as an XQueryX program was not valid XQueryX");
    const c = ["stackTrace" === a.localName ? "x:stackTrace" : a.localName],
      d = b.getAllAttributes(a);
    d && 0 < d.length && c.push(Array.from(d).reduce((e, f) => {
      "comment" !== f.localName && "start" !== f.localName && "end" !== f.localName || "stackTrace" !== a.localName ? "type" === f.localName ? e[f.localName] = Ja(f.value) : e[f.localName] = f.value : e[f.localName] = JSON.parse(f.value);
      return e;
    }, {}));
    b = b.getChildNodes(a);
    for (const e of b) switch (e.nodeType) {
      case 1:
        c.push(Kk(e));
        break;
      case 3:
        c.push(e.data);
    }
    return c;
  }
  const Lk = Object.create(null);
  var Mk = (a, b) => {
      let c = Lk[a];
      c ||= Lk[a] = {
        Ia: [],
        Ta: [],
        pa: null,
        source: b.source
      };
      const d = c.pa || (() => {});
      c.Ia = c.Ia.concat(b.Ia);
      c.Ta = c.Ta.concat(b.Ta);
      c.pa = e => {
        d(e);
        b.pa && b.pa(e);
      };
    },
    Nk = (a, b) => {
      const c = Lk[b];
      if (!c) throw Error(`XQST0051: No modules found with the namespace uri ${b}`);
      c.Ia.forEach(d => {
        d.cb && Fg(a, b, d.localName, d.arity, d);
      });
      c.Ta.forEach(d => {
        Hg(a, b, d.localName);
        Ig(a, b, d.localName, (e, f) => C(d.ba, e, f));
      });
    },
    Ok = () => {
      Object.keys(Lk).forEach(a => {
        a = Lk[a];
        if (a.pa) try {
          a.pa(a);
        } catch (b) {
          a.pa = null, hg(a.source, b);
        }
        a.pa = null;
      });
    };
  function Pk(a) {
    return a.replace(/(\x0D\x0A)|(\x0D(?!\x0A))/g, String.fromCharCode(10));
  }
  var R = prsc;
  function Qk(a, b) {
    return (c, d) => {
      if (b.has(d)) return b.get(d);
      c = a(c, d);
      b.set(d, c);
      return c;
    };
  }
  function S(a, b) {
    return (0, R.delimited)(b, a, b);
  }
  function T(a, b) {
    return a.reverse().reduce((c, d) => (0, R.preceded)(d, c), b);
  }
  function Rk(a, b, c, d) {
    return (0, R.then)((0, R.then)(a, b, (e, f) => [e, f]), c, ([e, f], h) => d(e, f, h));
  }
  function Sk(a, b, c, d, e) {
    return (0, R.then)((0, R.then)((0, R.then)(a, b, (f, h) => [f, h]), c, ([f, h], k) => [f, h, k]), d, ([f, h, k], l) => e(f, h, k, l));
  }
  function Tk(a, b, c, d, e, f) {
    return (0, R.then)((0, R.then)((0, R.then)((0, R.then)(a, b, (h, k) => [h, k]), c, ([h, k], l) => [h, k, l]), d, ([h, k, l], n) => [h, k, l, n]), e, ([h, k, l, n], t) => f(h, k, l, n, t));
  }
  function Uk(a) {
    return (0, R.map)(a, b => [b]);
  }
  function Vk(a, b) {
    return (0, R.map)((0, R.or)(a), () => b);
  }
  function Wk(a) {
    return (b, c) => (b = a.exec(b.substring(c))) && 0 === b.index ? (0, R.okWithValue)(c + b[0].length, b[0]) : (0, R.error)(c, [a.source], !1);
  }
  var Xk = (0, R.or)([(0, R.token)(" "), (0, R.token)("\t"), (0, R.token)("\r"), (0, R.token)("\n")]),
    Yk = (0, R.token)("(:"),
    Zk = (0, R.token)(":)"),
    $k = (0, R.token)("(#"),
    al = (0, R.token)("#)"),
    bl = (0, R.token)("("),
    cl = (0, R.token)(")"),
    dl = (0, R.token)("["),
    el = (0, R.token)("]"),
    fl = (0, R.token)("{"),
    gl = (0, R.token)("}"),
    hl = (0, R.token)("{{"),
    il = (0, R.token)("}}"),
    jl = (0, R.token)("'"),
    kl = (0, R.token)("''"),
    ll = (0, R.token)('"'),
    ml = (0, R.token)('""'),
    nl = (0, R.token)("<![CDATA["),
    ol = (0, R.token)("]]\x3e"),
    pl = (0, R.token)("/>"),
    ql = (0, R.token)("</"),
    rl = (0, R.token)("\x3c!--"),
    sl = (0, R.token)("--\x3e"),
    tl = (0, R.token)("<?"),
    ul = (0, R.token)("?>"),
    vl = (0, R.token)("&#x"),
    wl = (0, R.token)("&#"),
    xl = (0, R.token)(":*"),
    yl = (0, R.token)("*:"),
    zl = (0, R.token)(":="),
    Al = (0, R.token)("&"),
    Bl = (0, R.token)(":"),
    Cl = (0, R.token)(";"),
    Dl = (0, R.token)("*"),
    El = (0, R.token)("@"),
    Fl = (0, R.token)("$"),
    Gl = (0, R.token)("#"),
    Hl = (0, R.token)("%"),
    Il = (0, R.token)("?"),
    Jl = (0, R.token)("="),
    Kl = (0, R.followed)((0, R.token)("!"), (0, R.not)((0, R.peek)(Jl), [])),
    Ll = (0, R.followed)((0, R.token)("|"), (0, R.not)((0, R.peek)((0, R.token)("|")), [])),
    Ml = (0, R.token)("||"),
    Nl = (0, R.token)("!="),
    Ol = (0, R.token)("<"),
    Pl = (0, R.token)("<<"),
    Ql = (0, R.token)("<="),
    Rl = (0, R.token)(">"),
    Sl = (0, R.token)(">>"),
    Tl = (0, R.token)(">="),
    Ul = (0, R.token)(","),
    Vl = (0, R.token)("."),
    Wl = (0, R.token)(".."),
    Xl = (0, R.token)("+"),
    Yl = (0, R.token)("-"),
    Zl = (0, R.token)("/"),
    $l = (0, R.token)("//"),
    am = (0, R.token)("=>"),
    bm = (0, R.token)("e"),
    cm = (0, R.token)("E");
  (0, R.token)("l");
  (0, R.token)("L");
  (0, R.token)("m");
  (0, R.token)("M");
  var dm = (0, R.token)("Q");
  (0, R.token)("x");
  (0, R.token)("X");
  var em = (0, R.token)("as"),
    fm = (0, R.token)("cast"),
    gm = (0, R.token)("castable"),
    hm = (0, R.token)("treat"),
    im = (0, R.token)("instance"),
    jm = (0, R.token)("of"),
    km = (0, R.token)("node"),
    lm = (0, R.token)("nodes"),
    mm = (0, R.token)("delete"),
    nm = (0, R.token)("value"),
    om = (0, R.token)("function"),
    pm = (0, R.token)("map"),
    qm = (0, R.token)("element"),
    rm = (0, R.token)("attribute"),
    sm = (0, R.token)("schema-element"),
    tm = (0, R.token)("intersect"),
    um = (0, R.token)("except"),
    vm = (0, R.token)("union"),
    wm = (0, R.token)("to"),
    xm = (0, R.token)("is"),
    ym = (0, R.token)("or"),
    zm = (0, R.token)("and"),
    Am = (0, R.token)("div"),
    Bm = (0, R.token)("idiv"),
    Cm = (0, R.token)("mod"),
    Dm = (0, R.token)("eq"),
    Em = (0, R.token)("ne"),
    Fm = (0, R.token)("lt"),
    Gm = (0, R.token)("le"),
    Hm = (0, R.token)("gt"),
    Im = (0, R.token)("ge"),
    Jm = (0, R.token)("amp"),
    Km = (0, R.token)("quot"),
    Lm = (0, R.token)("apos"),
    Mm = (0, R.token)("if"),
    Nm = (0, R.token)("then"),
    Om = (0, R.token)("else"),
    Pm = (0, R.token)("allowing"),
    Qm = (0, R.token)("empty"),
    Rm = (0, R.token)("at"),
    Sm = (0, R.token)("in"),
    Tm = (0, R.token)("for"),
    Um = (0, R.token)("let"),
    Vm = (0, R.token)("where"),
    Wm = (0, R.token)("collation"),
    Xm = (0, R.token)("group"),
    Ym = (0, R.token)("by"),
    Zm = (0, R.token)("order"),
    $m = (0, R.token)("stable"),
    an = (0, R.token)("return"),
    bn = (0, R.token)("array"),
    cn = (0, R.token)("document"),
    dn = (0, R.token)("namespace"),
    en = (0, R.token)("text"),
    fn = (0, R.token)("comment"),
    gn = (0, R.token)("processing-instruction"),
    hn = (0, R.token)("lax"),
    jn = (0, R.token)("strict"),
    kn = (0, R.token)("validate"),
    ln = (0, R.token)("type"),
    mn = (0, R.token)("declare"),
    nn = (0, R.token)("default"),
    on = (0, R.token)("boundary-space"),
    pn = (0, R.token)("strip"),
    qn = (0, R.token)("preserve"),
    rn = (0, R.token)("no-preserve"),
    sn = (0, R.token)("inherit"),
    tn = (0, R.token)("no-inherit"),
    un = (0, R.token)("greatest"),
    vn = (0, R.token)("least"),
    wn = (0, R.token)("copy-namespaces"),
    xn = (0, R.token)("decimal-format"),
    yn = (0, R.token)("case"),
    zn = (0, R.token)("typeswitch"),
    An = (0, R.token)("some"),
    Bn = (0, R.token)("every"),
    Cn = (0, R.token)("satisfies"),
    Dn = (0, R.token)("replace"),
    En = (0, R.token)("with"),
    Fn = (0, R.token)("copy"),
    Gn = (0, R.token)("modify"),
    Hn = (0, R.token)("first"),
    In = (0, R.token)("last"),
    Jn = (0, R.token)("before"),
    Kn = (0, R.token)("after"),
    Ln = (0, R.token)("into"),
    Mn = (0, R.token)("insert"),
    Nn = (0, R.token)("rename"),
    On = (0, R.token)("switch"),
    Pn = (0, R.token)("variable"),
    Qn = (0, R.token)("external"),
    Rn = (0, R.token)("updating"),
    Sn = (0, R.token)("import"),
    Tn = (0, R.token)("schema"),
    Un = (0, R.token)("module"),
    Vn = (0, R.token)("base-uri"),
    Wn = (0, R.token)("construction"),
    Xn = (0, R.token)("ordering"),
    Yn = (0, R.token)("ordered"),
    Zn = (0, R.token)("unordered"),
    $n = (0, R.token)("option"),
    ao = (0, R.token)("context"),
    bo = (0, R.token)("item"),
    co = (0, R.token)("xquery"),
    eo = (0, R.token)("version"),
    fo = (0, R.token)("encoding"),
    go = (0, R.token)("document-node"),
    ho = (0, R.token)("namespace-node"),
    io = (0, R.token)("schema-attribute"),
    jo = (0, R.token)("ascending"),
    ko = (0, R.token)("descending"),
    lo = (0, R.token)("empty-sequence"),
    mo = (0, R.token)("child::"),
    no = (0, R.token)("descendant::"),
    oo = (0, R.token)("attribute::"),
    po = (0, R.token)("self::"),
    qo = (0, R.token)("descendant-or-self::"),
    ro = (0, R.token)("following-sibling::"),
    so = (0, R.token)("following::"),
    to = (0, R.token)("parent::"),
    uo = (0, R.token)("ancestor::"),
    vo = (0, R.token)("preceding-sibling::"),
    wo = (0, R.token)("preceding::"),
    xo = (0, R.token)("ancestor-or-self::"),
    yo = (0, R.token)("decimal-separator"),
    zo = (0, R.token)("grouping-separator"),
    Ao = (0, R.token)("infinity"),
    Bo = (0, R.token)("minus-sign"),
    Co = (0, R.token)("NaN"),
    Do = (0, R.token)("per-mille"),
    Eo = (0, R.token)("zero-digit"),
    Fo = (0, R.token)("digit"),
    Go = (0, R.token)("pattern-separator"),
    Ho = (0, R.token)("exponent-separator"),
    Io = (0, R.token)("schema-attribute("),
    Jo = (0, R.token)("document-node("),
    Ko = (0, R.token)("processing-instruction("),
    Lo = (0, R.token)("processing-instruction()"),
    Mo = (0, R.token)("comment()"),
    No = (0, R.token)("text()"),
    Oo = (0, R.token)("namespace-node()"),
    Po = (0, R.token)("node()"),
    Qo = (0, R.token)("item()"),
    Ro = (0, R.token)("empty-sequence()");
  var So = new Map(),
    To = new Map(),
    Uo = (0, R.or)([Wk(/[\t\n\r -\uD7FF\uE000\uFFFD]/), Wk(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)]),
    Vo = (0, R.preceded)((0, R.peek)((0, R.not)((0, R.or)([Yk, Zk]), ['comment contents cannot contain "(:" or ":)"'])), Uo),
    Wo = (0, R.map)((0, R.delimited)(Yk, (0, R.star)((0, R.or)([Vo, function (a, b) {
      return Wo(a, b);
    }])), Zk, !0), a => a.join("")),
    Xo = (0, R.or)([Xk, Wo]),
    Yo = (0, R.map)((0, R.plus)(Xk), a => a.join("")),
    V = Qk((0, R.map)((0, R.star)(Xo), a => a.join("")), So),
    W = Qk((0, R.map)((0, R.plus)(Xo), a => a.join("")), To);
  const Zo = (0, R.or)([Wk(/[A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/), (0, R.then)(Wk(/[\uD800-\uDB7F]/), Wk(/[\uDC00-\uDFFF]/), (a, b) => a + b)]),
    $o = (0, R.or)([Zo, Wk(/[\-\.0-9\xB7\u0300-\u036F\u203F\u2040]/)]);
  var ap = (0, R.then)(Zo, (0, R.star)($o), (a, b) => a + b.join("")),
    bp = (0, R.map)(ap, a => ["prefix", a]);
  const cp = (0, R.or)([Zo, Bl]),
    dp = (0, R.or)([$o, Bl]);
  (0, R.then)(cp, (0, R.star)(dp), (a, b) => a + b.join(""));
  const ep = (0, R.map)(ap, a => [{
      prefix: "",
      URI: null
    }, a]),
    fp = (0, R.then)(ap, (0, R.preceded)(Bl, ap), (a, b) => [{
      prefix: a,
      URI: null
    }, b]);
  var gp = (0, R.or)([fp, ep]),
    hp = (0, R.followed)(T([dm, V, fl], (0, R.map)((0, R.star)(Wk(/[^{}]/)), a => a.join("").replace(/\s+/g, " ").trim())), gl);
  const ip = (0, R.then)(hp, ap, (a, b) => [a, b]);
  var jp = (0, R.or)([(0, R.map)(ip, a => [{
      prefix: null,
      URI: a[0]
    }, a[1]]), gp]),
    kp = (0, R.or)([(0, R.map)(jp, a => ["QName", ...a]), (0, R.map)(Dl, () => ["star"])]),
    lp = (0, R.map)((0, R.preceded)(Fl, jp), a => ["varRef", ["name", ...a]]);
  var mp = (0, R.peek)((0, R.or)([bl, ll, jl, Xo])),
    np = (0, R.map)((0, R.or)([mo, no, oo, po, qo, ro, so]), a => a.substring(0, a.length - 2)),
    op = (0, R.map)((0, R.or)([to, uo, vo, wo, xo]), a => a.substring(0, a.length - 2)),
    pp = Rk(Al, (0, R.or)([Fm, Hm, Jm, Km, Lm]), Cl, (a, b, c) => a + b + c),
    qp = (0, R.or)([Rk(vl, Wk(/[0-9a-fA-F]+/), Cl, (a, b, c) => a + b + c), Rk(wl, Wk(/[0-9]+/), Cl, (a, b, c) => a + b + c)]),
    rp = Vk([ml], '"'),
    sp = Vk([kl], "'"),
    tp = Uk(Vk([Mo], "commentTest")),
    up = Uk(Vk([No], "textTest")),
    vp = Uk(Vk([Oo], "namespaceTest")),
    wp = Uk(Vk([Po], "anyKindTest"));
  const xp = Wk(/[0-9]+/),
    yp = (0, R.then)((0, R.or)([(0, R.then)(Vl, xp, (a, b) => a + b), (0, R.then)(xp, (0, R.optional)((0, R.preceded)(Vl, Wk(/[0-9]*/))), (a, b) => a + (null !== b ? "." + b : ""))]), Rk((0, R.or)([bm, cm]), (0, R.optional)((0, R.or)([Xl, Yl])), xp, (a, b, c) => a + (b ? b : "") + c), (a, b) => ["doubleConstantExpr", ["value", a + b]]),
    zp = (0, R.or)([(0, R.map)((0, R.preceded)(Vl, xp), a => ["decimalConstantExpr", ["value", "." + a]]), (0, R.then)((0, R.followed)(xp, Vl), (0, R.optional)(xp), (a, b) => ["decimalConstantExpr", ["value", a + "." + (null !== b ? b : "")]])]);
  var Ap = (0, R.map)(xp, a => ["integerConstantExpr", ["value", a]]),
    Bp = (0, R.followed)((0, R.or)([yp, zp, Ap]), (0, R.peek)((0, R.not)(Wk(/[a-zA-Z]/), ["no alphabetical characters after numeric literal"]))),
    Cp = (0, R.map)((0, R.followed)(Vl, (0, R.peek)((0, R.not)(Vl, ["context item should not be followed by another ."]))), () => ["contextItemExpr"]),
    Dp = (0, R.or)([bn, rm, fn, go, qm, lo, om, Mm, bo, pm, ho, km, gn, io, sm, On, en, zn]),
    Ep = Uk(Vk([Il], "argumentPlaceholder")),
    Fp = (0, R.or)([Il, Dl, Xl]),
    Gp = (0, R.preceded)((0, R.peek)((0, R.not)(Wk(/[{}<&]/), ["elementContentChar cannot be {, }, <, or &"])), Uo),
    Hp = (0, R.map)((0, R.delimited)(nl, (0, R.star)((0, R.preceded)((0, R.peek)((0, R.not)(ol, ['CDataSection content may not contain "]]\x3e"'])), Uo)), ol, !0), a => ["CDataSection", a.join("")]),
    Ip = (0, R.preceded)((0, R.peek)((0, R.not)(Wk(/["{}<&]/), ['quotAttrValueContentChar cannot be ", {, }, <, or &'])), Uo),
    Jp = (0, R.preceded)((0, R.peek)((0, R.not)(Wk(/['{}<&]/), ["aposAttrValueContentChar cannot be ', {, }, <, or &"])), Uo),
    Kp = (0, R.map)((0, R.star)((0, R.or)([(0, R.preceded)((0, R.peek)((0, R.not)(Yl, [])), Uo), (0, R.map)(T([Yl, (0, R.peek)((0, R.not)(Yl, []))], Uo), a => "-" + a)])), a => a.join("")),
    Lp = (0, R.map)((0, R.delimited)(rl, Kp, sl, !0), a => ["computedCommentConstructor", ["argExpr", ["stringConstantExpr", ["value", a]]]]);
  const Mp = (0, R.filter)(ap, a => "xml" !== a.toLowerCase(), ['A processing instruction target cannot be "xml"']),
    Np = (0, R.map)((0, R.star)((0, R.preceded)((0, R.peek)((0, R.not)(ul, [])), Uo)), a => a.join(""));
  var Op = (0, R.then)((0, R.preceded)(tl, (0, R.cut)(Mp)), (0, R.cut)((0, R.followed)((0, R.optional)((0, R.preceded)(Yo, Np)), ul)), (a, b) => ["computedPIConstructor", ["piTarget", a], ["piValueExpr", ["stringConstantExpr", ["value", b]]]]),
    Pp = (0, R.map)($l, () => ["stepExpr", ["xpathAxis", "descendant-or-self"], ["anyKindTest"]]),
    Qp = (0, R.or)([hn, jn]),
    Rp = (0, R.map)((0, R.star)((0, R.followed)(Uo, (0, R.peek)((0, R.not)(al, ["Pragma contents should not contain '#)'"])))), a => a.join("")),
    Sp = (0, R.map)((0, R.followed)((0, R.or)([Dm, Em, Fm, Gm, Hm, Im]), mp), a => a + "Op"),
    Tp = (0, R.or)([(0, R.followed)(Vk([xm], "isOp"), mp), Vk([Pl], "nodeBeforeOp"), Vk([Sl], "nodeAfterOp")]),
    Up = (0, R.or)([Vk([Jl], "equalOp"), Vk([Nl], "notEqualOp"), Vk([Ql], "lessThanOrEqualOp"), Vk([Ol], "lessThanOp"), Vk([Tl], "greaterThanOrEqualOp"), Vk([Rl], "greaterThanOp")]),
    Vp = (0, R.map)(Rn, () => ["annotation", ["annotationName", "updating"]]);
  const Wp = (0, R.or)([qn, rn]),
    Xp = (0, R.or)([sn, tn]);
  var Yp = (0, R.or)([yo, zo, Ao, Bo, Co, Hl, Do, Eo, Fo, Go, Ho]),
    Zp = (0, R.map)(T([mn, W, on, W], (0, R.or)([qn, pn])), a => ["boundarySpaceDecl", a]),
    $p = (0, R.map)(T([mn, W, Wn, W], (0, R.or)([qn, pn])), a => ["constructionDecl", a]),
    aq = (0, R.map)(T([mn, W, Xn, W], (0, R.or)([Yn, Zn])), a => ["orderingModeDecl", a]),
    bq = (0, R.map)(T([mn, W, nn, W, Zm, W, Qm, W], (0, R.or)([un, vn])), a => ["emptyOrderDecl", a]),
    cq = (0, R.then)(T([mn, W, wn, W], Wp), T([V, Ul, V], Xp), (a, b) => ["copyNamespacesDecl", ["preserveMode", a], ["inheritMode", b]]);
  function dq(a) {
    switch (a[0]) {
      case "constantExpr":
      case "varRef":
      case "contextItemExpr":
      case "functionCallExpr":
      case "sequenceExpr":
      case "elementConstructor":
      case "computedElementConstructor":
      case "computedAttributeConstructor":
      case "computedDocumentConstructor":
      case "computedTextConstructor":
      case "computedCommentConstructor":
      case "computedNamespaceConstructor":
      case "computedPIConstructor":
      case "orderedExpr":
      case "unorderedExpr":
      case "namedFunctionRef":
      case "inlineFunctionExpr":
      case "dynamicFunctionInvocationExpr":
      case "mapConstructor":
      case "arrayConstructor":
      case "stringConstructor":
      case "unaryLookup":
        return a;
    }
    return ["sequenceExpr", a];
  }
  function eq(a) {
    if (!(1 <= a && 55295 >= a || 57344 <= a && 65533 >= a || 65536 <= a && 1114111 >= a)) throw Error("XQST0090: The character reference " + a + " (" + a.toString(16) + ") does not reference a valid codePoint.");
  }
  function fq(a) {
    return a.replace(/(&[^;]+);/g, b => {
      if (/^&#x/.test(b)) return b = parseInt(b.slice(3, -1), 16), eq(b), String.fromCodePoint(b);
      if (/^&#/.test(b)) return b = parseInt(b.slice(2, -1), 10), eq(b), String.fromCodePoint(b);
      switch (b) {
        case "&lt;":
          return "<";
        case "&gt;":
          return ">";
        case "&amp;":
          return "&";
        case "&quot;":
          return String.fromCharCode(34);
        case "&apos;":
          return String.fromCharCode(39);
      }
      throw Error('XPST0003: Unknown character reference: "' + b + '"');
    });
  }
  function gq(a, b, c) {
    if (!a.length) return [];
    let d = [a[0]];
    for (let e = 1; e < a.length; ++e) {
      const f = d[d.length - 1];
      "string" === typeof f && "string" === typeof a[e] ? d[d.length - 1] = f + a[e] : d.push(a[e]);
    }
    if ("string" === typeof d[0] && 0 === d.length) return [];
    d = d.reduce((e, f, h) => {
      if ("string" !== typeof f) e.push(f);else if (c && /^\s*$/.test(f)) {
        const k = d[h + 1];
        k && "CDataSection" === k[0] ? e.push(fq(f)) : (h = d[h - 1]) && "CDataSection" === h[0] && e.push(fq(f));
      } else e.push(fq(f));
      return e;
    }, []);
    if (!d.length) return d;
    if (1 < d.length || b) for (a = 0; a < d.length; a++) "string" === typeof d[a] && (d[a] = ["stringConstantExpr", ["value", d[a]]]);
    return d;
  }
  function hq(a) {
    return a[0].prefix ? a[0].prefix + ":" + a[1] : a[1];
  }
  var iq = (0, R.then)(jp, (0, R.optional)(Il), (a, b) => null !== b ? ["singleType", ["atomicType", ...a], ["optional"]] : ["singleType", ["atomicType", ...a]]),
    jq = (0, R.map)(jp, a => ["atomicType", ...a]);
  const kq = new Map();
  function lq(a) {
    function b(m, r) {
      return r.reduce((B, X) => [X[0], ["firstOperand", B], ["secondOperand", X[1]]], m);
    }
    function c(m, r, B) {
      return (0, R.then)(m, (0, R.star)((0, R.then)(S(r, V), (0, R.cut)(m), (X, ea) => [X, ea])), B);
    }
    function d(m, r, B = "firstOperand", X = "secondOperand") {
      return (0, R.then)(m, (0, R.optional)((0, R.then)(S(r, V), (0, R.cut)(m), (ea, Fa) => [ea, Fa])), (ea, Fa) => null === Fa ? ea : [Fa[0], [B, ea], [X, Fa[1]]]);
    }
    function e(m) {
      return a.mb ? (r, B) => {
        r = m(r, B);
        if (!r.success) return r;
        const X = n.has(B) ? n.get(B) : {
            offset: B,
            line: -1,
            ha: -1
          },
          ea = n.has(r.offset) ? n.get(r.offset) : {
            offset: r.offset,
            line: -1,
            ha: -1
          };
        n.set(B, X);
        n.set(r.offset, ea);
        B = r.value.Wa;
        return (0, R.okWithValue)(r.offset, ["x:stackTrace", Object.assign({
          start: X,
          end: ea
        }, B ? {
          Wa: B
        } : {}), r.value]);
      } : m;
    }
    function f(m, r) {
      return Bj(m, r);
    }
    function h(m, r) {
      return yf(m, r);
    }
    function k(m, r) {
      return e((0, R.or)([zr, Ar, Br, Cr, Dr, Er, Fr, Gr, Hr, Ir, Jr]))(m, r);
    }
    function l(m, r) {
      return c(k, Ul, (B, X) => 0 === X.length ? B : ["sequenceExpr", B, ...X.map(ea => ea[1])])(m, r);
    }
    const n = new Map(),
      t = (0, R.preceded)(dl, (0, R.followed)(S(l, V), el)),
      u = (0, R.map)(a.Za ? (0, R.or)([S((0, R.star)((0, R.or)([pp, qp, rp, Wk(/[^"&]/)])), ll), S((0, R.star)((0, R.or)([pp, qp, sp, Wk(/[^'&]/)])), jl)]) : (0, R.or)([S((0, R.star)((0, R.or)([rp, Wk(/[^"]/)])), ll), S((0, R.star)((0, R.or)([sp, Wk(/[^']/)])), jl)]), m => m.join("")),
      z = (0, R.or)([(0, R.map)(T([qm, V], (0, R.delimited)((0, R.followed)(bl, V), (0, R.then)(kp, T([V, Ul, V], jp), (m, r) => [["elementName", m], ["typeName", ...r]]), (0, R.preceded)(V, cl))), ([m, r]) => ["elementTest", m, r]), (0, R.map)(T([qm, V], (0, R.delimited)(bl, kp, cl)), m => ["elementTest", ["elementName", m]]), (0, R.map)(T([qm, V], (0, R.delimited)(bl, V, cl)), () => ["elementTest"])]),
      y = (0, R.or)([(0, R.map)(jp, m => ["QName", ...m]), (0, R.map)(Dl, () => ["star"])]),
      G = (0, R.or)([(0, R.map)(T([rm, V], (0, R.delimited)((0, R.followed)(bl, V), (0, R.then)(y, T([V, Ul, V], jp), (m, r) => [["attributeName", m], ["typeName", ...r]]), (0, R.preceded)(V, cl))), ([m, r]) => ["attributeTest", m, r]), (0, R.map)(T([rm, V], (0, R.delimited)(bl, y, cl)), m => ["attributeTest", ["attributeName", m]]), (0, R.map)(T([rm, V], (0, R.delimited)(bl, V, cl)), () => ["attributeTest"])]),
      N = (0, R.map)(T([sm, V, bl], (0, R.followed)(jp, cl)), m => ["schemaElementTest", ...m]),
      U = (0, R.map)((0, R.delimited)(Io, S(jp, V), cl), m => ["schemaAttributeTest", ...m]),
      ca = (0, R.map)((0, R.preceded)(Jo, (0, R.followed)(S((0, R.optional)((0, R.or)([z, N])), V), cl)), m => ["documentTest", ...(m ? [m] : [])]),
      Ga = (0, R.or)([(0, R.map)((0, R.preceded)(Ko, (0, R.followed)(S((0, R.or)([ap, u]), V), cl)), m => ["piTest", ["piTarget", m]]), Uk(Vk([Lo], "piTest"))]),
      Gb = (0, R.or)([ca, z, G, N, U, Ga, tp, up, vp, wp]),
      Xb = (0, R.or)([(0, R.map)((0, R.preceded)(yl, ap), m => ["Wildcard", ["star"], ["NCName", m]]), Uk(Vk([Dl], "Wildcard")), (0, R.map)((0, R.followed)(hp, Dl), m => ["Wildcard", ["uri", m], ["star"]]), (0, R.map)((0, R.followed)(ap, xl), m => ["Wildcard", ["NCName", m], ["star"]])]),
      fd = (0, R.or)([Xb, (0, R.map)(jp, m => ["nameTest", ...m])]),
      Yb = (0, R.or)([Gb, fd]),
      Kr = (0, R.then)((0, R.optional)(El), Yb, (m, r) => null !== m || "attributeTest" === r[0] || "schemaAttributeTest" === r[0] ? ["stepExpr", ["xpathAxis", "attribute"], r] : ["stepExpr", ["xpathAxis", "child"], r]),
      Lr = (0, R.or)([(0, R.then)(np, Yb, (m, r) => ["stepExpr", ["xpathAxis", m], r]), Kr]),
      Mr = (0, R.map)(Wl, () => ["stepExpr", ["xpathAxis", "parent"], ["anyKindTest"]]),
      Nr = (0, R.or)([(0, R.then)(op, Yb, (m, r) => ["stepExpr", ["xpathAxis", m], r]), Mr]),
      Or = (0, R.map)((0, R.star)((0, R.preceded)(V, t)), m => 0 < m.length ? ["predicates", ...m] : void 0),
      Pr = (0, R.then)((0, R.or)([Nr, Lr]), Or, (m, r) => void 0 === r ? m : m.concat([r])),
      zf = (0, R.or)([Bp, (0, R.map)(u, m => ["stringConstantExpr", ["value", a.Za ? fq(m) : m]])]),
      Af = (0, R.or)([(0, R.delimited)(bl, S(l, V), cl), (0, R.map)((0, R.delimited)(bl, V, cl), () => ["sequenceExpr"])]),
      Cj = (0, R.or)([k, Ep]),
      de = (0, R.map)((0, R.delimited)(bl, S((0, R.optional)((0, R.then)(Cj, (0, R.star)((0, R.preceded)(S(Ul, V), Cj)), (m, r) => [m, ...r])), V), cl), m => null !== m ? m : []),
      Qr = (0, R.preceded)((0, R.not)(Rk(Dp, V, bl, () => {}), ["cannot use reserved keyword for function names"]), e((0, R.then)(jp, (0, R.preceded)(V, de), (m, r) => {
        r = ["functionCallExpr", ["functionName", ...m], null !== r ? ["arguments", ...r] : ["arguments"]];
        const B = m[0].prefix,
          X = m[0].URI;
        m = m[1];
        r.Wa = B ? `${B}:${m}` : X ? `Q{${X}}${m}` : m;
        return r;
      }))),
      Rr = (0, R.then)(jp, (0, R.preceded)(Gl, Ap), (m, r) => ["namedFunctionRef", ["functionName", ...m], r]),
      Ta = (0, R.delimited)(fl, S((0, R.optional)(l), V), gl),
      Dj = (0, R.map)(Ta, m => m ? m : ["sequenceExpr"]),
      gb = (0, R.or)([(0, R.map)(Ro, () => [["voidSequenceType"]]), (0, R.then)(f, (0, R.optional)((0, R.preceded)(V, Fp)), (m, r) => [m, ...(null !== r ? [["occurrenceIndicator", r]] : [])])]),
      Bf = (0, R.then)(T([Hl, V], jp), (0, R.optional)((0, R.followed)((0, R.then)(T([bl, V], zf), (0, R.star)(T([Ul, V], zf)), (m, r) => m.concat(r)), cl)), (m, r) => ["annotation", ["annotationName", ...m], ...(r ? ["arguments", r] : [])]),
      Sr = (0, R.map)(T([om, V, bl, V, Dl, V], cl), () => ["anyFunctionTest"]),
      Tr = (0, R.then)(T([om, V, bl, V], (0, R.optional)(c(gb, Ul, (m, r) => m.concat.apply(m, r.map(B => B[1]))))), T([V, cl, W, em, W], gb), (m, r) => ["typedFunctionTest", ["paramTypeList", ["sequenceType", ...(m ? m : [])]], ["sequenceType", ...r]]),
      Ur = (0, R.then)((0, R.star)(Bf), (0, R.or)([Sr, Tr]), (m, r) => [r[0], ...m, ...r.slice(1)]),
      Vr = (0, R.map)(T([pm, V, bl, V, Dl, V], cl), () => ["anyMapTest"]),
      Wr = (0, R.then)(T([pm, V, bl, V], jq), T([V, Ul], (0, R.followed)(S(gb, V), cl)), (m, r) => ["typedMapTest", m, ["sequenceType", ...r]]),
      Xr = (0, R.or)([Vr, Wr]),
      Yr = (0, R.map)(T([bn, V, bl, V, Dl, V], cl), () => ["anyArrayTest"]),
      Zr = (0, R.map)(T([bn, V, bl], (0, R.followed)(S(gb, V), cl)), m => ["typedArrayTest", ["sequenceType", ...m]]),
      $r = (0, R.or)([Yr, Zr]),
      as = (0, R.map)((0, R.delimited)(bl, S(f, V), cl), m => ["parenthesizedItemType", m]),
      Bj = (0, R.or)([Gb, Uk(Vk([Qo], "anyItemType")), Ur, Xr, $r, jq, as]),
      Ac = (0, R.map)(T([em, W], gb), m => ["typeDeclaration", ...m]),
      bs = (0, R.then)((0, R.preceded)(Fl, jp), (0, R.optional)((0, R.preceded)(W, Ac)), (m, r) => ["param", ["varName", ...m], ...(r ? [r] : [])]),
      Ej = c(bs, Ul, (m, r) => [m, ...r.map(B => B[1])]),
      cs = Sk((0, R.star)(Bf), T([V, om, V, bl, V], (0, R.optional)(Ej)), T([V, cl, V], (0, R.optional)((0, R.map)(T([em, V], (0, R.followed)(gb, V)), m => ["typeDeclaration", ...m]))), Dj, (m, r, B, X) => ["inlineFunctionExpr", ...m, ["paramList", ...(r ? r : [])], ...(B ? [B] : []), ["functionBody", X]]),
      ds = (0, R.or)([Rr, cs]),
      es = (0, R.map)(k, m => ["mapKeyExpr", m]),
      fs = (0, R.map)(k, m => ["mapValueExpr", m]),
      gs = (0, R.then)(es, (0, R.preceded)(S(Bl, V), fs), (m, r) => ["mapConstructorEntry", m, r]),
      hs = (0, R.preceded)(pm, (0, R.delimited)(S(fl, V), (0, R.map)((0, R.optional)(c(gs, S(Ul, V), (m, r) => [m, ...r.map(B => B[1])])), m => m ? ["mapConstructor", ...m] : ["mapConstructor"]), (0, R.preceded)(V, gl))),
      is = (0, R.map)((0, R.delimited)(dl, S((0, R.optional)(c(k, Ul, (m, r) => [m, ...r.map(B => B[1])].map(B => ["arrayElem", B]))), V), el), m => ["squareArray", ...(null !== m ? m : [])]),
      js = (0, R.map)((0, R.preceded)(bn, (0, R.preceded)(V, Ta)), m => ["curlyArray", ...(null !== m ? [["arrayElem", m]] : [])]),
      ks = (0, R.map)((0, R.or)([is, js]), m => ["arrayConstructor", m]),
      Fj = (0, R.or)([ap, Ap, Af, Dl]),
      ls = (0, R.map)((0, R.preceded)(Il, (0, R.preceded)(V, Fj)), m => "*" === m ? ["unaryLookup", ["star"]] : "string" === typeof m ? ["unaryLookup", ["NCName", m]] : ["unaryLookup", m]),
      Cf = (0, R.or)([pp, qp, Vk([hl], "{"), Vk([il], "}"), (0, R.map)(Ta, m => m || ["sequenceExpr"])]),
      ms = (0, R.or)([Hp, function (m, r) {
        return Gj(m, r);
      }, Cf, Gp]),
      ns = (0, R.or)([(0, R.map)(Ip, m => m.replace(/[\x20\x0D\x0A\x09]/g, " ")), Cf]),
      os = (0, R.or)([(0, R.map)(Jp, m => m.replace(/[\x20\x0D\x0A\x09]/g, " ")), Cf]),
      ps = (0, R.map)((0, R.or)([S((0, R.star)((0, R.or)([rp, ns])), ll), S((0, R.star)((0, R.or)([sp, os])), jl)]), m => gq(m, !1, !1)),
      qs = (0, R.then)(gp, (0, R.preceded)(S(Jl, (0, R.optional)(Yo)), ps), (m, r) => {
        if ("" === m[0].prefix && "xmlns" === m[1]) {
          if (r.length && "string" !== typeof r[0]) throw Error("XQST0022: A namespace declaration may not contain enclosed expressions");
          return ["namespaceDeclaration", r.length ? ["uri", r[0]] : ["uri"]];
        }
        if ("xmlns" === m[0].prefix) {
          if (r.length && "string" !== typeof r[0]) throw Error("XQST0022: The namespace declaration for 'xmlns:" + m[1] + "' may not contain enclosed expressions");
          return ["namespaceDeclaration", ["prefix", m[1]], r.length ? ["uri", r[0]] : ["uri"]];
        }
        return ["attributeConstructor", ["attributeName"].concat(m), 0 === r.length ? ["attributeValue"] : 1 === r.length && "string" === typeof r[0] ? ["attributeValue", r[0]] : ["attributeValueExpr"].concat(r)];
      }),
      rs = (0, R.map)((0, R.star)((0, R.preceded)(Yo, (0, R.optional)(qs))), m => m.filter(Boolean)),
      ss = Rk((0, R.preceded)(Ol, gp), rs, (0, R.or)([(0, R.map)(pl, () => null), (0, R.then)((0, R.preceded)(Rl, (0, R.star)(ms)), T([V, ql], (0, R.followed)(gp, (0, R.then)((0, R.optional)(Yo), Rl, () => null))), (m, r) => [gq(m, !0, !0), r])]), (m, r, B) => {
        var X = B;
        if (B && B.length) {
          X = hq(m);
          const ea = hq(B[1]);
          if (X !== ea) throw Error('XQST0118: The start and the end tag of an element constructor must be equal. "' + X + '" does not match "' + ea + '"');
          X = B[0];
        }
        return ["elementConstructor", ["tagName", ...m], ...(r.length ? [["attributeList", ...r]] : []), ...(X && X.length ? [["elementContent", ...X]] : [])];
      }),
      Gj = (0, R.or)([ss, Lp, Op]),
      ts = (0, R.map)(T([cn, V], Ta), m => ["computedDocumentConstructor", ...(m ? [["argExpr", m]] : [])]),
      us = (0, R.map)(Ta, m => m ? [["contentExpr", m]] : []),
      vs = (0, R.then)(T([qm, V], (0, R.or)([(0, R.map)(jp, m => ["tagName", ...m]), (0, R.map)((0, R.delimited)(fl, S(l, V), gl), m => ["tagNameExpr", m])])), (0, R.preceded)(V, us), (m, r) => ["computedElementConstructor", m, ...r]),
      ws = (0, R.then)((0, R.preceded)(rm, (0, R.or)([(0, R.map)(T([mp, V], jp), m => ["tagName", ...m]), (0, R.map)((0, R.preceded)(V, (0, R.delimited)(fl, S(l, V), gl)), m => ["tagNameExpr", m])])), (0, R.preceded)(V, Ta), (m, r) => ["computedAttributeConstructor", m, ["valueExpr", r ? r : ["sequenceExpr"]]]),
      xs = (0, R.map)(Ta, m => m ? [["prefixExpr", m]] : []),
      ys = (0, R.map)(Ta, m => m ? [["URIExpr", m]] : []),
      zs = (0, R.then)(T([dn, V], (0, R.or)([bp, xs])), (0, R.preceded)(V, ys), (m, r) => ["computedNamespaceConstructor", ...m, ...r]),
      As = (0, R.map)(T([en, V], Ta), m => ["computedTextConstructor", ...(m ? [["argExpr", m]] : [])]),
      Bs = (0, R.map)(T([fn, V], Ta), m => ["computedCommentConstructor", ...(m ? [["argExpr", m]] : [])]),
      Cs = T([gn, V], (0, R.then)((0, R.or)([(0, R.map)(ap, m => ["piTarget", m]), (0, R.map)((0, R.delimited)(fl, S(l, V), gl), m => ["piTargetExpr", m])]), (0, R.preceded)(V, Ta), (m, r) => ["computedPIConstructor", m, ...(r ? [["piValueExpr", r]] : [])])),
      Ds = (0, R.or)([ts, vs, ws, zs, As, Bs, Cs]),
      Es = (0, R.or)([Gj, Ds]),
      Hj = (0, R.or)([zf, lp, Af, Cp, Qr, Es, ds, hs, ks, ls]),
      Ij = (0, R.map)(T([Il, V], Fj), m => "*" === m ? ["lookup", ["star"]] : "string" === typeof m ? ["lookup", ["NCName", m]] : ["lookup", m]),
      Fs = (0, R.then)((0, R.map)(Hj, m => dq(m)), (0, R.star)((0, R.or)([(0, R.map)((0, R.preceded)(V, t), m => ["predicate", m]), (0, R.map)((0, R.preceded)(V, de), m => ["argumentList", m]), (0, R.preceded)(V, Ij)])), (m, r) => {
        function B() {
          Jj && 1 === Fa.length ? Bc.push(["predicate", Fa[0]]) : 0 !== Fa.length && Bc.push(["predicates", ...Fa]);
          Fa.length = 0;
        }
        function X(Zb) {
          B();
          0 !== Bc.length ? ("sequenceExpr" === ea[0][0] && 2 < ea[0].length && (ea = [["sequenceExpr", ...ea]]), ea = [["filterExpr", ...ea], ...Bc], Bc.length = 0) : Zb && (ea = [["filterExpr", ...ea]]);
        }
        let ea = [m];
        const Fa = [],
          Bc = [];
        let Jj = !1;
        for (const Zb of r) switch (Zb[0]) {
          case "predicate":
            Fa.push(Zb[1]);
            break;
          case "lookup":
            Jj = !0;
            B();
            Bc.push(Zb);
            break;
          case "argumentList":
            X(!1);
            1 < ea.length && (ea = [["sequenceExpr", ["pathExpr", ["stepExpr", ...ea]]]]);
            ea = [["dynamicFunctionInvocationExpr", ["functionItem", ...ea], ...(Zb[1].length ? [["arguments", ...Zb[1]]] : [])]];
            break;
          default:
            throw Error("unreachable");
        }
        X(!0);
        return ea;
      }),
      Cc = (0, R.or)([(0, R.map)(Fs, m => ["stepExpr", ...m]), Pr]),
      Gs = (0, R.followed)(Hj, (0, R.peek)((0, R.not)((0, R.preceded)(V, (0, R.or)([t, de, Ij])), ["primary expression not followed by predicate, argumentList, or lookup"]))),
      Hs = (0, R.or)([Rk(Cc, (0, R.preceded)(V, Pp), (0, R.preceded)(V, h), (m, r, B) => ["pathExpr", m, r, ...B]), (0, R.then)(Cc, (0, R.preceded)(S(Zl, V), h), (m, r) => ["pathExpr", m, ...r]), Gs, (0, R.map)(Cc, m => ["pathExpr", m])]),
      yf = (0, R.or)([Rk(Cc, (0, R.preceded)(V, Pp), (0, R.preceded)(V, h), (m, r, B) => [m, r, ...B]), (0, R.then)(Cc, (0, R.preceded)(S(Zl, V), h), (m, r) => [m, ...r]), (0, R.map)(Cc, m => [m])]),
      Is = (0, R.or)([(0, R.map)(T([Zl, V], yf), m => ["pathExpr", ["rootExpr"], ...m]), (0, R.then)(Pp, (0, R.preceded)(V, yf), (m, r) => ["pathExpr", ["rootExpr"], m, ...r]), (0, R.map)((0, R.followed)(Zl, (0, R.not)((0, R.preceded)(V, a.Za ? Wk(/[*<a-zA-Z]/) : Wk(/[*a-zA-Z]/)), ["Single rootExpr cannot be by followed by something that can be interpreted as a relative path"])), () => ["pathExpr", ["rootExpr"]])]),
      Js = Qk((0, R.or)([Hs, Is]), kq),
      Ks = (0, R.preceded)(kn, (0, R.then)((0, R.optional)((0, R.or)([(0, R.map)((0, R.preceded)(V, Qp), m => ["validationMode", m]), (0, R.map)(T([V, ln, V], jp), m => ["type", ...m])])), (0, R.delimited)((0, R.preceded)(V, fl), S(l, V), gl), (m, r) => ["validateExpr", ...(m ? [m] : []), ["argExpr", r]])),
      Ls = (0, R.delimited)($k, (0, R.then)((0, R.preceded)(V, jp), (0, R.optional)((0, R.preceded)(W, Rp)), (m, r) => r ? ["pragma", ["pragmaName", m], ["pragmaContents", r]] : ["pragma", ["pragmaName", m]]), (0, R.preceded)(V, al)),
      Ms = (0, R.map)((0, R.followed)((0, R.plus)(Ls), (0, R.preceded)(V, (0, R.delimited)(fl, S((0, R.optional)(l), V), gl))), m => ["extensionExpr", ...m]),
      Ns = e(c(Js, Kl, (m, r) => 0 === r.length ? m : ["simpleMapExpr", "pathExpr" === m[0] ? m : ["pathExpr", ["stepExpr", ["filterExpr", dq(m)]]]].concat(r.map(B => {
        B = B[1];
        return "pathExpr" === B[0] ? B : ["pathExpr", ["stepExpr", ["filterExpr", dq(B)]]];
      })))),
      Os = (0, R.or)([Ks, Ms, Ns]),
      Kj = (0, R.or)([(0, R.then)((0, R.or)([Vk([Yl], "unaryMinusOp"), Vk([Xl], "unaryPlusOp")]), (0, R.preceded)(V, function (m, r) {
        return Kj(m, r);
      }), (m, r) => [m, ["operand", r]]), Os]),
      Ps = (0, R.or)([(0, R.map)(jp, m => ["EQName", ...m]), lp, Af]),
      Qs = (0, R.then)(Kj, (0, R.star)(T([V, am, V], (0, R.then)(Ps, (0, R.preceded)(V, de), (m, r) => [m, r]))), (m, r) => r.reduce((B, X) => ["arrowExpr", ["argExpr", B], X[0], ["arguments", ...X[1]]], m)),
      Rs = (0, R.then)(Qs, (0, R.optional)(T([V, fm, W, em, mp, V], iq)), (m, r) => null !== r ? ["castExpr", ["argExpr", m], r] : m),
      Ss = (0, R.then)(Rs, (0, R.optional)(T([V, gm, W, em, mp, V], iq)), (m, r) => null !== r ? ["castableExpr", ["argExpr", m], r] : m),
      Ts = (0, R.then)(Ss, (0, R.optional)(T([V, hm, W, em, mp, V], gb)), (m, r) => null !== r ? ["treatExpr", ["argExpr", m], ["sequenceType", ...r]] : m),
      Us = (0, R.then)(Ts, (0, R.optional)(T([V, im, W, jm, mp, V], gb)), (m, r) => null !== r ? ["instanceOfExpr", ["argExpr", m], ["sequenceType", ...r]] : m),
      Vs = c(Us, (0, R.followed)((0, R.or)([Vk([tm], "intersectOp"), Vk([um], "exceptOp")]), mp), b),
      Ws = c(Vs, (0, R.or)([Vk([Ll], "unionOp"), (0, R.followed)(Vk([vm], "unionOp"), mp)]), b),
      Xs = c(Ws, (0, R.or)([Vk([Dl], "multiplyOp"), (0, R.followed)(Vk([Am], "divOp"), mp), (0, R.followed)(Vk([Bm], "idivOp"), mp), (0, R.followed)(Vk([Cm], "modOp"), mp)]), b),
      Ys = c(Xs, (0, R.or)([Vk([Yl], "subtractOp"), Vk([Xl], "addOp")]), b),
      Zs = d(Ys, (0, R.followed)(Vk([wm], "rangeSequenceExpr"), mp), "startExpr", "endExpr"),
      $s = c(Zs, Vk([Ml], "stringConcatenateOp"), b),
      at = d($s, (0, R.or)([Sp, Tp, Up])),
      bt = c(at, (0, R.followed)(Vk([zm], "andOp"), mp), b),
      Jr = c(bt, (0, R.followed)(Vk([ym], "orOp"), mp), b),
      ct = e((0, R.map)(l, m => ["ifClause", m])),
      dt = e((0, R.map)(k, m => ["thenClause", m])),
      et = e((0, R.map)(k, m => ["elseClause", m])),
      Dr = (0, R.then)((0, R.then)(T([Mm, V, bl, V], ct), T([V, cl, V, Nm, mp, V], dt), (m, r) => [m, r]), T([V, Om, mp, V], et), (m, r) => ["ifThenElseExpr", m[0], m[1], r]),
      ft = (0, R.delimited)(Pm, W, Qm),
      gt = (0, R.map)(T([Rm, W, Fl], jp), m => ["positionalVariableBinding", ...m]),
      ht = Tk((0, R.preceded)(Fl, (0, R.cut)(jp)), (0, R.cut)((0, R.preceded)(V, (0, R.optional)(Ac))), (0, R.cut)((0, R.preceded)(V, (0, R.optional)(ft))), (0, R.cut)((0, R.preceded)(V, (0, R.optional)(gt))), (0, R.cut)((0, R.preceded)(S(Sm, V), k)), (m, r, B, X, ea) => ["forClauseItem", ["typedVariableBinding", ["varName", ...m, ...(r ? [r] : [])]], ...(B ? [["allowingEmpty"]] : []), ...(X ? [X] : []), ["forExpr", ea]]),
      it = T([Tm, W], c(ht, Ul, (m, r) => ["forClause", m, ...r.map(B => B[1])])),
      jt = Rk((0, R.preceded)(Fl, jp), (0, R.preceded)(V, (0, R.optional)(Ac)), (0, R.preceded)(S(zl, V), k), (m, r, B) => ["letClauseItem", ["typedVariableBinding", ["varName", ...m], ...(r ? [r] : [])], ["letExpr", B]]),
      kt = (0, R.map)(T([Um, V], c(jt, Ul, (m, r) => [m, ...r.map(B => B[1])])), m => ["letClause", ...m]),
      Lj = (0, R.or)([it, kt]),
      lt = (0, R.map)(T([Vm, mp, V], k), m => ["whereClause", m]),
      mt = (0, R.map)((0, R.preceded)(Fl, jp), m => ["varName", ...m]),
      nt = (0, R.then)((0, R.preceded)(V, (0, R.optional)(Ac)), (0, R.preceded)(S(zl, V), k), (m, r) => ["groupVarInitialize", ...(m ? [["typeDeclaration", ...m]] : []), ["varValue", r]]),
      ot = Rk(mt, (0, R.optional)(nt), (0, R.optional)((0, R.map)((0, R.preceded)(S(Wm, V), u), m => ["collation", m])), (m, r, B) => ["groupingSpec", m, ...(r ? [r] : []), ...(B ? [B] : [])]),
      pt = c(ot, Ul, (m, r) => [m, ...r.map(B => B[1])]),
      qt = (0, R.map)(T([Xm, W, Ym, V], pt), m => ["groupByClause", ...m]),
      rt = Rk((0, R.optional)((0, R.or)([jo, ko])), (0, R.optional)(T([V, Qm, V], (0, R.or)([un, vn].map(m => (0, R.map)(m, r => "empty " + r))))), (0, R.preceded)(V, (0, R.optional)(T([Wm, V], u))), (m, r, B) => m || r || B ? ["orderModifier", ...(m ? [["orderingKind", m]] : []), ...(r ? [["emptyOrderingMode", r]] : []), ...(B ? [["collation", B]] : [])] : null),
      st = (0, R.then)(k, (0, R.preceded)(V, rt), (m, r) => ["orderBySpec", ["orderByExpr", m], ...(r ? [r] : [])]),
      tt = c(st, Ul, (m, r) => [m, ...r.map(B => B[1])]),
      ut = (0, R.then)((0, R.or)([(0, R.map)(T([Zm, W], Ym), () => !1), (0, R.map)(T([$m, W, Zm, W], Ym), () => !0)]), (0, R.preceded)(V, tt), (m, r) => ["orderByClause", ...(m ? [["stable"]] : []), ...r]),
      vt = (0, R.or)([Lj, lt, qt, ut]),
      wt = (0, R.map)(T([an, V], k), m => ["returnClause", m]),
      zr = Rk(Lj, (0, R.cut)((0, R.star)((0, R.preceded)(V, vt))), (0, R.cut)((0, R.preceded)(V, wt)), (m, r, B) => ["flworExpr", m, ...r, B]),
      xt = c(gb, Ll, (m, r) => 0 === r.length ? ["sequenceType", ...m] : ["sequenceTypeUnion", ["sequenceType", ...m], ...r.map(B => ["sequenceType", ...B[1]])]),
      yt = Rk(T([yn, V], (0, R.optional)((0, R.preceded)(Fl, (0, R.followed)((0, R.followed)(jp, W), em)))), (0, R.preceded)(V, xt), T([W, an, W], k), (m, r, B) => ["typeswitchExprCaseClause"].concat(m ? [["variableBinding", ...m]] : [], [r], [["resultExpr", B]])),
      Cr = Sk((0, R.preceded)(zn, S((0, R.delimited)(bl, S(l, V), cl), V)), (0, R.plus)((0, R.followed)(yt, V)), T([nn, W], (0, R.optional)((0, R.preceded)(Fl, (0, R.followed)(jp, W)))), T([an, W], k), (m, r, B, X) => ["typeswitchExpr", ["argExpr", m], ...r, ["typeswitchExprDefaultClause", ...(B || []), ["resultExpr", X]]]),
      zt = Rk((0, R.preceded)(Fl, jp), (0, R.optional)((0, R.preceded)(W, Ac)), (0, R.preceded)(S(Sm, W), k), (m, r, B) => ["quantifiedExprInClause", ["typedVariableBinding", ["varName", ...m], ...(r ? [r] : [])], ["sourceExpr", B]]),
      At = c(zt, Ul, (m, r) => [m, ...r.map(B => B[1])]),
      Ar = Rk((0, R.or)([An, Bn]), (0, R.preceded)(W, At), (0, R.preceded)(S(Cn, V), k), (m, r, B) => ["quantifiedExpr", ["quantifier", m], ...r, ["predicateExpr", B]]),
      Fr = (0, R.map)(T([mm, W, (0, R.or)([lm, km]), W], k), m => ["deleteExpr", ["targetExpr", m]]),
      Hr = Rk(T([Dn, W], (0, R.optional)(T([nm, W, jm], W))), T([km, W], k), (0, R.preceded)(S(En, W), k), (m, r, B) => m ? ["replaceExpr", ["replaceValue"], ["targetExpr", r], ["replacementExpr", B]] : ["replaceExpr", ["targetExpr", r], ["replacementExpr", B]]),
      Bt = (0, R.then)(lp, (0, R.preceded)(S(zl, V), k), (m, r) => ["transformCopy", m, ["copySource", r]]),
      Ir = Rk(T([Fn, W], c(Bt, Ul, (m, r) => [m, ...r.map(B => B[1])])), T([V, Gn, W], k), (0, R.preceded)(S(an, W), k), (m, r, B) => ["transformExpr", ["transformCopies", ...m], ["modifyExpr", r], ["returnExpr", B]]),
      Ct = (0, R.or)([(0, R.followed)((0, R.map)((0, R.optional)((0, R.followed)(T([em, W], (0, R.or)([(0, R.map)(Hn, () => ["insertAsFirst"]), (0, R.map)(In, () => ["insertAsLast"])])), W)), m => m ? ["insertInto", m] : ["insertInto"]), Ln), (0, R.map)(Kn, () => ["insertAfter"]), (0, R.map)(Jn, () => ["insertBefore"])]),
      Er = Rk(T([Mn, W, (0, R.or)([lm, km]), W], k), (0, R.preceded)(W, Ct), (0, R.preceded)(W, k), (m, r, B) => ["insertExpr", ["sourceExpr", m], r, ["targetExpr", B]]),
      Gr = (0, R.then)(T([Nn, W, km, V], k), T([W, em, W], k), (m, r) => ["renameExpr", ["targetExpr", m], ["newNameExpr", r]]),
      Dt = (0, R.then)((0, R.plus)((0, R.then)((0, R.map)(T([yn, W], (0, R.cut)(k)), m => ["switchCaseExpr", m]), (0, R.cut)(W), m => m)), (0, R.cut)(T([an, W], (0, R.cut)(k))), (m, r) => ["switchExprCaseClause", ...m, ["resultExpr", r]]),
      Br = Rk(T([On, V, bl], (0, R.cut)(l)), (0, R.cut)(T([V, cl, (0, R.cut)(V)], (0, R.plus)((0, R.followed)(Dt, V)))), (0, R.cut)(T([nn, W, an, W], k)), (m, r, B) => ["switchExpr", ["argExpr", m], ...r, ["switchExprDefaultClause", ["resultExpr", B]]]),
      Et = (0, R.map)(l, m => ["queryBody", m]),
      Ft = T([mn, W, dn, W], (0, R.cut)((0, R.then)(ap, (0, R.preceded)(S(Jl, V), u), (m, r) => ["namespaceDecl", ["prefix", m], ["uri", r]]))),
      Gt = (0, R.then)(T([Pn, W, Fl, V], (0, R.then)(jp, (0, R.optional)((0, R.preceded)(V, Ac)), (m, r) => [m, r])), (0, R.cut)((0, R.or)([(0, R.map)(T([V, zl, V], k), m => ["varValue", m]), (0, R.map)(T([W, Qn], (0, R.optional)(T([V, zl, V], k))), m => ["external", ...(m ? [["varValue", m]] : [])])])), ([m, r], B) => ["varDecl", ["varName", ...m], ...(null !== r ? [r] : []), B]),
      Ht = Sk(T([om, W, (0, R.cut)((0, R.peek)((0, R.not)((0, R.followed)(Dp, (0, R.not)(Bl, [""])), ["Cannot use reserved function name"])))], jp), (0, R.cut)(T([V, bl, V], (0, R.optional)(Ej))), (0, R.cut)(T([V, cl], (0, R.optional)(T([W, em, W], gb)))), (0, R.cut)((0, R.preceded)(V, (0, R.or)([(0, R.map)(Dj, m => ["functionBody", m]), (0, R.map)(Qn, () => ["externalDefinition"])]))), (m, r, B, X) => ["functionDecl", ["functionName", ...m], ["paramList", ...(r || [])], ...(B ? [["typeDeclaration", ...B]] : []), X]),
      It = T([mn, W], (0, R.then)((0, R.star)((0, R.followed)((0, R.or)([Bf, Vp]), W)), (0, R.or)([Gt, Ht]), (m, r) => [r[0], ...m, ...r.slice(1)])),
      Jt = (0, R.then)(T([mn, W, nn, W], (0, R.or)([qm, om])), T([W, dn, W], u), (m, r) => ["defaultNamespaceDecl", ["defaultNamespaceCategory", m], ["uri", r]]),
      Kt = (0, R.or)([(0, R.map)((0, R.followed)(T([dn, W], ap), (0, R.preceded)(V, Jl)), m => ["namespacePrefix", m]), (0, R.map)(T([nn, W, qm, W], dn), () => ["defaultElementNamespace"])]),
      Lt = T([Sn, W, Tn], Rk((0, R.optional)((0, R.preceded)(W, Kt)), (0, R.preceded)(V, u), (0, R.optional)((0, R.then)(T([W, Rm, W], u), (0, R.star)(T([V, Ul, V], u)), (m, r) => [m, ...r])), (m, r, B) => ["schemaImport", ...(m ? [m] : []), ["targetNamespace", r], ...(B ? [B] : [])])),
      Mt = T([Sn, W, Un], Rk((0, R.optional)((0, R.followed)(T([W, dn, W], ap), (0, R.preceded)(V, Jl))), (0, R.preceded)(V, u), (0, R.optional)((0, R.then)(T([W, Rm, W], u), (0, R.star)(T([V, Ul, V], u)), (m, r) => [m, ...r])), (m, r) => ["moduleImport", ["namespacePrefix", m], ["targetNamespace", r]])),
      Nt = (0, R.or)([Lt, Mt]),
      Ot = (0, R.map)(T([mn, W, nn, W, Wm, W], u), m => ["defaultCollationDecl", m]),
      Pt = (0, R.map)(T([mn, W, Vn, W], u), m => ["baseUriDecl", m]),
      Qt = (0, R.then)(T([mn, W], (0, R.or)([(0, R.map)(T([xn, W], jp), m => ["decimalFormatName", ...m]), (0, R.map)(T([nn, W], xn), () => null)])), (0, R.star)((0, R.then)((0, R.preceded)(W, Yp), (0, R.preceded)(S(Jl, W), u), (m, r) => ["decimalFormatParam", ["decimalFormatParamName", m], ["decimalFormatParamValue", r]])), (m, r) => ["decimalFormatDecl", ...(m ? [m] : []), ...r]),
      Rt = (0, R.or)([Zp, Ot, Pt, $p, aq, bq, cq, Qt]),
      St = (0, R.then)(T([mn, W, $n, W], jp), (0, R.preceded)(W, u), (m, r) => ["optionDecl", ["optionName", m], ["optionContents", r]]),
      Tt = (0, R.then)(T([mn, W, ao, W, bo], (0, R.optional)(T([W, em], Bj))), (0, R.or)([(0, R.map)((0, R.preceded)(S(zl, V), k), m => ["varValue", m]), (0, R.map)(T([W, Qn], (0, R.optional)((0, R.preceded)(S(zl, V), k))), () => ["external"])]), (m, r) => ["contextItemDecl", ...(m ? [["contextItemType", m]] : []), r]),
      Mj = (0, R.then)((0, R.star)((0, R.followed)((0, R.or)([Jt, Rt, Ft, Nt]), (0, R.cut)(S(Cl, V)))), (0, R.star)((0, R.followed)((0, R.or)([Tt, It, St]), (0, R.cut)(S(Cl, V)))), (m, r) => 0 === m.length && 0 === r.length ? null : ["prolog", ...m, ...r]),
      Ut = T([Un, W, dn, W], (0, R.then)((0, R.followed)(ap, S(Jl, V)), (0, R.followed)(u, S(Cl, V)), (m, r) => ["moduleDecl", ["prefix", m], ["uri", r]])),
      Vt = (0, R.then)(Ut, (0, R.preceded)(V, Mj), (m, r) => ["libraryModule", m, ...(r ? [r] : [])]),
      Wt = (0, R.then)(Mj, (0, R.preceded)(V, Et), (m, r) => ["mainModule", ...(m ? [m] : []), r]),
      Xt = (0, R.map)(T([co, V], (0, R.followed)((0, R.or)([(0, R.then)((0, R.preceded)(fo, W), u, m => ["encoding", m]), (0, R.then)(T([eo, W], u), (0, R.optional)(T([W, fo, W], u)), (m, r) => [["version", m], ...(r ? [["encoding", r]] : [])])]), (0, R.preceded)(V, Cl))), m => ["versionDecl", ...m]),
      Yt = (0, R.then)((0, R.optional)(S(Xt, V)), (0, R.or)([Vt, Wt]), (m, r) => ["module", ...(m ? [m] : []), r]),
      Zt = (0, R.complete)(S(Yt, V));
    return (m, r) => {
      n.clear();
      r = Zt(m, r);
      let B = 1,
        X = 1;
      for (let ea = 0; ea < m.length + 1; ea++) {
        if (n.has(ea)) {
          const Fa = n.get(ea);
          Fa.line = X;
          Fa.ha = B;
        }
        "\n" === m[ea] ? (X++, B = 1) : B++;
      }
      return r;
    };
  }
  const mq = lq({
      mb: !1,
      Za: !1
    }),
    nq = lq({
      mb: !0,
      Za: !1
    }),
    oq = lq({
      mb: !1,
      Za: !0
    }),
    pq = lq({
      mb: !0,
      Za: !0
    });
  function qq(a, b) {
    var c = !!b.Z;
    b = !!b.debug;
    So.clear();
    To.clear();
    kq.clear();
    c = c ? b ? pq(a, 0) : oq(a, 0) : b ? nq(a, 0) : mq(a, 0);
    if (!0 === c.success) return c.value;
    a = a.substring(0, c.offset).split("\n");
    b = a[a.length - 1].length + 1;
    throw new Rh({
      start: {
        offset: c.offset,
        line: a.length,
        ha: b
      },
      end: {
        offset: c.offset + 1,
        line: a.length,
        ha: b + 1
      }
    }, "", "", Error(`XPST0003: Failed to parse script. Expected ${[...new Set(c.expected)]}`));
  }
  const rq = "http://www.w3.org/XML/1998/namespace http://www.w3.org/2001/XMLSchema http://www.w3.org/2001/XMLSchema-instance http://www.w3.org/2005/xpath-functions http://www.w3.org/2005/xpath-functions/math http://www.w3.org/2012/xquery http://www.w3.org/2005/xpath-functions/array http://www.w3.org/2005/xpath-functions/map".split(" ");
  function sq(a, b, c, d, e) {
    var f = F(a, "functionName"),
      h = I(f, "prefix") || "";
    let k = I(f, "URI");
    const l = H(f);
    if (null === k && (k = "" === h ? null === b.v ? "http://www.w3.org/2005/xpath-functions" : b.v : b.$(h), !k && h)) throw zg(h);
    if (rq.includes(k)) throw tg();
    h = K(a, "annotation").map(y => F(y, "annotationName"));
    f = h.every(y => !I(y, "URI") && "private" !== H(y));
    h = h.some(y => !I(y, "URI") && "updating" === H(y));
    if (!k) throw vg();
    const n = Lg(a),
      t = K(F(a, "paramList"), "param"),
      u = t.map(y => F(y, "varName")),
      z = t.map(y => Lg(y));
    if (a = F(a, "functionBody")) {
      if (b.va(k, l, z.length)) throw ug(k, l);
      if (!e) return;
      const y = Fk(a[1], {
          sa: !1,
          Z: !0
        }),
        G = new Cg(b),
        N = u.map(U => {
          let ca = I(U, "URI");
          const Ga = I(U, "prefix");
          U = H(U);
          Ga && null === ca && (ca = b.$(Ga || ""));
          return Hg(G, ca, U);
        });
      e = h ? {
        j: z,
        arity: u.length,
        callFunction: (U, ca, Ga, ...Gb) => {
          U = hc(bc(U, -1, null, w.empty()), N.reduce((Xb, fd, Yb) => {
            Xb[fd] = Ra(Gb[Yb]);
            return Xb;
          }, Object.create(null)));
          return y.s(U, ca);
        },
        wb: !1,
        I: !0,
        cb: f,
        localName: l,
        namespaceURI: k,
        i: n
      } : {
        j: z,
        arity: u.length,
        callFunction: (U, ca, Ga, ...Gb) => {
          U = hc(bc(U, -1, null, w.empty()), N.reduce((Xb, fd, Yb) => {
            Xb[fd] = Ra(Gb[Yb]);
            return Xb;
          }, Object.create(null)));
          return C(y, U, ca);
        },
        wb: !1,
        I: !1,
        cb: f,
        localName: l,
        namespaceURI: k,
        i: n
      };
      c.push({
        ba: y,
        Eb: G
      });
      d.push({
        arity: u.length,
        ba: y,
        Ab: e,
        localName: l,
        namespaceURI: k,
        cb: f
      });
    } else {
      if (h) throw Error("Updating external function declarations are not supported");
      e = {
        j: z,
        arity: u.length,
        callFunction: (y, G, N, ...U) => {
          const ca = N.va(k, l, u.length, !0);
          if (!ca) throw Error(`XPST0017: Function Q{${k}}${l} with arity of ${u.length} not registered. ${mg(l)}`);
          if (ca.i.type !== n.type || ca.j.some((Ga, Gb) => Ga.type !== z[Gb].type)) throw Error("External function declaration types do not match actual function");
          return ca.callFunction(y, G, N, ...U);
        },
        wb: !0,
        I: !1,
        localName: l,
        namespaceURI: k,
        cb: f,
        i: n
      };
    }
    Fg(b, k, l, u.length, e);
  }
  function tq(a, b, c, d) {
    const e = [],
      f = [];
    K(a, "*").forEach(t => {
      switch (t[0]) {
        case "moduleImport":
        case "namespaceDecl":
        case "defaultNamespaceDecl":
        case "functionDecl":
        case "varDecl":
          break;
        default:
          throw Error("Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules");
      }
    });
    const h = new Set();
    K(a, "moduleImport").forEach(t => {
      const u = H(F(t, "namespacePrefix"));
      t = H(F(t, "targetNamespace"));
      if (h.has(t)) throw Error(`XQST0047: The namespace "${t}" is imported more than once.`);
      h.add(t);
      Gg(b, u, t);
    });
    K(a, "namespaceDecl").forEach(t => {
      const u = H(F(t, "prefix"));
      t = H(F(t, "uri"));
      if ("xml" === u || "xmlns" === u) throw xg();
      if ("http://www.w3.org/XML/1998/namespace" === t || "http://www.w3.org/2000/xmlns/" === t) throw xg();
      Gg(b, u, t);
    });
    let k = null,
      l = null;
    for (const t of K(a, "defaultNamespaceDecl")) {
      const u = H(F(t, "defaultNamespaceCategory")),
        z = H(F(t, "uri"));
      if (!z) throw vg();
      if ("http://www.w3.org/XML/1998/namespace" === z || "http://www.w3.org/2000/xmlns/" === z) throw xg();
      if ("function" === u) {
        if (k) throw wg();
        k = z;
      } else if ("element" === u) {
        if (l) throw wg();
        l = z;
      }
    }
    k && (b.v = k);
    l && Gg(b, "", l);
    K(a, "functionDecl").forEach(t => {
      sq(t, b, e, f, c);
    });
    const n = [];
    K(a, "varDecl").forEach(t => {
      const u = Kg(F(t, "varName"));
      let z = u.namespaceURI;
      if (null === z && (z = b.$(u.prefix), !z && u.prefix)) throw zg(u.prefix);
      if (rq.includes(z)) throw tg();
      var y = F(t, "external");
      t = F(t, "varValue");
      let G, N;
      null !== y ? (y = F(y, "varValue"), null !== y && (G = F(y, "*"))) : null !== t && (G = F(t, "*"));
      if (n.some(U => U.namespaceURI === z && U.localName === u.localName)) throw Error(`XQST0049: The variable ${z ? `Q{${z}}` : ""}${u.localName} has already been declared.`);
      Hg(b, z || "", u.localName);
      if (c && (G && (N = Fk(G, {
        sa: !1,
        Z: !0
      })), G && !Eg(b, z || "", u.localName))) {
        let U = null;
        Ig(b, z, u.localName, (ca, Ga) => {
          if (U) return U();
          U = Ra(C(N, ca, Ga));
          return U();
        });
        e.push({
          ba: N,
          Eb: new Cg(b)
        });
        n.push({
          ba: N,
          localName: u.localName,
          namespaceURI: z
        });
      }
    });
    f.forEach(t => {
      if (!t.Ab.I && t.ba.I) throw Oe(`The function Q{${t.namespaceURI}}${t.localName} is updating but the %updating annotation is missing.`);
    });
    return {
      Ia: f.map(t => t.Ab),
      Ta: n,
      source: d,
      pa: t => {
        h.forEach(u => {
          Nk(b, u);
        });
        e.forEach(({
          ba: u,
          Eb: z
        }) => {
          h.forEach(y => {
            Nk(z, y);
          });
          t.Ia.forEach(y => {
            z.va(y.namespaceURI, y.localName, y.arity, !0) || y.cb && Fg(z, y.namespaceURI, y.localName, y.arity, y);
          });
          t.Ta.forEach(y => {
            z.eb(y.namespaceURI, y.localName) || Hg(z, y.namespaceURI, y.localName);
          });
          u.v(z);
        });
      }
    };
  }
  function uq(a, b, c, d, e, f, h) {
    const k = b.Z ? "XQuery" : "XPath";
    c = b.Ha ? null : Ik(a, k, c, d, e, b.debug, f, h);
    return null !== c ? {
      state: c.hc ? 1 : 2,
      ba: c.ba
    } : {
      state: 0,
      Zb: "string" === typeof a ? qq(a, b) : Kk(a)
    };
  }
  function vq(a, b, c, d) {
    const e = F(a, "mainModule");
    if (!e) throw Error("Can not execute a library module.");
    const f = F(e, "prolog");
    if (f) {
      if (!b.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
      Ok();
      d = tq(f, c, !0, d);
      d.pa(d);
    }
    O(a, new rh(c));
    a = J(e, ["queryBody", "*"]);
    return Q(a, b);
  }
  function wq(a, b, c, d, e, f, h) {
    const k = new qg(c, d, f, h),
      l = new Cg(k);
    0 < Object.keys(e).length && Ok();
    Object.keys(e).forEach(n => {
      const t = e[n];
      Nk(l, t);
      Gg(l, n, t);
    });
    "string" === typeof a && (a = Pk(a));
    c = uq(a, b, c, d, e, f, h);
    switch (c.state) {
      case 2:
        return {
          ga: l,
          ba: c.ba
        };
      case 1:
        return c.ba.v(l), Jk(a, b.Z ? "XQuery" : "XPath", k, e, c.ba, b.debug, f), {
          ga: l,
          ba: c.ba
        };
      case 0:
        return c = vq(c.Zb, b, l, a), c.v(l), b.Ha || Jk(a, b.Z ? "XQuery" : "XPath", k, e, c, b.debug, f), {
          ga: l,
          ba: c
        };
    }
  }
  function xq(a) {
    if (v(a.type, 1)) return a.value;
    if (v(a.type, 54)) return a.value.node;
    throw mc(`Unable to convert selector argument of type ${Da[a.type]} to either an ${Da[1]} or an ${Da[54]} representing an XQueryX program while calling 'fontoxpath:evaluate'`);
  }
  function yq(a, b, c, d) {
    a = a.first();
    const e = b.first().h.reduce((f, h) => {
      f[h.key.value] = Ra(h.value());
      return f;
    }, Object.create(null));
    b = e["."] ? e["."]() : w.empty();
    delete e["."];
    try {
      const {
          ba: f,
          ga: h
        } = wq(xq(a), {
          sa: !1,
          Z: !0,
          debug: d.debug,
          Ha: d.Ha
        }, n => c.$(n), Object.keys(e).reduce((n, t) => {
          n[t] = t;
          return n;
        }, {}), {}, "http://www.w3.org/2005/xpath-functions", (n, t) => c.Sa(n, t)),
        k = !b.F(),
        l = new cc({
          M: k ? b.first() : null,
          Aa: k ? 0 : -1,
          ta: b,
          ra: Object.keys(e).reduce((n, t) => {
            n[h.eb(null, t)] = e[t];
            return n;
          }, Object.create(null))
        });
      return {
        ic: f.h(l, d).value,
        ec: a
      };
    } catch (f) {
      hg(a.value, f);
    }
  }
  function zq(a, b, c) {
    if (1 !== b.node.nodeType && 9 !== b.node.nodeType) return [];
    const d = hb(a, b).reduce((e, f) => {
      for (const h of zq(a, f, c)) e.push(h);
      return e;
    }, []);
    c(b) && d.unshift(b);
    return d;
  }
  const Aq = (a, b, c, d, e) => {
      a = e.first();
      if (!a) throw lc("The context is absent, it needs to be present to use id function.");
      if (!v(a.type, 53)) throw mc("The context item is not a node, it needs to be node to use id function.");
      const f = b.h,
        h = d.O().reduce((k, l) => {
          l.value.split(/\s+/).forEach(n => {
            k[n] = !0;
          });
          return k;
        }, Object.create(null));
      for (b = a.value; 9 !== b.node.nodeType;) if (b = x(f, b), null === b) throw Error("FODC0001: the root node of the target node is not a document node.");
      b = zq(f, b, k => {
        if (1 !== k.node.nodeType) return !1;
        k = fb(f, k, "id");
        if (!k || !h[k]) return !1;
        h[k] = !1;
        return !0;
      });
      return w.create(b.map(k => rb(k)));
    },
    Bq = (a, b, c, d, e) => {
      a = e.first();
      if (!a) throw lc("The context is absent, it needs to be present to use idref function.");
      if (!v(a.type, 53)) throw mc("The context item is not a node, it needs to be node to use idref function.");
      const f = b.h,
        h = d.O().reduce((k, l) => {
          k[l.value] = !0;
          return k;
        }, Object.create(null));
      for (b = a.value; 9 !== b.node.nodeType;) if (b = x(f, b), null === b) throw Error("FODC0001: the root node of the context node is not a document node.");
      b = zq(f, b, k => 1 !== k.node.nodeType ? !1 : (k = fb(f, k, "idref")) ? k.split(/\s+/).some(l => h[l]) : !1);
      return w.create(b.map(k => rb(k)));
    };
  function Cq(a) {
    switch (typeof a) {
      case "object":
        return Array.isArray(a) ? w.m(new pb(a.map(b => Ra(Cq(b))))) : null === a ? w.empty() : w.m(new ub(Object.keys(a).map(b => ({
          key: g(b, 1),
          value: Ra(Cq(a[b]))
        }))));
      case "number":
        return w.m(g(a, 3));
      case "string":
        return w.m(g(a, 1));
      case "boolean":
        return a ? w.aa() : w.T();
      default:
        throw Error("Unexpected type in JSON parse");
    }
  }
  const Dq = (a, b, c, d, e) => {
    const f = w.m(g("duplicates", 1));
    a = tb(a, b, c, e, f);
    const h = a.F() ? "use-first" : a.first().value;
    return d.N(k => w.m(new ub(k.reduce((l, n) => {
      n.h.forEach(t => {
        const u = l.findIndex(z => sb(z.key, t.key));
        if (0 <= u) switch (h) {
          case "reject":
            throw Error("FOJS0003: Duplicate encountered when merging maps.");
          case "use-last":
            l.splice(u, 1, t);
            return;
          case "combine":
            l.splice(u, 1, {
              key: t.key,
              value: Ra(w.create(l[u].value().O().concat(t.value().O())))
            });
            return;
          default:
            return;
        }
        l.push(t);
      });
      return l;
    }, []))));
  };
  function Eq(a, b, c) {
    let d = 1;
    const e = a.value;
    a = a.Pa(!0);
    let f = null;
    const h = Math.max(b - 1, 0);
    -1 !== a && (f = Math.max(0, (null === c ? a : Math.max(0, Math.min(a, c + (b - 1)))) - h));
    return w.create({
      next: k => {
        for (; d < b;) e.next(k), d++;
        if (null !== c && d >= b + c) return p;
        k = e.next(k);
        d++;
        return k;
      }
    }, f);
  }
  function Fq(a) {
    return a.map(b => v(b.type, 19) ? jd(b, 3) : b);
  }
  function Gq(a) {
    a = Fq(a);
    if (a.some(b => Number.isNaN(b.value))) return [g(NaN, 3)];
    a = Ji(a);
    if (!a) throw Error("FORG0006: Incompatible types to be converted to a common type");
    return a;
  }
  const Hq = (a, b, c, d, e, f) => A([e, f], ([h, k]) => {
      if (Infinity === h.value) return w.empty();
      if (-Infinity === h.value) return k && Infinity === k.value ? w.empty() : d;
      if (k) {
        if (isNaN(k.value)) return w.empty();
        Infinity === k.value && (k = null);
      }
      return isNaN(h.value) ? w.empty() : Eq(d, Math.round(h.value), k ? Math.round(k.value) : null);
    }),
    Iq = (a, b, c, d, e) => {
      if (d.F()) return e;
      a = Fq(d.O());
      a = Ji(a);
      if (!a) throw Error("FORG0006: Incompatible types to be converted to a common type");
      if (!a.every(f => v(f.type, 2))) throw Error("FORG0006: items passed to fn:sum are not all numeric.");
      b = a.reduce((f, h) => f + h.value, 0);
      return a.every(f => v(f.type, 5)) ? w.m(g(b, 5)) : a.every(f => v(f.type, 3)) ? w.m(g(b, 3)) : a.every(f => v(f.type, 4)) ? w.m(g(b, 4)) : w.m(g(b, 6));
    };
  var Jq = [].concat(Nf, [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "boolean",
    j: [{
      type: 59,
      g: 2
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: (a, b, c, d) => d.fa() ? w.aa() : w.T()
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "true",
    j: [],
    i: {
      type: 0,
      g: 3
    },
    callFunction: () => w.aa()
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "not",
    j: [{
      type: 59,
      g: 2
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: (a, b, c, d) => !1 === d.fa() ? w.aa() : w.T()
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "false",
    j: [],
    i: {
      type: 0,
      g: 3
    },
    callFunction: () => w.T()
  }], [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "last",
    j: [],
    i: {
      type: 5,
      g: 3
    },
    callFunction: a => {
      if (null === a.M) throw lc("The fn:last() function depends on dynamic context, which is absent.");
      let b = !1;
      return w.create({
        next: () => {
          if (b) return p;
          const c = a.ta.Pa();
          b = !0;
          return q(g(c, 5));
        }
      }, 1);
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "position",
    j: [],
    i: {
      type: 5,
      g: 3
    },
    callFunction: a => {
      if (null === a.M) throw lc("The fn:position() function depends on dynamic context, which is absent.");
      return w.m(g(a.Aa + 1, 5));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "current-dateTime",
    j: [],
    i: {
      type: 10,
      g: 3
    },
    callFunction: a => w.m(g(ec(a), 10))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "current-date",
    j: [],
    i: {
      type: 7,
      g: 3
    },
    callFunction: a => w.m(g(Lb(ec(a), 7), 7))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "current-time",
    j: [],
    i: {
      type: 8,
      g: 3
    },
    callFunction: a => w.m(g(Lb(ec(a), 8), 8))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "implicit-timezone",
    j: [],
    i: {
      type: 17,
      g: 3
    },
    callFunction: a => w.m(g(fc(a), 17))
  }], Of, Wf, cg, [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "years-from-duration",
    j: [{
      type: 18,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.bb(), 5))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "months-from-duration",
    j: [{
      type: 18,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.ab(), 5))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "days-from-duration",
    j: [{
      type: 18,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.$a(), 5))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "hours-from-duration",
    j: [{
      type: 18,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getHours(), 5))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "minutes-from-duration",
    j: [{
      type: 18,
      g: 0
    }],
    i: {
      type: 5,
      g: 0
    },
    callFunction: (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getMinutes(), 5))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "seconds-from-duration",
    j: [{
      type: 18,
      g: 0
    }],
    i: {
      type: 4,
      g: 0
    },
    callFunction: (a, b, c, d) => d.F() ? d : w.m(g(d.first().value.getSeconds(), 4))
  }], eg, [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "id",
    j: [{
      type: 1,
      g: 2
    }, {
      type: 53,
      g: 3
    }],
    i: {
      type: 54,
      g: 2
    },
    callFunction: Aq
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "id",
    j: [{
      type: 1,
      g: 2
    }],
    i: {
      type: 54,
      g: 2
    },
    callFunction(a, b, c, d) {
      return Aq(a, b, c, d, w.m(a.M));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "idref",
    j: [{
      type: 1,
      g: 2
    }, {
      type: 53,
      g: 3
    }],
    i: {
      type: 53,
      g: 2
    },
    callFunction: Bq
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "idref",
    j: [{
      type: 1,
      g: 2
    }],
    i: {
      type: 53,
      g: 2
    },
    callFunction(a, b, c, d) {
      return Bq(a, b, c, d, w.m(a.M));
    }
  }], [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "parse-json",
    j: [{
      type: 1,
      g: 3
    }],
    i: {
      type: 59,
      g: 0
    },
    callFunction: (a, b, c, d) => {
      let e;
      try {
        e = JSON.parse(d.first().value);
      } catch (f) {
        throw Error("FOJS0001: parsed JSON string contains illegal JSON.");
      }
      return Cq(e);
    }
  }], [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "contains",
    j: [{
      type: 61,
      g: 3
    }, {
      type: 46,
      g: 3
    }],
    i: {
      type: 0,
      g: 3
    },
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => f.h.some(k => sb(k.key, h)) ? w.aa() : w.T())
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "entry",
    j: [{
      type: 46,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 61,
      g: 3
    },
    callFunction: (a, b, c, d, e) => d.map(f => new ub([{
      key: f,
      value: Ra(e)
    }]))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "for-each",
    j: [{
      type: 61,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => jc(f.h.map(k => h.value.call(void 0, a, b, c, w.m(k.key), k.value()))))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "get",
    j: [{
      type: 61,
      g: 3
    }, {
      type: 46,
      g: 3
    }],
    i: {
      type: 59,
      g: 2
    },
    callFunction: tb
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "keys",
    j: [{
      type: 61,
      g: 3
    }],
    i: {
      type: 46,
      g: 2
    },
    callFunction: (a, b, c, d) => A([d], ([e]) => w.create(e.h.map(f => f.key)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "merge",
    j: [{
      type: 61,
      g: 2
    }, {
      type: 61,
      g: 3
    }],
    i: {
      type: 61,
      g: 3
    },
    callFunction: Dq
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "merge",
    j: [{
      type: 61,
      g: 2
    }],
    i: {
      type: 61,
      g: 3
    },
    callFunction(a, b, c, d) {
      return Dq(a, b, c, d, w.m(new ub([{
        key: g("duplicates", 1),
        value: () => w.m(g("use-first", 1))
      }])));
    }
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "put",
    j: [{
      type: 61,
      g: 3
    }, {
      type: 46,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    i: {
      type: 61,
      g: 3
    },
    callFunction: (a, b, c, d, e, f) => A([d, e], ([h, k]) => {
      h = h.h.concat();
      const l = h.findIndex(n => sb(n.key, k));
      0 <= l ? h.splice(l, 1, {
        key: k,
        value: Ra(f)
      }) : h.push({
        key: k,
        value: Ra(f)
      });
      return w.m(new ub(h));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "remove",
    j: [{
      type: 61,
      g: 3
    }, {
      type: 46,
      g: 2
    }],
    i: {
      type: 61,
      g: 3
    },
    callFunction: (a, b, c, d, e) => A([d], ([f]) => {
      const h = f.h.concat();
      return e.N(k => {
        k.forEach(l => {
          const n = h.findIndex(t => sb(t.key, l));
          0 <= n && h.splice(n, 1);
        });
        return w.m(new ub(h));
      });
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "size",
    j: [{
      type: 61,
      g: 3
    }],
    i: {
      type: 5,
      g: 3
    },
    callFunction: (a, b, c, d) => d.map(e => g(e.h.length, 5))
  }], [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "pi",
    j: [],
    i: {
      type: 3,
      g: 3
    },
    callFunction: () => w.m(g(Math.PI, 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "exp",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.pow(Math.E, e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "exp10",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.pow(10, e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "log",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.log(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "log10",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.log10(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "pow",
    j: [{
      type: 3,
      g: 0
    }, {
      type: 2,
      g: 3
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d, e) => e.N(([f]) => d.map(h => 1 !== Math.abs(h.value) || Number.isFinite(f.value) ? g(Math.pow(h.value, f.value), 3) : g(1, 3)))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "sqrt",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.sqrt(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "sin",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.sin(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "cos",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.cos(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "tan",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.tan(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "asin",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.asin(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "acos",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.acos(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "atan",
    j: [{
      type: 3,
      g: 0
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(Math.atan(e.value), 3))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
    localName: "atan2",
    j: [{
      type: 3,
      g: 0
    }, {
      type: 3,
      g: 3
    }],
    i: {
      type: 3,
      g: 0
    },
    callFunction: (a, b, c, d, e) => e.N(([f]) => d.map(h => g(Math.atan2(h.value, f.value), 3)))
  }], Ae, Yd, [{
    namespaceURI: "http://fontoxpath/operators",
    localName: "to",
    j: [{
      type: 5,
      g: 0
    }, {
      type: 5,
      g: 0
    }],
    i: {
      type: 5,
      g: 2
    },
    callFunction: (a, b, c, d, e) => {
      a = d.first();
      e = e.first();
      if (null === a || null === e) return w.empty();
      let f = a.value;
      e = e.value;
      return f > e ? w.empty() : w.create({
        next: () => q(g(f++, 5))
      }, e - f + 1);
    }
  }], [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "QName",
    j: [{
      type: 1,
      g: 0
    }, {
      type: 1,
      g: 3
    }],
    i: {
      type: 23,
      g: 3
    },
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => {
      h = h.value;
      if (!tc(h, 23)) throw Error("FOCA0002: The provided QName is invalid.");
      f = f ? f.value || null : null;
      if (null === f && h.includes(":")) throw Error("FOCA0002: The URI of a QName may not be empty if a prefix is provided.");
      if (d.F()) return w.m(g(new Sa("", null, h), 23));
      if (!h.includes(":")) return w.m(g(new Sa("", f, h), 23));
      const [k, l] = h.split(":");
      return w.m(g(new Sa(k, f, l), 23));
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "prefix-from-QName",
    j: [{
      type: 23,
      g: 0
    }],
    i: {
      type: 24,
      g: 0
    },
    callFunction: (a, b, c, d) => A([d], ([e]) => {
      if (null === e) return w.empty();
      e = e.value;
      return e.prefix ? w.m(g(e.prefix, 24)) : w.empty();
    })
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "local-name-from-QName",
    j: [{
      type: 23,
      g: 0
    }],
    i: {
      type: 24,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(e.value.localName, 24))
  }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "namespace-uri-from-QName",
    j: [{
      type: 23,
      g: 0
    }],
    i: {
      type: 20,
      g: 0
    },
    callFunction: (a, b, c, d) => d.map(e => g(e.value.namespaceURI || "", 20))
  }], [{
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => d.X({
      empty: () => w.aa(),
      multiple: () => w.T(),
      m: () => w.T()
    }),
    localName: "empty",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => d.X({
      empty: () => w.T(),
      multiple: () => w.aa(),
      m: () => w.aa()
    }),
    localName: "exists",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => Eq(d, 1, 1),
    localName: "head",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 0
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => Eq(d, 2, null),
    localName: "tail",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 5,
      g: 3
    }, {
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d, e, f) => {
      if (d.F()) return f;
      if (f.F()) return d;
      a = d.O();
      e = e.first().value - 1;
      0 > e ? e = 0 : e > a.length && (e = a.length);
      b = a.slice(e);
      return w.create(a.slice(0, e).concat(f.O(), b));
    },
    localName: "insert-before",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 5,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => {
      a = e.first().value;
      d = d.O();
      if (!d.length || 1 > a || a > d.length) return w.create(d);
      d.splice(a - 1, 1);
      return w.create(d);
    },
    localName: "remove",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => d.N(e => w.create(e.reverse())),
    localName: "reverse",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 3,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => Hq(a, b, c, d, e, w.empty()),
    localName: "subsequence",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 3,
      g: 3
    }, {
      type: 3,
      g: 3
    }],
    callFunction: Hq,
    localName: "subsequence",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => d,
    localName: "unordered",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      const e = qc(d, b).O();
      return w.create(e).filter((f, h) => e.slice(0, h).every(k => !De(f, k)));
    },
    localName: "distinct-values",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 2
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }, {
      type: 1,
      g: 3
    }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "distinct-values",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 2
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }, {
      type: 46,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => e.N(([f]) => qc(d, b).map((h, k) => pi("eqOp", h.type, f.type)(h, f, a) ? g(k + 1, 5) : g(-1, 5)).filter(h => -1 !== h.value)),
    localName: "index-of",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 5,
      g: 2
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }, {
      type: 46,
      g: 3
    }, {
      type: 1,
      g: 3
    }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "index-of",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 5,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d, e) => {
      let f = !1;
      const h = Ge(a, b, c, d, e);
      return w.create({
        next: () => {
          if (f) return p;
          const k = h.next(0);
          if (k.done) return k;
          f = !0;
          return q(g(k.value, 0));
        }
      });
    },
    localName: "deep-equal",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 59,
      g: 2
    }, {
      type: 1,
      g: 3
    }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "deep-equal",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 0,
      g: 3
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      let e = !1;
      return w.create({
        next: () => {
          if (e) return p;
          const f = d.Pa();
          e = !0;
          return q(g(f, 5));
        }
      });
    },
    localName: "count",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 5,
      g: 3
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (d.F()) return d;
      a = Fq(d.O());
      a = Ji(a);
      if (!a) throw Error("FORG0006: Incompatible types to be converted to a common type");
      if (!a.every(e => v(e.type, 2))) throw Error("FORG0006: items passed to fn:avg are not all numeric.");
      b = a.reduce((e, f) => e + f.value, 0) / a.length;
      return a.every(e => v(e.type, 5) || v(e.type, 3)) ? w.m(g(b, 3)) : a.every(e => v(e.type, 4)) ? w.m(g(b, 4)) : w.m(g(b, 6));
    },
    localName: "avg",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 0
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (d.F()) return d;
      a = Gq(d.O());
      return w.m(a.reduce((e, f) => e.value < f.value ? f : e));
    },
    localName: "max",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 0
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }, {
      type: 1,
      g: 3
    }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "max",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 0
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (d.F()) return d;
      a = Gq(d.O());
      return w.m(a.reduce((e, f) => e.value > f.value ? f : e));
    },
    localName: "min",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 0
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }, {
      type: 1,
      g: 3
    }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "min",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 0
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }],
    callFunction: (a, b, c, d) => Iq(a, b, c, d, w.m(g(0, 5))),
    localName: "sum",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 3
    }
  }, {
    j: [{
      type: 46,
      g: 2
    }, {
      type: 46,
      g: 0
    }],
    callFunction: Iq,
    localName: "sum",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 46,
      g: 0
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (!d.F() && !d.oa()) throw Error("FORG0003: The argument passed to fn:zero-or-one contained more than one item.");
      return d;
    },
    localName: "zero-or-one",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 0
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (d.F()) throw Error("FORG0004: The argument passed to fn:one-or-more was empty.");
      return d;
    },
    localName: "one-or-more",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 1
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (!d.oa()) throw Error("FORG0005: The argument passed to fn:exactly-one is empty or contained more than one item.");
      return d;
    },
    localName: "exactly-one",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 3
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 60,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => {
      if (d.F()) return d;
      const f = e.first(),
        h = f.o;
      if (1 !== h.length) throw Error("XPTY0004: signature of function passed to fn:filter is incompatible.");
      return d.filter(k => {
        k = Ad(h[0], w.m(k), b, "fn:filter", !1);
        k = f.value.call(void 0, a, b, c, k);
        if (!k.oa() || !v(k.first().type, 0)) throw Error("XPTY0004: signature of function passed to fn:filter is incompatible.");
        return k.first().value;
      });
    },
    localName: "filter",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 60,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => {
      if (d.F()) return d;
      const f = e.first(),
        h = f.o;
      if (1 !== h.length) throw Error("XPTY0004: signature of function passed to fn:for-each is incompatible.");
      const k = d.value;
      let l;
      return w.create({
        next: n => {
          for (;;) {
            if (!l) {
              var t = k.next(0);
              if (t.done) return t;
              t = Ad(h[0], w.m(t.value), b, "fn:for-each", !1);
              l = f.value.call(void 0, a, b, c, t).value;
            }
            t = l.next(n);
            if (!t.done) return t;
            l = null;
          }
        }
      });
    },
    localName: "for-each",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 59,
      g: 2
    }, {
      type: 60,
      g: 3
    }],
    callFunction: (a, b, c, d, e, f) => {
      if (d.F()) return d;
      const h = f.first(),
        k = h.o;
      if (2 !== k.length) throw Error("XPTY0004: signature of function passed to fn:fold-left is incompatible.");
      return d.N(l => l.reduce((n, t) => {
        n = Ad(k[0], n, b, "fn:fold-left", !1);
        t = Ad(k[1], w.m(t), b, "fn:fold-left", !1);
        return h.value.call(void 0, a, b, c, n, t);
      }, e));
    },
    localName: "fold-left",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }, {
      type: 59,
      g: 2
    }, {
      type: 60,
      g: 3
    }],
    callFunction: (a, b, c, d, e, f) => {
      if (d.F()) return d;
      const h = f.first(),
        k = h.o;
      if (2 !== k.length) throw Error("XPTY0004: signature of function passed to fn:fold-right is incompatible.");
      return d.N(l => l.reduceRight((n, t) => {
        n = Ad(k[0], n, b, "fn:fold-right", !1);
        t = Ad(k[1], w.m(t), b, "fn:fold-right", !1);
        return h.value.call(void 0, a, b, c, t, n);
      }, e));
    },
    localName: "fold-right",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [{
      type: 59,
      g: 2
    }],
    callFunction: (a, b, c, d) => {
      if (!b.Ua) throw Error("serialize() called but no xmlSerializer set in execution parameters.");
      a = d.O();
      if (!a.every(e => v(e.type, 53))) throw Error("Expected argument to fn:serialize to resolve to a sequence of Nodes.");
      return w.m(g(a.map(e => b.Ua.serializeToString(ag(e.value, b, !1))).join(""), 1));
    },
    localName: "serialize",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 1,
      g: 3
    }
  }], ke, [{
    j: [{
      type: 59,
      g: 3
    }, {
      type: 61,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => {
      let f, h;
      return w.create({
        next: () => {
          f || ({
            ic: f,
            ec: h
          } = yq(d, e, c, b));
          try {
            return f.next(0);
          } catch (k) {
            hg(h.value, k);
          }
        }
      });
    },
    localName: "evaluate",
    namespaceURI: "http://fontoxml.com/fontoxpath",
    i: {
      type: 59,
      g: 2
    }
  }, {
    j: [],
    callFunction: () => w.m(g(VERSION, 1)),
    localName: "version",
    namespaceURI: "http://fontoxml.com/fontoxpath",
    i: {
      type: 1,
      g: 3
    }
  }], [{
    j: [{
      type: 23,
      g: 3
    }, {
      type: 5,
      g: 3
    }],
    callFunction: (a, b, c, d, e) => A([d, e], ([f, h]) => {
      const k = c.va(f.value.namespaceURI, f.value.localName, h.value);
      if (null === k) return w.empty();
      f = new Va({
        j: k.j,
        arity: h.value,
        localName: f.value.localName,
        namespaceURI: f.value.namespaceURI,
        i: k.i,
        value: k.callFunction
      });
      return w.m(f);
    }),
    localName: "function-lookup",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      g: 0,
      type: 60
    }
  }, {
    j: [{
      type: 60,
      g: 3
    }],
    callFunction: (a, b, c, d) => A([d], ([e]) => e.Ya() ? w.empty() : w.m(g(new Sa("", e.l, e.D), 23))),
    localName: "function-name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 23,
      g: 0
    }
  }, {
    j: [{
      type: 60,
      g: 3
    }],
    callFunction: (a, b, c, d) => A([d], ([e]) => w.m(g(e.v, 5))),
    localName: "function-arity",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: {
      type: 5,
      g: 3
    }
  }]);
  class Kq {
    constructor(a) {
      this.h = a;
    }
    createAttributeNS(a, b) {
      return this.h.createAttributeNS(a, b);
    }
    createCDATASection(a) {
      return this.h.createCDATASection(a);
    }
    createComment(a) {
      return this.h.createComment(a);
    }
    createDocument() {
      return this.h.createDocument();
    }
    createElementNS(a, b) {
      return this.h.createElementNS(a, b);
    }
    createProcessingInstruction(a, b) {
      return this.h.createProcessingInstruction(a, b);
    }
    createTextNode(a) {
      return this.h.createTextNode(a);
    }
  }
  var Lq = Symbol("IS_XPATH_VALUE_SYMBOL");
  function Mq(a) {
    return (b, c) => {
      b = Vb(new nb(null === c ? new Za() : c), b, Ja(a));
      return {
        [Lq]: !0,
        zb: b
      };
    };
  }
  Jq.forEach(a => {
    og(a.namespaceURI, a.localName, a.j, a.i, a.callFunction);
  });
  function Nq(a) {
    return a && "object" === typeof a && "lookupNamespaceURI" in a ? b => a.lookupNamespaceURI(b || null) : () => null;
  }
  function Oq(a) {
    return ({
      prefix: b,
      localName: c
    }) => b ? null : {
      namespaceURI: a,
      localName: c
    };
  }
  function Pq(a, b, c, d, e, f) {
    if (null === d || void 0 === d) d = d || {};
    const h = e ? {
        jb: e.logger || {
          trace: console.log.bind(console)
        },
        Ma: e.documentWriter,
        kb: e.moduleImports,
        Cb: e.namespaceResolver,
        ac: e.functionNameResolver,
        Ja: e.nodesFactory,
        Ua: e.xmlSerializer
      } : {
        jb: {
          trace: console.log.bind(console)
        },
        kb: {},
        Cb: null,
        Ja: null,
        Ma: null,
        Ua: null
      },
      k = new nb(null === c ? new Za() : c);
    c = h.kb || Object.create(null);
    var l = void 0 === e.defaultFunctionNamespaceURI ? "http://www.w3.org/2005/xpath-functions" : e.defaultFunctionNamespaceURI;
    const n = wq(a, f, h.Cb || Nq(b), d, c, l, h.ac || Oq(l));
    a = b ? Wb(k, b) : w.empty();
    b = !h.Ja && f.Z ? new $e(b) : new Kq(h.Ja);
    c = h.Ma ? new bb(h.Ma) : ab;
    l = h.Ua;
    const t = Object.keys(d).reduce((y, G) => {
      const N = d[G];
      y[`Q{}${G}[0]`] = N && "object" === typeof N && Lq in N ? () => w.create(N.zb) : () => Wb(k, d[G]);
      return y;
    }, Object.create(null));
    let u;
    for (const y of Object.keys(n.ga.Ea)) t[y] || (t[y] = () => (0, n.ga.Ea[y])(u, z));
    u = new cc({
      M: a.first(),
      Aa: 0,
      ta: a,
      ra: t
    });
    const z = new ic(f.debug, f.Ha, k, b, c, e.currentContext, new Map(), h.jb, l);
    return {
      tb: u,
      ub: z,
      ba: n.ba
    };
  }
  function Qq(a, b) {
    const c = {};
    let d = 0,
      e = !1,
      f = null;
    return {
      next: () => {
        if (e) return p;
        for (; d < a.h.length;) {
          const k = a.h[d].key.value;
          if (!f) {
            const l = a.h[d];
            var h = l.value().X({
              default: n => n,
              multiple: () => {
                throw Error(`Serialization error: The value of an entry in a map is expected to be a single item or an empty sequence. Use arrays when putting multiple values in a map. The value of the key ${l.key.value} holds multiple items`);
              }
            }).first();
            if (null === h) {
              c[k] = null;
              d++;
              continue;
            }
            f = Rq(h, b);
          }
          h = f.next(0);
          f = null;
          c[k] = h.value;
          d++;
        }
        e = !0;
        return q(c);
      }
    };
  }
  function Sq(a, b) {
    const c = [];
    let d = 0,
      e = !1,
      f = null;
    return {
      next: () => {
        if (e) return p;
        for (; d < a.h.length;) {
          if (!f) {
            var h = a.h[d]().X({
              default: k => k,
              multiple: () => {
                throw Error("Serialization error: The value of an entry in an array is expected to be a single item or an empty sequence. Use nested arrays when putting multiple values in an array.");
              }
            }).first();
            if (null === h) {
              c[d++] = null;
              continue;
            }
            f = Rq(h, b);
          }
          h = f.next(0);
          f = null;
          c[d++] = h.value;
        }
        e = !0;
        return q(c);
      }
    };
  }
  function Rq(a, b) {
    if (v(a.type, 61)) return Qq(a, b);
    if (v(a.type, 62)) return Sq(a, b);
    if (v(a.type, 23)) {
      const c = a.value;
      return {
        next: () => q(`Q{${c.namespaceURI || ""}}${c.localName}`)
      };
    }
    switch (a.type) {
      case 7:
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
        const c = a.value;
        return {
          next: () => q(Mb(c))
        };
      case 47:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
        const d = a.value;
        return {
          next: () => q(ag(d, b, !1))
        };
      default:
        return {
          next: () => q(a.value)
        };
    }
  }
  var Tq = {
    ANY: 0,
    NUMBER: 1,
    STRING: 2,
    BOOLEAN: 3,
    NODES: 7,
    FIRST_NODE: 9,
    STRINGS: 10,
    MAP: 11,
    ARRAY: 12,
    NUMBERS: 13,
    ALL_RESULTS: 14,
    ASYNC_ITERATOR: 99
  };
  Tq[Tq.ANY] = "ANY";
  Tq[Tq.NUMBER] = "NUMBER";
  Tq[Tq.STRING] = "STRING";
  Tq[Tq.BOOLEAN] = "BOOLEAN";
  Tq[Tq.NODES] = "NODES";
  Tq[Tq.FIRST_NODE] = "FIRST_NODE";
  Tq[Tq.STRINGS] = "STRINGS";
  Tq[Tq.MAP] = "MAP";
  Tq[Tq.ARRAY] = "ARRAY";
  Tq[Tq.NUMBERS] = "NUMBERS";
  Tq[Tq.ALL_RESULTS] = "ALL_RESULTS";
  Tq[Tq.ASYNC_ITERATOR] = "ASYNC_ITERATOR";
  function Uq(a, b, c, d) {
    switch (c) {
      case 3:
        return b.fa();
      case 2:
        return b = qc(b, d).O(), b.length ? b.map(l => jd(l, 1).value).join(" ") : "";
      case 10:
        return b = qc(b, d).O(), b.length ? b.map(l => l.value + "") : [];
      case 1:
        return b = b.first(), null !== b && v(b.type, 2) ? b.value : NaN;
      case 9:
        b = b.first();
        if (null === b) return null;
        if (!v(b.type, 53)) throw Error("Expected XPath " + fg(a) + " to resolve to Node. Got " + Da[b.type]);
        return ag(b.value, d, !1);
      case 7:
        b = b.O();
        if (!b.every(l => v(l.type, 53))) throw Error("Expected XPath " + fg(a) + " to resolve to a sequence of Nodes.");
        return b.map(l => ag(l.value, d, !1));
      case 11:
        b = b.O();
        if (1 !== b.length) throw Error("Expected XPath " + fg(a) + " to resolve to a single map.");
        b = b[0];
        if (!v(b.type, 61)) throw Error("Expected XPath " + fg(a) + " to resolve to a map");
        return Qq(b, d).next(0).value;
      case 12:
        b = b.O();
        if (1 !== b.length) throw Error("Expected XPath " + fg(a) + " to resolve to a single array.");
        b = b[0];
        if (!v(b.type, 62)) throw Error("Expected XPath " + fg(a) + " to resolve to an array");
        return Sq(b, d).next(0).value;
      case 13:
        return b.O().map(l => {
          if (!v(l.type, 2)) throw Error("Expected XPath " + fg(a) + " to resolve to numbers");
          return l.value;
        });
      case 99:
        const e = b.value;
        let f = null,
          h = !1;
        const k = () => {
          for (; !h;) {
            if (!f) {
              var l = e.next(0);
              if (l.done) {
                h = !0;
                break;
              }
              f = Rq(l.value, d);
            }
            l = f.next(0);
            f = null;
            return l;
          }
          return Promise.resolve({
            done: !0,
            value: null
          });
        };
        return "asyncIterator" in Symbol ? {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: () => new Promise(l => l(k())).catch(l => {
            hg(a, l);
          })
        } : {
          next: () => new Promise(l => l(k()))
        };
      case 14:
        return b.O().map(l => Rq(l, d).next(0).value);
      default:
        return b = b.O(), b.every(l => v(l.type, 53) && !v(l.type, 47)) ? (b = b.map(l => ag(l.value, d, !1)), 1 === b.length ? b[0] : b) : 1 === b.length ? (b = b[0], v(b.type, 62) ? Sq(b, d).next(0).value : v(b.type, 61) ? Qq(b, d).next(0).value : pc(b, d).first().value) : qc(w.create(b), d).O().map(l => l.value);
    }
  }
  let Vq = !1,
    Wq = null;
  var Xq = {
    getPerformanceSummary() {
      const a = Wq.getEntriesByType("measure").filter(b => b.name.startsWith("XPath: "));
      return Array.from(a.reduce((b, c) => {
        var d = c.name.substring(7);
        b.has(d) ? (d = b.get(d), d.times += 1, d.totalDuration += c.duration) : b.set(d, {
          xpath: d,
          times: 1,
          totalDuration: c.duration,
          average: 0
        });
        return b;
      }, new Map()).values()).map(b => {
        b.average = b.totalDuration / b.times;
        return b;
      }).sort((b, c) => c.totalDuration - b.totalDuration);
    },
    setPerformanceImplementation(a) {
      Wq = a;
    },
    startProfiling() {
      if (null === Wq) throw Error("Performance API object must be set using `profiler.setPerformanceImplementation` before starting to profile");
      Wq.clearMarks();
      Wq.clearMeasures();
      Vq = !0;
    },
    stopProfiling() {
      Vq = !1;
    }
  };
  let Yq = 0;
  var Zq = {
    XPATH_3_1_LANGUAGE: "XPath3.1",
    XQUERY_3_1_LANGUAGE: "XQuery3.1",
    XQUERY_UPDATE_3_1_LANGUAGE: "XQueryUpdate3.1"
  };
  const $q = (a, b, c, d, e, f) => {
    e = e || 0;
    if (!a || "string" !== typeof a && !("nodeType" in a)) throw new TypeError("Failed to execute 'evaluateXPath': xpathExpression must be a string or an element depicting an XQueryX DOM tree.");
    f = f || {};
    let h, k;
    try {
      const n = Pq(a, b, c || null, d || {}, f, {
        sa: "XQueryUpdate3.1" === f.language,
        Z: "XQuery3.1" === f.language || "XQueryUpdate3.1" === f.language,
        debug: !!f.debug,
        Ha: !!f.disableCache
      });
      var l = n.tb;
      h = n.ub;
      k = n.ba;
    } catch (n) {
      hg(a, n);
    }
    if (k.I) throw Error("XUST0001: Updating expressions should be evaluated as updating expressions");
    if (3 === e && b && "object" === typeof b && "nodeType" in b && (c = k.D(), b = Ya(b), null !== c && !b.includes(c))) return !1;
    try {
      b = a;
      Vq && ("string" !== typeof b && (b = fg(b)), Wq.mark(`${b}${0 === Yq ? "" : "@" + Yq}`), Yq++);
      const n = C(k, l, h),
        t = Uq(a, n, e, h);
      e = a;
      Vq && ("string" !== typeof e && (e = fg(e)), Yq--, l = `${e}${0 === Yq ? "" : "@" + Yq}`, Wq.measure(`XPath: ${e}`, l), Wq.clearMarks(l));
      return t;
    } catch (n) {
      hg(a, n);
    }
  };
  Object.assign($q, {
    jc: 14,
    ANY_TYPE: 0,
    Lb: 12,
    Mb: 99,
    BOOLEAN_TYPE: 3,
    Ob: 9,
    Rb: 11,
    Tb: 7,
    Ub: 13,
    NUMBER_TYPE: 1,
    Vb: 10,
    STRING_TYPE: 2,
    kc: "XPath3.1",
    lc: "XQuery3.1",
    Yb: "XQueryUpdate3.1"
  });
  Object.assign($q, {
    ALL_RESULTS_TYPE: 14,
    ANY_TYPE: 0,
    ARRAY_TYPE: 12,
    ASYNC_ITERATOR_TYPE: 99,
    BOOLEAN_TYPE: 3,
    FIRST_NODE_TYPE: 9,
    MAP_TYPE: 11,
    NODES_TYPE: 7,
    NUMBERS_TYPE: 13,
    NUMBER_TYPE: 1,
    STRINGS_TYPE: 10,
    STRING_TYPE: 2,
    XPATH_3_1_LANGUAGE: "XPath3.1",
    XQUERY_3_1_LANGUAGE: "XQuery3.1",
    XQUERY_UPDATE_3_1_LANGUAGE: "XQueryUpdate3.1"
  });
  function ar(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Mb, e);
  }
  function br(a, b, c, d) {
    return {
      pendingUpdateList: a.da.map(e => e.h(d)),
      xdmValue: Uq(b, w.create(a.J), c, d)
    };
  }
  async function cr(a, b, c, d, e) {
    e = e || {};
    Ok();
    let f, h;
    try {
      const n = Pq(a, b, c || null, d || {}, e || {}, {
        sa: !0,
        Z: !0,
        debug: !!e.debug,
        Ha: !!e.disableCache
      });
      var k = n.tb;
      f = n.ub;
      h = n.ba;
    } catch (n) {
      hg(a, n);
    }
    if (!h.I) {
      k = [];
      a = ar(a, b, c, d, Object.assign(Object.assign({}, e), {
        language: "XQueryUpdate3.1"
      }));
      for (b = await a.next(); !b.done; b = await a.next()) k.push(b.value);
      return Promise.resolve({
        pendingUpdateList: [],
        xdmValue: k
      });
    }
    let l;
    try {
      l = h.s(k, f).next(0);
    } catch (n) {
      hg(a, n);
    }
    return br(l.value, a, e.returnType, f);
  }
  function dr(a, b, c, d, e) {
    e = e || {};
    Ok();
    let f, h, k;
    try {
      const n = Pq(a, b, c || null, d || {}, e || {}, {
        sa: !0,
        Z: !0,
        debug: !!e.debug,
        Ha: !!e.disableCache
      });
      f = n.tb;
      h = n.ub;
      k = n.ba;
    } catch (n) {
      hg(a, n);
    }
    if (!k.I) return {
      pendingUpdateList: [],
      xdmValue: $q(a, b, c, d, e.i, Object.assign(Object.assign({}, e), {
        language: $q.Yb
      }))
    };
    let l;
    try {
      l = k.s(f, h).next(0);
    } catch (n) {
      hg(a, n);
    }
    return br(l.value, a, e.returnType, h);
  }
  function er(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Lb, e);
  }
  function fr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.BOOLEAN_TYPE, e);
  }
  function gr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Ob, e);
  }
  function hr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Rb, e);
  }
  function ir(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Tb, e);
  }
  function jr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.NUMBER_TYPE, e);
  }
  function kr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Ub, e);
  }
  function lr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.STRING_TYPE, e);
  }
  function mr(a, b, c, d, e) {
    return $q(a, b, c, d, $q.Vb, e);
  }
  function nr(a, b, c, d) {
    b = new nb(b ? b : new Za());
    d = d ? new bb(d) : ab;
    c = c ? c = new Kq(c) : null;
    a = a.map(Rj);
    lf(a, b, c, d);
  }
  function Y(a, b, c) {
    return {
      code: a,
      ua: b,
      H: c,
      isAstAccepted: !0
    };
  }
  function or(a) {
    return {
      isAstAccepted: !1,
      reason: a
    };
  }
  function Z(a, b) {
    return a.isAstAccepted ? b(a) : a;
  }
  function pr(a, b) {
    return a.isAstAccepted ? b(a) : [a, null];
  }
  function qr(a, b, c) {
    return Z(a, d => {
      switch (d.ua.type) {
        case 0:
          return d;
        case 1:
          return Z(rr(c, d, "nodes"), e => Z(rr(c, b, "contextItem"), f => Y(`(function () {
							const { done, value } = ${e.code}(${f.code}).next();
							return done ? null : value;
						})()`, {
            type: 0
          }, [...e.H, ...f.H])));
        default:
          throw Error(`invalid generated code type to convert to value: ${d.ua.type}`);
      }
    });
  }
  function sr(a, b, c, d) {
    a = qr(a, c, d);
    return b && 0 === b.type && 3 === b.g ? a : Z(a, e => Y(`!!${e.code}`, {
      type: 0
    }, e.H));
  }
  function tr(a, b, c) {
    return b ? a.isAstAccepted && 0 !== a.ua.type ? or("Atomization only implemented for single value") : v(b.type, 1) ? a : v(b.type, 47) ? Z(rr(c, a, "attr"), d => Y(`(${d.code} ? domFacade.getData(${d.code}) : null)`, {
      type: 0
    }, d.H)) : or("Atomization only implemented for string and attribute") : or("Can not atomize value if type was not annotated");
  }
  function ur(a, b, c, d) {
    a = qr(a, c, d);
    d = tr(a, b, d);
    return wc(b) ? Z(d, e => Y(`${e.code} ?? ''`, {
      type: 0
    }, e.H)) : d;
  }
  function vr(a, b, c) {
    return Z(rr(c, a, "node"), d => 1 === d.ua.type ? d : b && !v(b.type, 53) ? or("Can not evaluate to node if expression does not result in nodes") : Y(`(function () {
				if (${d.code} !== null && !${d.code}.nodeType) {
					throw new Error('XPDY0050: The result of the expression was not a node');
				}
				return ${d.code};
			})()`, {
      type: 0
    }, d.H));
  }
  function wr(a, b, c, d) {
    return Z(a, e => {
      switch (e.ua.type) {
        case 1:
          return Z(rr(d, e, "nodes"), f => Z(rr(d, c, "contextItem"), h => Y(`Array.from(${f.code}(${h.code}))`, {
            type: 0
          }, [...f.H, ...h.H])));
        case 0:
          return Z(rr(d, vr(e, b, d), "node"), f => Y(`(${f.code} === null ? [] : [${f.code}])`, {
            type: 0
          }, f.H));
        default:
          return or("Unsupported code type to evaluate to nodes");
      }
    });
  }
  function xr(a, b) {
    return Z(a, c => Z(b, d => {
      if (0 !== c.ua.type || 0 !== d.ua.type) throw Error("can only use emitAnd with value expressions");
      return Y(`${c.code} && ${d.code}`, {
        type: 0
      }, [...c.H, ...d.H]);
    }));
  }
  function yr(a, b, c, d) {
    return (a = J(a, [b, "*"])) ? d.h(a, c, d) : [or(`${b} expression not found`), null];
  }
  const $t = {
      equalOp: "eqOp",
      notEqualOp: "neOp",
      lessThanOrEqualOp: "leOp",
      lessThanOp: "ltOp",
      greaterThanOrEqualOp: "geOp",
      greaterThanOp: "gtOp"
    },
    au = {
      eqOp: "eqOp",
      neOp: "neOp",
      leOp: "geOp",
      ltOp: "gtOp",
      geOp: "leOp",
      gtOp: "ltOp"
    };
  function bu(a, b, c, d) {
    const e = I(J(a, ["firstOperand", "*"]), "type"),
      f = I(J(a, ["secondOperand", "*"]), "type");
    if (!e || !f) return or("Can not generate code for value compare without both types");
    var h = [47, 1];
    if (!h.includes(e.type) || !h.includes(f.type)) return or(`Unsupported types in compare: [${Da[e.type]}, ${Da[f.type]}]`);
    h = new Map([["eqOp", "==="], ["neOp", "!=="]]);
    if (!h.has(b)) return or(b + " not yet implemented");
    const k = h.get(b);
    [b] = yr(a, "firstOperand", c, d);
    b = qr(b, c, d);
    b = tr(b, e, d);
    return Z(rr(d, b, "first"), l => {
      var [n] = yr(a, "secondOperand", c, d);
      n = qr(n, c, d);
      n = tr(n, f, d);
      return Z(rr(d, n, "second"), t => {
        const u = [];
        wc(e) && u.push(`${l.code} === null`);
        wc(f) && u.push(`${t.code} === null`);
        return Y(`(${u.length ? `${u.join(" || ")} ? null : ` : ""}${l.code} ${k} ${t.code})`, {
          type: 0
        }, [...l.H, ...t.H]);
      });
    });
  }
  function cu(a, b, c, d, e, f) {
    var h = I(J(a, [b, "*"]), "type");
    const k = I(J(a, [c, "*"]), "type");
    if (!h || !k) return or("Can not generate code for general compare without both types");
    var l = [47, 1];
    if (!l.includes(h.type) || !l.includes(k.type)) return or(`Unsupported types in compare: [${Da[h.type]}, ${Da[k.type]}]`);
    l = new Map([["eqOp", "==="], ["neOp", "!=="]]);
    if (!l.has(d)) return or(d + " not yet implemented");
    const n = l.get(d);
    [b] = yr(a, b, e, f);
    b = qr(b, e, f);
    h = tr(b, h, f);
    return Z(rr(f, h, "single"), t => {
      const [u] = yr(a, c, e, f);
      return Z(rr(f, u, "multiple"), z => {
        if (1 !== z.ua.type) return or("can only generate general compare for a single value and a generator");
        const y = du(f, eu(f, "n")),
          G = tr(y, k, f);
        return Z(e, N => Z(G, U => Y(`(function () {
									for (const ${y.code} of ${z.code}(${N.code})) {
										${U.H.join("\n")}
										if (${U.code} ${n} ${t.code}) {
											return true;
										}
									}
									return false;
								})()`, {
          type: 0
        }, [...t.H, ...y.H, ...N.H, ...z.H])));
      });
    });
  }
  function fu(a) {
    return JSON.stringify(a).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  const lu = {
      "false#0": gu,
      "local-name#0": hu,
      "local-name#1": hu,
      "name#0": iu,
      "name#1": iu,
      "not#1": ju,
      "true#0": ku
    },
    mu = {
      ["http://fontoxml.com/fontoxpath"]: ["version#0"],
      [""]: ["root#1", "path#1"]
    };
  function nu(a, b, c, d) {
    const [e] = d.h(a, c, d);
    a = I(a, "type");
    if (b ? 2 === b.g || 1 === b.g : 1) return or("Not supported: sequence arguments with multiple items");
    if (v(b.type, 53)) return b = qr(e, c, d), vr(b, a, d);
    switch (b.type) {
      case 59:
        return qr(e, c, d);
      case 0:
        return sr(e, a, c, d);
      case 1:
        return ur(e, a, c, d);
    }
    return or(`Argument types not supported: ${a ? Da[a.type] : "unknown"} -> ${Da[b.type]}`);
  }
  function ou(a, b, c, d) {
    if (a.length !== b.length || b.some(l => 4 === l)) return or("Not supported: variadic function or mismatch in argument count");
    if (0 === a.length) return Y("", {
      type: 0
    }, []);
    const [e, ...f] = a,
      [h, ...k] = b;
    a = rr(d, nu(e, h, c, d), "arg");
    return 0 === f.length ? a : Z(a, l => {
      const n = ou(f, k, c, d);
      return Z(n, t => Y(`${l.code}, ${t.code}`, {
        type: 0
      }, [...l.H, ...t.H]));
    });
  }
  function pu(a, b) {
    return Z(a, c => (b ? 2 === b.g || 1 === b.g : 1) || ![0, 1].includes(b.type) && !v(b.type, 53) ? or(`Function return type ${Da[b.type]} not supported`) : c);
  }
  function qu(a, b, c) {
    const {
        localName: d,
        namespaceURI: e
      } = Kg(F(a, "functionName")),
      f = K(F(a, "arguments"), "*");
    var h = f.length;
    const k = `${d}#${h}`,
      l = e === c.D;
    if (l) {
      const n = lu[k];
      if (void 0 !== n) return n(a, b, c);
    }
    if ((a = mu[l ? "" : e]) && !a.includes(k)) return or(`Not supported: built-in function not on allow list: ${k}`);
    h = ng(e, d, h);
    if (!h) return or(`Unknown function / arity: ${k}`);
    if (h.I) return or("Not supported: updating functions");
    b = ou(f, h.j, b, c);
    b = Z(b, n => Y(`runtimeLib.callFunction(domFacade, ${fu(e)}, ${fu(d)}, [${n.code}], options)`, {
      type: 0
    }, n.H));
    return pu(b, h.i);
  }
  function ru(a, b) {
    return Z(rr(b, a, "contextItem"), c => Y(c.code, {
      type: 0
    }, [...c.H, `if (${c.code} === undefined || ${c.code} === null) {
					throw errXPDY0002('The function which was called depends on dynamic context, which is absent.');
				}`]));
  }
  function su(a, b, c, d) {
    if ((a = J(a, ["arguments", "*"])) && "contextItemExpr" !== a[0]) {
      const e = I(a, "type");
      if (!e || !v(e.type, 53)) return or("name function only implemented if arg is a node");
      [a] = c.h(a, b, c);
    } else a = ru(b, c);
    b = qr(a, b, c);
    return Z(rr(c, b, "arg"), e => Y(`(${e.code} ? ${d(e.code)} : '')`, {
      type: 0
    }, e.H));
  }
  function iu(a, b, c) {
    return su(a, b, c, d => `(((${d}.prefix || '').length !== 0 ? ${d}.prefix + ':' : '')
		+ (${d}.localName || ${d}.target || ''))`);
  }
  function hu(a, b, c) {
    return su(a, b, c, d => `(${d}.localName || ${d}.target || '')`);
  }
  function ju(a, b, c) {
    var d = J(a, ["arguments", "*"]);
    a = I(d, "type");
    [d] = c.h(d, b, c);
    b = sr(d, a, b, c);
    return Z(b, e => Y(`!${e.code}`, {
      type: 0
    }, e.H));
  }
  function gu() {
    return Y("false", {
      type: 0
    }, []);
  }
  function ku() {
    return Y("true", {
      type: 0
    }, []);
  }
  function tu(a, b, c, d) {
    const [e, f] = yr(a, "firstOperand", c, d);
    var h = I(J(a, ["firstOperand", "*"]), "type");
    h = sr(e, h, c, d);
    const [k, l] = yr(a, "secondOperand", c, d);
    h = Z(h, t => {
      var u = I(J(a, ["secondOperand", "*"]), "type");
      u = sr(k, u, c, d);
      return Z(u, z => Y(`(${t.code} ${b} ${z.code})`, {
        type: 0
      }, [...t.H, ...z.H]));
    });
    const n = "&&" === b ? yh(f, l) : f === l ? f : null;
    return [h, n];
  }
  function uu(a, b, c) {
    return Z(a, d => Z(b, e => Z(c, f => Y(`for (${d.code}) {
						${e.H.join("\n")}
						if (!(${e.code})) {
							continue;
						}
						${f.H.join("\n")}
						${f.code}
					}`, {
      type: 2
    }, d.H))));
  }
  function vu(a, b, c, d, e) {
    const f = b ? `, "${b}"` : "";
    b = Z(d, h => Z(e, k => Y(`let ${h.code} = domFacade.getFirstChild(${k.code}${f});
							${h.code};
							${h.code} = domFacade.getNextSibling(${h.code}${f})`, {
      type: 2
    }, [...h.H, ...k.H])));
    return uu(b, a, c);
  }
  function wu(a, b, c, d, e) {
    const f = yh(b, "type-2"),
      h = Z(e, k => Y(`(${k.code} && ${k.code}.nodeType === /*ELEMENT_NODE*/ ${1} ? domFacade.getAllAttributes(${k.code}${f ? `, "${f}"` : ""}) : [])`, {
        type: 0
      }, k.H));
    b = Z(d, k => Z(h, l => Y(`const ${k.code} of ${l.code}`, {
      type: 2
    }, [...k.H, ...l.H])));
    return uu(b, a, c);
  }
  function xu(a, b, c, d, e) {
    const f = b ? `, "${b}"` : "";
    b = Z(e, h => Y(`domFacade.getParentNode(${h.code}${f})`, {
      type: 0
    }, h.H));
    return yu(d, b, a, c);
  }
  function yu(a, b, c, d) {
    const e = xr(a, c);
    return Z(a, f => Z(b, h => Z(e, k => Z(d, l => Y(`const ${f.code} = ${h.code};
						${k.H.join("\n")}
						if (${k.code}) {
							${l.H.join("\n")}
							${l.code}
						}`, {
      type: 2
    }, [...f.H, ...h.H])))));
  }
  function zu(a, b, c, d, e, f) {
    a = H(a);
    switch (a) {
      case "attribute":
        return [wu(b, c, d, e, f), "type-1"];
      case "child":
        return [vu(b, c, d, e, f), null];
      case "parent":
        return [xu(b, c, d, e, f), null];
      case "self":
        return [yu(e, f, b, d), c];
      default:
        return [or(`Unsupported: the ${a} axis`), null];
    }
  }
  const Au = {
    Wb: "textTest",
    Nb: "elementTest",
    Sb: "nameTest",
    Xb: "Wildcard",
    Kb: "anyKindTest"
  };
  var Bu = Object.values(Au);
  function Cu(a) {
    return [Z(a, b => Y(`(${b.code}.nodeType === /*TEXT_NODE*/ ${3} ||
				${b.code}.nodeType === /* CDATA_SECTION_NODE */ ${4})`, {
      type: 0
    }, [])), "type-3"];
  }
  function Du(a, b) {
    if (null === a.namespaceURI && "*" !== a.prefix) {
      b = b.$(a.prefix || "") || null;
      if (!b && a.prefix) throw Error(`XPST0081: The prefix ${a.prefix} could not be resolved.`);
      a.namespaceURI = b;
    }
  }
  function Eu(a, b, c, d) {
    Du(a, d);
    const e = a.prefix,
      f = a.namespaceURI,
      h = a.localName;
    return pr(c, k => {
      var l = b ? Y(`${k.code}.nodeType
						&& (${k.code}.nodeType === /*ELEMENT_NODE*/ ${1}
						|| ${k.code}.nodeType === /*ATTRIBUTE_NODE*/ ${2})`, {
        type: 0
      }, []) : Y(`${k.code}.nodeType
						&& ${k.code}.nodeType === /*ELEMENT_NODE*/ ${1}`, {
        type: 0
      }, []);
      if ("*" === e) return "*" === h ? [l, b ? "type-1-or-type-2" : "type-1"] : [xr(l, Y(`${k.code}.localName === ${fu(h)}`, {
        type: 0
      }, [])), `name-${h}`];
      l = "*" === h ? l : xr(l, Y(`${k.code}.localName === ${fu(h)}`, {
        type: 0
      }, []));
      var n = Y(fu(f), {
        type: 0
      }, []);
      n = "" === e && b ? Z(n, t => Y(`${k.code}.nodeType === /*ELEMENT_NODE*/ ${1} ? ${t.code} : null`, {
        type: 0
      }, t.H)) : n;
      n = Z(n, t => Y(`(${k.code}.namespaceURI || null) === ((${t.code}) || null)`, {
        type: 0
      }, t.H));
      return [xr(l, n), `name-${h}`];
    });
  }
  function Fu(a, b, c) {
    const d = (a = F(a, "elementName")) && F(a, "star");
    if (null === a || d) return [Z(b, e => Y(`${e.code}.nodeType === /*ELEMENT_NODE*/ ${1}`, {
      type: 0
    }, [])), "type-1"];
    a = Kg(F(a, "QName"));
    return Eu(a, !1, b, c);
  }
  function Gu(a) {
    return [Z(a, b => Y(`!!${b.code}.nodeType`, {
      type: 0
    }, [])), null];
  }
  function Hu(a, b, c, d) {
    var e = a[0];
    switch (e) {
      case Au.Nb:
        return Fu(a, c, d);
      case Au.Wb:
        return Cu(c);
      case Au.Sb:
        return Eu(Kg(a), b, c, d);
      case Au.Xb:
        return F(a, "star") ? (e = F(a, "uri"), null !== e ? a = Eu({
          localName: "*",
          namespaceURI: H(e),
          prefix: ""
        }, b, c, d) : (e = F(a, "NCName"), a = "star" === F(a, "*")[0] ? Eu({
          localName: H(e),
          namespaceURI: null,
          prefix: "*"
        }, b, c, d) : Eu({
          localName: "*",
          namespaceURI: null,
          prefix: H(e)
        }, b, c, d))) : a = Eu({
          localName: "*",
          namespaceURI: null,
          prefix: "*"
        }, b, c, d), a;
      case Au.Kb:
        return Gu(c);
      default:
        return [or(`Test not implemented: '${e}`), null];
    }
  }
  function Iu(a, b, c) {
    const [d, e] = c.h(a, b, c);
    return [sr(d, I(a, "type"), b, c), e];
  }
  function Ju(a, b, c) {
    a = a ? K(a, "*") : [];
    const [d, e] = a.reduce(([f, h], k) => {
      if (!f) return Iu(k, b, c);
      let l = h;
      return pr(f, n => {
        const [t, u] = Iu(k, b, c);
        l = yh(h, u);
        return [Z(t, z => Y(`${n.code} && ${z.code}`, {
          type: 0
        }, [...n.H, ...z.H])), l];
      });
    }, [null, null]);
    return [d ? Z(d, f => Y(`(function () {
							${f.H.join("\n")}
							return ${f.code};
						})()`, {
      type: 0
    }, [])) : null, e];
  }
  function Ku(a, b, c, d) {
    if (0 === a.length) return [Z(c, y => Y(`yield ${y.code};`, {
      type: 2
    }, y.H)), null];
    const [e, ...f] = a;
    if (0 < K(e, "lookup").length) return [or("Unsupported: lookups"), null];
    const h = du(d, eu(d, "contextItem"));
    a = F(e, "predicates");
    const [k, l] = Ju(a, h, d);
    if (a = F(e, "xpathAxis")) {
      var n = F(e, Bu);
      if (!n) return [or("Unsupported test in step"), null];
      var t = H(a);
      b = "attribute" === t || "self" === t && b;
      const [y, G] = Hu(n, b, h, d);
      n = null === k ? y : xr(y, k);
      t = yh(G, l);
      [b] = Ku(f, b, h, d);
      return zu(a, n, t, b, h, c);
    }
    a = J(e, ["filterExpr", "*"]);
    if (!a) return [or("Unsupported: unknown step type"), null];
    const [u, z] = d.h(a, c, d);
    return [Z(u, y => {
      const G = 0 === f.length ? Y("", {
          type: 2
        }, []) : Y(`if (${h.code} !== null && !${h.code}.nodeType) {
									throw new Error('XPTY0019: The result of E1 in a path expression E1/E2 should evaluate to a sequence of nodes.');
								}`, {
          type: 2
        }, []),
        [N] = Ku(f, !0, h, d),
        U = null === k ? N : Z(k, ca => Z(N, Ga => Y(`if (${ca.code}) {
									${Ga.H.join("\n")}
									${Ga.code}
								}`, {
          type: 2
        }, ca.H)));
      return Z(U, ca => {
        switch (y.ua.type) {
          case 1:
            return Z(c, Ga => Y(`for (const ${h.code} of ${y.code}(${Ga.code})) {
									${ca.H.join("\n")}
									${ca.code}
								}`, {
              type: 2
            }, [...h.H, ...y.H, ...G.H]));
          case 0:
            return Y(`const ${h.code} = ${y.code};
							${G.code}
							if (${h.code} !== null) {
								${ca.H.join("\n")}
								${ca.code}
							}`, {
              type: 2
            }, [...h.H, ...y.H, ...G.H]);
          default:
            return or("Unsupported generated code type for filterExpr");
        }
      });
    }), z];
  }
  function Lu(a) {
    return Z(a, b => Y(`(function () {
				let n = ${b.code};
				while (n.nodeType !== /*DOCUMENT_NODE*/${9}) {
					n = domFacade.getParentNode(n);
					if (n === null) {
						throw new Error('XPDY0050: the root node of the context node is not a document node.');
					}
				}
				return n;
			})()`, {
      type: 0
    }, b.H));
  }
  function Mu(a, b, c) {
    return pr(b, d => {
      if (0 < K(a, "lookup").length) return [or("Unsupported: lookups"), null];
      var e = F(a, "predicates");
      const [f, h] = Ju(e, d, c);
      e = F(a, Bu);
      if (!e) return [or("Unsupported test in step"), null];
      const [k, l] = Hu(e, !0, d, c);
      e = null === f ? k : xr(k, f);
      const n = yh(l, h);
      return [Z(e, t => Y(`((${t.code}) ? ${d.code} : null)`, {
        type: 0
      }, [...d.H, ...t.H])), n];
    });
  }
  function Nu(a, b, c) {
    const d = K(a, "stepExpr");
    if (1 === d.length) {
      const k = F(d[0], "xpathAxis");
      if (k && "self" === H(k)) return Mu(d[0], b, c);
    }
    const e = du(c, eu(c, "contextItem"));
    b = (a = F(a, "rootExpr")) ? rr(c, Lu(e), "root") : e;
    const [f, h] = Ku(d, !a, b, c);
    return [Z(f, k => Y(`(function* (${e.code}) {
			${k.H.join("\n")}
			${k.code}
		})`, {
      type: 1
    }, [])), h];
  }
  function Ou(a, b, c) {
    const d = a[0];
    switch (d) {
      case "contextItemExpr":
        return [b, null];
      case "pathExpr":
        return Nu(a, b, c);
      case "andOp":
        return tu(a, "&&", b, c);
      case "orOp":
        return tu(a, "||", b, c);
      case "stringConstantExpr":
        return a = F(a, "value")[1] || "", a = fu(a), [Y(a, {
          type: 0
        }, []), null];
      case "equalOp":
      case "notEqualOp":
      case "lessThanOrEqualOp":
      case "lessThanOp":
      case "greaterThanOrEqualOp":
      case "greaterThanOp":
      case "eqOp":
      case "neOp":
      case "ltOp":
      case "leOp":
      case "gtOp":
      case "geOp":
      case "isOp":
      case "nodeBeforeOp":
      case "nodeAfterOp":
        a: switch (d) {
          case "eqOp":
          case "neOp":
          case "ltOp":
          case "leOp":
          case "gtOp":
          case "geOp":
          case "isOp":
            a = bu(a, d, b, c);
            break a;
          case "equalOp":
          case "notEqualOp":
          case "lessThanOrEqualOp":
          case "lessThanOp":
          case "greaterThanOrEqualOp":
          case "greaterThanOp":
            const e = I(J(a, ["firstOperand", "*"]), "type"),
              f = I(J(a, ["secondOperand", "*"]), "type");
            a = e && f ? 3 === e.g && 3 === f.g ? bu(a, $t[d], b, c) : 3 === e.g ? cu(a, "firstOperand", "secondOperand", $t[d], b, c) : 3 === f.g ? cu(a, "secondOperand", "firstOperand", au[$t[d]], b, c) : or("General comparison for sequences is not implemented") : or("types of compare are not known");
            break a;
          default:
            a = or(`Unsupported compare type: ${d}`);
        }
        return [a, null];
      case "functionCallExpr":
        return [qu(a, b, c), null];
      default:
        return [or(`Unsupported: the base expression '${d}'.`), null];
    }
  }
  function rr(a, b, c) {
    return Z(b, d => {
      var e = a.o.get(d);
      e || (e = eu(a, c), e = Y(e, d.ua, [...d.H, `const ${e} = ${d.code};`]), a.o.set(d, e), a.o.set(e, e));
      return e;
    });
  }
  function eu(a, b = "v") {
    const c = a.v.get(b) || 0;
    a.v.set(b, c + 1);
    return `${b}${c}`;
  }
  function du(a, b) {
    b = Y(b, {
      type: 0
    }, []);
    a.o.set(b, b);
    return b;
  }
  var Pu = class {
    constructor(a, b) {
      this.o = new Map();
      this.v = new Map();
      this.$ = a;
      this.D = b;
      this.h = Ou;
    }
  };
  function Qu(a) {
    const b = K(a, "*");
    if ("pathExpr" === a[0]) return !0;
    for (const c of b) if (Qu(c)) return !0;
    return !1;
  }
  function Ru(a, b, c) {
    c = c || {};
    b = b || 0;
    if ("string" === typeof a) {
      a = Pk(a);
      var d = {
        Z: "XQuery3.1" === c.language || "XQueryUpdate3.1" === c.language,
        debug: !1
      };
      try {
        var e = qq(a, d);
      } catch (h) {
        hg(a, h);
      }
    } else e = Kk(a);
    a = F(e, "mainModule");
    if (!a) return or("Unsupported: XQuery Library modules are not supported.");
    if (F(a, "prolog")) return or("Unsupported: XQuery Prologs are not supported.");
    d = void 0 === c.defaultFunctionNamespaceURI ? "http://www.w3.org/2005/xpath-functions" : c.defaultFunctionNamespaceURI;
    a = new Pu(c.namespaceResolver || Nq(null), d);
    c = new rh(new Cg(new qg(a.$, {}, d, c.functionNameResolver || Oq("http://www.w3.org/2005/xpath-functions"))));
    O(e, c);
    if (c = F(e, "mainModule")) {
      if (F(c, "prolog")) a = or("Unsupported: XQuery.");else {
        var f = J(c, ["queryBody", "*"]);
        c = du(a, "contextItem");
        [d] = a.h(f, c, a);
        b: switch (f = I(f, "type"), b) {
          case 9:
            b = qr(d, c, a);
            a = vr(b, f, a);
            break b;
          case 7:
            a = wr(d, f, c, a);
            break b;
          case 3:
            a = sr(d, f, c, a);
            break b;
          case 2:
            a = ur(d, f, c, a);
            break b;
          default:
            a = or(`Unsupported: the return type '${b}'.`);
        }
        a.isAstAccepted && (a = `
		${a.H.join("\n")}
		return ${a.code};`, b = "\n\treturn (contextItem, domFacade, runtimeLib, options) => {\n\t\tconst {\n\t\t\terrXPDY0002,\n\t\t} = runtimeLib;", Qu(e) && (b += '\n\t\tif (!contextItem) {\n\t\t\tthrow errXPDY0002("Context is needed to evaluate the given path expression.");\n\t\t}\n\n\t\tif (!contextItem.nodeType) {\n\t\t\tthrow new Error("Context item must be subtype of node().");\n\t\t}\n\t\t'), a = {
          code: b + (a + "}\n//# sourceURL=generated.js"),
          isAstAccepted: !0
        });
      }
    } else a = or("Unsupported: Can not execute a library module.");
    return a;
  }
  class Su extends Error {
    constructor(a, b, c) {
      var d = a.stack;
      d && (d.includes(a.message) && (d = d.substr(d.indexOf(a.message) + a.message.length).trim()), d = d.split("\n"), d.splice(10), d = d.map(e => e.startsWith("    ") || e.startsWith("\t") ? e : `    ${e}`), d = d.join("\n"));
      super(`Custom XPath function Q{${c}}${b} raised:\n${a.message}\n${d}`);
    }
  }
  function Tu(a, b, c) {
    return 0 === b.g ? a.F() ? null : Rq(a.first(), c).next(0).value : 2 === b.g || 1 === b.g ? a.O().map(d => {
      if (v(d.type, 47)) throw Error("Cannot pass attribute nodes to custom functions");
      return Rq(d, c).next(0).value;
    }) : Rq(a.first(), c).next(0).value;
  }
  function Uu(a) {
    if ("object" === typeof a) return a;
    a = a.split(":");
    if (2 !== a.length) throw Error("Do not register custom functions in the default function namespace");
    const [b, c] = a;
    a = pg[b];
    if (!a) {
      a = `generated_namespace_uri_${b}`;
      if (pg[b]) throw Error("Prefix already registered: Do not register the same prefix twice.");
      pg[b] = a;
    }
    return {
      localName: c,
      namespaceURI: a
    };
  }
  function Vu(a, b, c, d) {
    const {
      namespaceURI: e,
      localName: f
    } = Uu(a);
    if (!e) throw vg();
    const h = b.map(l => Ja(l)),
      k = Ja(c);
    og(e, f, h, k, function (l, n, t) {
      var u = Array.from(arguments);
      u.splice(0, 3);
      u = u.map((G, N) => Tu(G, h[N], n));
      const z = {
        currentContext: n.o,
        domFacade: n.h.h
      };
      let y;
      try {
        y = d.apply(void 0, [z, ...u]);
      } catch (G) {
        throw new Su(G, f, e);
      }
      return y && "object" === typeof y && Object.getOwnPropertySymbols(y).includes(Lq) ? w.create(y.zb) : Wb(n.h, y, k);
    });
  }
  var Wu = {
    callFunction(a, b, c, d, e) {
      const f = ng(b, c, d.length);
      if (!f) throw Error("function not found for codegen function call");
      b = new cc({
        M: null,
        Aa: 0,
        ta: w.empty(),
        ra: {}
      });
      const h = new nb(a);
      a = new ic(!1, !1, h, null, null, e ? e.currentContext : null, null);
      d = f.callFunction(b, a, null, ...d.map((k, l) => Wb(h, k, f.j[l])));
      return Tu(d, {
        type: 59,
        g: 0
      }, a);
    },
    errXPDY0002: lc
  };
  var Xu = (a, b, c, d) => {
    c = c ? c : new Za();
    return a()(null !== b && void 0 !== b ? b : null, c, Wu, d);
  };
  const Yu = {
    ["http://www.w3.org/2005/XQueryX"]: "xqx",
    ["http://www.w3.org/2007/xquery-update-10"]: "xquf",
    ["http://fontoxml.com/fontoxpath"]: "x"
  };
  function Zu(a, b) {
    switch (a) {
      case "copySource":
      case "insertAfter":
      case "insertAsFirst":
      case "insertAsLast":
      case "insertBefore":
      case "insertInto":
      case "modifyExpr":
      case "newNameExpr":
      case "replacementExpr":
      case "replaceValue":
      case "returnExpr":
      case "sourceExpr":
      case "targetExpr":
      case "transformCopies":
      case "transformCopy":
        return {
          localName: a,
          lb: b || "http://www.w3.org/2005/XQueryX"
        };
      case "deleteExpr":
      case "insertExpr":
      case "renameExpr":
      case "replaceExpr":
      case "transformExpr":
        return {
          localName: a,
          lb: "http://www.w3.org/2007/xquery-update-10"
        };
      case "x:stackTrace":
        return {
          localName: "stackTrace",
          lb: "http://fontoxml.com/fontoxpath"
        };
      default:
        return {
          localName: a,
          lb: "http://www.w3.org/2005/XQueryX"
        };
    }
  }
  function $u(a, b, c, d, e) {
    if ("string" === typeof c) return 0 === c.length ? null : b.createTextNode(c);
    if (!Array.isArray(c)) throw new TypeError("JsonML element should be an array or string");
    var f = Zu(c[0], d);
    d = f.localName;
    f = f.lb;
    const h = b.createElementNS(f, Yu[f] + ":" + d),
      k = c[1];
    var l = 1;
    if ("object" === typeof k && !Array.isArray(k)) {
      if (null !== k) for (var n of Object.keys(k)) l = k[n], null !== l && ("type" === n ? void 0 !== l && a.setAttributeNS(h, f, "fontoxpath:" + n, Ha(l)) : ("start" !== n && "end" !== n && "comment" !== n || "stackTrace" !== d || (l = JSON.stringify(l)), e && "prefix" === n && "" === l || a.setAttributeNS(h, f, Yu[f] + ":" + n, l)));
      l = 2;
    }
    for (let t = l, u = c.length; t < u; ++t) n = $u(a, b, c[t], f, e), null !== n && a.insertBefore(h, n, null);
    return h;
  }
  function av(a, b, c, d = ab) {
    a = Pk(a);
    let e;
    try {
      e = qq(a, {
        Z: "XQuery3.1" === b.language || "XQueryUpdate3.1" === b.language,
        debug: b.debug
      });
    } catch (l) {
      hg(a, l);
    }
    var f = new qg(b.namespaceResolver || (() => null), {}, void 0 === b.defaultFunctionNamespaceURI ? "http://www.w3.org/2005/xpath-functions" : b.defaultFunctionNamespaceURI, b.functionNameResolver || (() => null));
    f = new Cg(f);
    var h = F(e, ["mainModule", "libraryModule"]),
      k = F(h, "moduleDecl");
    if (k) {
      const l = H(F(k, "prefix"));
      k = H(F(k, "uri"));
      Gg(f, l, k);
    }
    (h = F(h, "prolog")) && tq(h, f, !1, a);
    !1 !== b.annotateAst && jh(e, new rh(f));
    f = new Za();
    b = $u(d, c, e, null, !1 === b.mc);
    d.insertBefore(b, c.createComment(a), f.getFirstChild(b));
    return b;
  }
  function bv(a) {
    return Promise.resolve(a);
  }
  function cv(a, b = {
    debug: !1
  }) {
    try {
      var c = qq(a, {
        Z: !0,
        debug: b.debug
      });
    } catch (f) {
      hg(a, f);
    }
    jh(c, new rh());
    b = F(c, "libraryModule");
    if (!b) throw Error("XQuery module must be declared in a library module.");
    c = F(b, "moduleDecl");
    var d = F(c, "uri");
    const e = H(d);
    c = F(c, "prefix");
    d = H(c);
    c = new Cg(new qg(() => null, Object.create(null), "http://www.w3.org/2005/xpath-functions", Oq("http://www.w3.org/2005/xpath-functions")));
    Gg(c, d, e);
    b = F(b, "prolog");
    if (null !== b) {
      let f;
      try {
        f = tq(b, c, !0, a);
      } catch (h) {
        hg(a, h);
      }
      f.Ia.forEach(({
        namespaceURI: h
      }) => {
        if (e !== h) throw Error("XQST0048: Functions and variables declared in a module must reside in the module target namespace.");
      });
      Mk(e, f);
    } else Mk(e, {
      Ia: [],
      Ta: [],
      pa: null,
      source: a
    });
    return e;
  }
  const dv = new Map();
  function ev(a) {
    var b;
    a: {
      if (b = Gk.get(a)) for (const c of Object.keys(b)) if (b[c] && b[c].length) {
        b = b[c][0].h;
        break a;
      }
      b = null;
    }
    if (b) return b;
    if (dv.has(a)) return dv.get(a);
    b = "string" === typeof a ? qq(a, {
      Z: !1
    }) : Kk(a);
    b = J(b, ["mainModule", "queryBody", "*"]);
    if (null === b) throw Error("Library modules do not have a specificity");
    b = Fk(b, {
      sa: !1,
      Z: !1
    });
    dv.set(a, b);
    return b;
  }
  function fv(a) {
    return ev(a).D();
  }
  function gv(a, b) {
    return uf(ev(a).o, ev(b).o);
  }
  var hv = new Za();
  "undefined" !== typeof fontoxpathGlobal && (fontoxpathGlobal.compareSpecificity = gv, fontoxpathGlobal.compileXPathToJavaScript = Ru, fontoxpathGlobal.domFacade = hv, fontoxpathGlobal.evaluateXPath = $q, fontoxpathGlobal.evaluateXPathToArray = er, fontoxpathGlobal.evaluateXPathToAsyncIterator = ar, fontoxpathGlobal.evaluateXPathToBoolean = fr, fontoxpathGlobal.evaluateXPathToFirstNode = gr, fontoxpathGlobal.evaluateXPathToMap = hr, fontoxpathGlobal.evaluateXPathToNodes = ir, fontoxpathGlobal.evaluateXPathToNumber = jr, fontoxpathGlobal.evaluateXPathToNumbers = kr, fontoxpathGlobal.evaluateXPathToString = lr, fontoxpathGlobal.evaluateXPathToStrings = mr, fontoxpathGlobal.evaluateUpdatingExpression = cr, fontoxpathGlobal.evaluateUpdatingExpressionSync = dr, fontoxpathGlobal.executeJavaScriptCompiledXPath = Xu, fontoxpathGlobal.executePendingUpdateList = nr, fontoxpathGlobal.getBucketForSelector = fv, fontoxpathGlobal.getBucketsForNode = Ya, fontoxpathGlobal.precompileXPath = bv, fontoxpathGlobal.registerXQueryModule = cv, fontoxpathGlobal.registerCustomXPathFunction = Vu, fontoxpathGlobal.parseScript = av, fontoxpathGlobal.profiler = Xq, fontoxpathGlobal.createTypedValueFactory = Mq, fontoxpathGlobal.finalizeModuleRegistration = Ok, fontoxpathGlobal.Language = Zq, fontoxpathGlobal.ReturnType = Tq);
  return fontoxpathGlobal;
}.call(typeof window === 'undefined' ? undefined : window, xspattern, prsc);
fontoxpath.compareSpecificity;
fontoxpath.compileXPathToJavaScript;
const createTypedValueFactory = fontoxpath.createTypedValueFactory;
const domFacade = fontoxpath.domFacade;
fontoxpath.evaluateUpdatingExpression;
fontoxpath.evaluateUpdatingExpressionSync;
const evaluateXPath$1 = fontoxpath.evaluateXPath;
fontoxpath.evaluateXPathToArray;
fontoxpath.evaluateXPathToAsyncIterator;
const evaluateXPathToBoolean$1 = fontoxpath.evaluateXPathToBoolean;
const evaluateXPathToFirstNode$1 = fontoxpath.evaluateXPathToFirstNode;
fontoxpath.evaluateXPathToMap;
const evaluateXPathToNodes$1 = fontoxpath.evaluateXPathToNodes;
const evaluateXPathToNumber$1 = fontoxpath.evaluateXPathToNumber;
fontoxpath.evaluateXPathToNumbers;
const evaluateXPathToString$1 = fontoxpath.evaluateXPathToString;
const evaluateXPathToStrings$1 = fontoxpath.evaluateXPathToStrings;
fontoxpath.executeJavaScriptCompiledXPath;
fontoxpath.executePendingUpdateList;
fontoxpath.finalizeModuleRegistration;
fontoxpath.getBucketForSelector;
const getBucketsForNode = fontoxpath.getBucketsForNode;
fontoxpath.Language;
const parseScript = fontoxpath.parseScript;
fontoxpath.precompileXPath;
fontoxpath.profiler;
const registerCustomXPathFunction = fontoxpath.registerCustomXPathFunction;
const registerXQueryModule = fontoxpath.registerXQueryModule;
fontoxpath.ReturnType;

/**
 * A DomFacade that will intercept any and all accesses to _nodes_ from an XPath. Basically the same
 * as the `depends` function, but less explicit and will automatically be called for any node that
 * will be touched in the XPath.
 *
 * Maybe some more granularity is better. Maybe only notify a node's attributes are touched?
 *
 */
class DependencyNotifyingDomFacade {
  /**
   * @param  onNodeTouched - onNodeTouched A function what will be executed whenever a node is 'touched' by the XPath
   */
  constructor(onNodeTouched) {
    this._onNodeTouched = onNodeTouched;
  }

  /**
   * Get all attributes of this element.
   * The bucket can be used to narrow down which attributes should be retrieved.
   *
   * @param  node -
   */
  // eslint-disable-next-line class-methods-use-this
  getAllAttributes(node) {
    return Array.from(node.attributes);
  }

  /**
   * Get the value of specified attribute of this element.
   *
   * @param  node -
   * @param  attributeName -
   */
  // eslint-disable-next-line class-methods-use-this
  getAttribute(node, attributeName) {
    return node.getAttribute(attributeName);
  }

  /**
   * Get all child nodes of this element.
   * The bucket can be used to narrow down which child nodes should be retrieved.
   *
   * @param  node -
   * @param  bucket - The bucket that matches the attribute that will be used.
   */
  // eslint-disable-next-line class-methods-use-this
  getChildNodes(node, bucket) {
    const matchingNodes = Array.from(node.childNodes).filter(childNode => !bucket || getBucketsForNode(childNode).includes(bucket));
    matchingNodes.forEach(matchingNode => this._onNodeTouched(matchingNode));
    return matchingNodes;
  }

  /**
   * Get the data of this node.
   *
   * @param  node -
   */
  getData(node) {
    if (node.nodeType === Node.ATTRIBUTE_NODE) {
      this._onNodeTouched(node);
      return node.value;
    }
    // Text node
    this._onNodeTouched(node.parentNode);
    return node.data;
  }

  /**
   * Get the first child of this element.
   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.
   *
   * @param  node -
   * @param  bucket - The bucket that matches the attribute that will be used.
   */
  getFirstChild(node, bucket) {
    for (const child of node.childNodes) {
      if (!bucket || getBucketsForNode(child).includes(bucket)) {
        this._onNodeTouched(child);
        return child;
      }
    }
    return null;
  }

  /**
   * Get the last child of this element.
   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.
   *
   * @param  node -
   * @param  bucket - The bucket that matches the attribute that will be used.
   */
  // eslint-disable-next-line class-methods-use-this
  getLastChild(node, bucket) {
    const matchingNodes = node.getChildNodes().filter(childNode => !bucket || getBucketsForNode(childNode).includes(bucket));
    const matchNode = matchingNodes[matchingNodes.length - 1];
    if (matchNode) {
      return matchNode;
    }
    return null;
  }

  /**
   * Get the next sibling of this node
   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.
   *
   * @param  node -
   * @param  bucket - The bucket that matches the nextSibling that is requested.
   */
  // eslint-disable-next-line class-methods-use-this
  getNextSibling(node, bucket) {
    for (let sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {
      if (bucket && !getBucketsForNode(sibling).includes(bucket)) {
        // eslint-disable-next-line no-continue
        continue;
      }
      this._onNodeTouched(sibling);
      return sibling;
    }
    return null;
  }

  /**
   * Get the parent of this element.
   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.
   *
   * @param  node - the starting node
   */
  // eslint-disable-next-line class-methods-use-this
  getParentNode(node) {
    return node.parentNode;
  }

  /**
   * Get the previous sibling of this element.
   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.
   *
   * @param  node -
   * @param  bucket - The bucket that matches the attribute that will be used.
   */
  // eslint-disable-next-line class-methods-use-this
  getPreviousSibling(node, bucket) {
    for (let {
      previousSibling
    } = node; previousSibling; previousSibling = previousSibling.previousSibling) {
      if (bucket && !getBucketsForNode(previousSibling).includes(bucket)) {
        // eslint-disable-next-line no-continue
        continue;
      }
      return previousSibling;
    }
    return null;
  }
}

class XPathUtil {
  /**
   * creates DOM Nodes from an XPath locationpath expression. Support namespaced and un-namespaced
   * nodes.
   * E.g. 'foo/bar' creates an element 'foo' with an child element 'bar'
   * 'foo/@bar' creates a 'foo' element with an 'bar' attribute
   *
   * supports multiple steps
   *
   * @param xpath
   * @param doc
   * @param fore
   * @return {*}
   */
  static createNodesFromXPath(xpath, doc, fore) {
    if (!doc) {
      doc = document.implementation.createDocument(null, null, null); // Create a new XML document if not provided
    }

    const parts = xpath.split('/');
    let rootNode = null;
    let currentNode = null;
    for (const part of parts) {
      if (!part) continue; // Skip empty parts (e.g., leading slashes)

      // Handle attributes
      if (part.startsWith('@')) {
        const attrName = part.slice(1); // Strip '@'
        if (!currentNode) {
          throw new Error('Cannot create an attribute without a parent element.');
        }
        currentNode.setAttribute(attrName, '');
      } else {
        // Handle namespaces if present
        const [prefix, localName] = part.includes(':') ? part.split(':') : [null, part];
        const namespace = prefix ? XPathUtil.lookupNamespace(fore, prefix) : null;
        const newElement = namespace ? doc.createElementNS(namespace, part) : doc.createElement(localName);
        if (!rootNode) {
          rootNode = newElement; // Set as the root node
        } else {
          currentNode.appendChild(newElement);
        }
        currentNode = newElement;
      }
    }
    if (!rootNode) {
      throw new Error('Invalid XPath; no root element could be created.');
    }
    return rootNode;
  }

  /**
   * looks up namespace on ownerForm. Though not strictly in the sense of resolving namespaces in XML, the
   * fx-fore element is a convenient place to put namespace declarations for 2 reasons:
   * - this way namespaces are scoped to a Fore element
   * - as fx-fore is a web component we can add our xmlns attributes as we got no restrictions to attributes
   *   though strictly speaking they are no xmlns declarations and just serve the purpose of namespace lookup.
   *
   * @param boundElement
   * @param prefix
   * @return {string}
   */
  static lookupNamespace(ownerForm, prefix) {
    return ownerForm.getAttribute(`xmlns:${prefix}`);
  }
  static querySelectorAll(querySelector, start) {
    const queue = [start];
    const found = [];
    while (queue.length) {
      const item = queue.shift();
      for (const child of Array.from(item.children).reverse()) {
        queue.unshift(child);
      }
      if (item.matches && item.matches('template')) {
        queue.unshift(item.content);
      }
      if (item.matches && item.matches(querySelector)) {
        found.push(item);
      }
    }
    return found;
  }

  /**
   * Alternative to `contains` that respects shadowroots
   * @param {Node} ancestor
   * @param {Node} descendant
   * @returns {boolean}
   */
  static contains(ancestor, descendant) {
    while (descendant) {
      if (descendant === ancestor) {
        return true;
      }
      if (descendant.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        // We are passing a shadow root boundary
        descendant = descendant.host;
      } else {
        descendant = descendant.parentNode;
      }
    }
    return false;
  }

  /**
   * Alternative to `closest` that respects subcontrol boundaries
   *
   * @param {string} querySelector
   * @param {Node} start
   * @returns {HTMLElement}
   */
  static getClosest(querySelector, start) {
    while (start && !start.matches || !start.matches(querySelector)) {
      if (start.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        // We are passing a shadow root boundary
        start = start.host;
        continue;
      }
      if (start.nodeType === Node.ATTRIBUTE_NODE) {
        // We are passing an attribute
        start = start.ownerElement;
        continue;
      }
      if (start.nodeType === Node.TEXT_NODE) {
        start = start.parentNode;
      }
      if (start.matches('fx-fore')) {
        // Subform reached. Bail out
        return null;
      }
      start = start.parentNode;
      if (!start) {
        return null;
      }
    }
    return start;
  }

  /**
   * returns next bound element upwards in tree
   * @param {Node} start where to start the search
   * @returns {*|null}
   */
  static getParentBindingElement(start) {
    /*    if (start.parentNode.host) {
      const { host } = start.parentNode;
      if (host.hasAttribute('ref')) {
        return host;
      }
    } else */
    if (start.parentNode && (start.parentNode.nodeType !== Node.DOCUMENT_NODE || start.parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE)) {
      return this.getClosest('[ref],fx-repeatitem', start.parentNode);
    }
    return null;
  }

  /**
   * Checks whether the specified path expression is an absolute path.
   *
   * @param {string} path the path expression.
   * @returns {boolean} <code>true</code> if specified path expression is an absolute
   * path, otherwise <code>false</code>.
   */
  static isAbsolutePath(path) {
    return path != null && (path.startsWith('/') || path.startsWith('instance(') || path.startsWith('$'));
  }

  /**
   * @param {string} ref
   */
  static isSelfReference(ref) {
    return ref === '.' || ref === './text()' || ref === 'text()' || ref === '' || ref === null;
  }

  /**
   * returns the instance id from a complete XPath using `instance()` function.
   *
   * Will return 'default' in case no ref is given at all or the `instance()` function is called without arg.
   *
   * Otherwise instance id is extracted from function and returned. If all fails null is returned.
   * @param {string} ref
   * @param {HTMLElement}  boundElement  The element related to this ref. Used to resolve variables
   * @returns {string}
   */
  static getInstanceId(ref, boundElement) {
    if (!ref) {
      return 'default';
    }
    if (ref.startsWith('instance()')) {
      return 'default';
    }
    if (ref.startsWith('instance(')) {
      const result = ref.substring(ref.indexOf('(') + 1);
      return result.substring(1, result.indexOf(')') - 1);
    }
    if (ref.startsWith('$')) {
      // this variable might actually point to an instance
      const variableName = ref.match(/\$(?<variableName>[a-zA-Z0-9\-\_]+).*/)?.groups?.variableName;
      let closestActualFormElement = boundElement;
      while (closestActualFormElement && !('inScopeVariables' in closestActualFormElement)) {
        closestActualFormElement = closestActualFormElement.nodeType === Node.ATTRIBUTE_NODE ? closestActualFormElement.ownerElement : closestActualFormElement.parentNode;
      }
      const correspondingVariable = closestActualFormElement?.inScopeVariables?.get(variableName);
      if (!correspondingVariable) {
        return null;
      }
      return this.getInstanceId(correspondingVariable.valueQuery, correspondingVariable);
    }
    return null;
  }

  /**
   * @param {HTMLElement} boundElement
   * @param {string} path
   * @returns {string}
   */
  static resolveInstance(boundElement, path) {
    let instanceId = XPathUtil.getInstanceId(path, boundElement);
    if (!instanceId) {
      instanceId = XPathUtil.getInstanceId(boundElement.getAttribute('ref'), boundElement);
    }
    if (instanceId !== null) {
      return instanceId;
    }
    const parentBinding = XPathUtil.getParentBindingElement(boundElement);
    if (parentBinding) {
      return this.resolveInstance(parentBinding, path);
    }
    return 'default';
  }

  /**
   * @param {Node} node
   * @returns string
   */
  static getDocPath(node) {
    const path = evaluateXPathToString$1('path()', node);
    // Path is like `$default/x[1]/y[1]`
    const shortened = XPathUtil.shortenPath(path);
    return shortened.startsWith('/') ? `${shortened}` : `/${shortened}`;
  }

  /**
   * @param {Node} node
   * @param {string} instanceId
   * @returns string
   */
  static getPath(node, instanceId) {
    const path = evaluateXPathToString$1('path()', node);
    // Path is like `$default/x[1]/y[1]`
    const shortened = XPathUtil.shortenPath(path);
    return shortened.startsWith('/') ? `$${instanceId}${shortened}` : `$${instanceId}/${shortened}`;
  }

  /**
   * @param {string} path
   * @returns string
   */
  static shortenPath(path) {
    const tmp = path.replaceAll(/(Q{(.*?)\})/g, '');
    // cut off leading slash
    const tmp1 = tmp.substring(1, tmp.length);
    // ### cut-off root node ref
    return tmp1.substring(tmp1.indexOf('/'), tmp.length);
  }

  /**
   * @param {string} dep
   * @returns {string}
   */
  static getBasePath(dep) {
    const split = dep.split(':');
    return split[0];
  }
}

/**
 * A simple dependency graph
 *
 * based on the work of https://github.com/jriecken/dependency-graph but working on ES6.
 *
 * Furthermore instead of the DepGraphCycleError a compute-exception event is dispatched.
 *
 *
 */

/**
 * Cycle error, including the path of the cycle.
 */
// const DepGraphCycleError = (exports.DepGraphCycleError = function (cyclePath) {

/*
export function DepGraphCycleError(cyclePath) {
  const message = "Dependency Cycle Found: " + cyclePath.join(" -> ");
  const instance = new Error(message);
  instance.cyclePath = cyclePath;
  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, DepGraphCycleError);
  }
  return instance;
};

DepGraphCycleError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(DepGraphCycleError, Error);
*/

/**
 * Helper for creating a Topological Sort using Depth-First-Search on a set of edges.
 *
 * Detects cycles and throws an Error if one is detected (unless the "circular"
 * parameter is "true" in which case it ignores them).
 *
 * @param edges The set of edges to DFS through
 * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
 * @param result An array in which the results will be populated
 * @param circular A boolean to allow circular dependencies
 */
function createDFS(edges, leavesOnly, result, circular) {
  const visited = {};
  // eslint-disable-next-line func-names
  return function (start) {
    // console.log('start ', start);
    if (visited[start]) {
      return;
    }
    const inCurrentPath = {};
    const currentPath = [];
    const todo = []; // used as a stack
    todo.push({
      node: start,
      processed: false
    });
    while (todo.length > 0) {
      const current = todo[todo.length - 1]; // peek at the todo stack
      const {
        processed
      } = current;
      const {
        node
      } = current;
      if (!processed) {
        // Haven't visited edges yet (visiting phase)
        if (visited[node]) {
          todo.pop();
          // eslint-disable-next-line no-continue
          continue;
        } else if (inCurrentPath[node]) {
          // It's not a DAG
          if (circular) {
            todo.pop();
            // If we're tolerating cycles, don't revisit the node
            // eslint-disable-next-line no-continue
            continue;
          }
          currentPath.push(node);
          window.dispatchEvent(new CustomEvent('compute-exception', {
            composed: false,
            bubbles: true,
            detail: {
              path: currentPath,
              message: 'cyclic graph'
            }
          }));
          // return;
          // console.log('circular path: ' + currentPath);
          // throw new DepGraphCycleError(currentPath);

          // Stop all processing. This form is broken and we should not break the browser
          throw new Error(`Cyclic at ${currentPath}`);
        }
        inCurrentPath[node] = true;
        currentPath.push(node);
        const nodeEdges = edges[node];
        // (push edges onto the todo stack in reverse order to be order-compatible with the old DFS implementation)
        for (let i = nodeEdges.length - 1; i >= 0; i -= 1) {
          todo.push({
            node: nodeEdges[i],
            processed: false
          });
        }
        current.processed = true;
      } else {
        // Have visited edges (stack unrolling phase)
        todo.pop();
        currentPath.pop();
        inCurrentPath[node] = false;
        visited[node] = true;
        if (!leavesOnly || edges[node].length === 0) {
          result.push(node);
        }
      }
    }
  };
}

/**
 * Simple Dependency Graph
 */

/*
var DepGraph = (exports.DepGraph = function DepGraph(opts) {
  this.nodes = {}; // Node -> Node/Data (treated like a Set)
  this.outgoingEdges = {}; // Node -> [Dependency Node]
  this.incomingEdges = {}; // Node -> [Dependant Node]
  this.circular = opts && !!opts.circular; // Allows circular deps
});
*/

function DepGraph(opts) {
  this.nodes = {}; // Node -> Node/Data (treated like a Set)
  this.outgoingEdges = {}; // Node -> [Dependency Node]
  this.incomingEdges = {}; // Node -> [Dependant Node]
  this.circular = opts && !!opts.circular; // Allows circular deps
}

DepGraph.prototype = {
  /**
   * The number of nodes in the graph.
   */
  size() {
    return Object.keys(this.nodes).length;
  },
  /**
   * Add a node to the dependency graph. If a node already exists, this method will do nothing.
   */
  addNode(node, data) {
    if (!this.hasNode(node)) {
      // Checking the arguments length allows the user to add a node with undefined data
      if (arguments.length === 2) {
        this.nodes[node] = data;
      } else {
        this.nodes[node] = node;
      }
      this.outgoingEdges[node] = [];
      this.incomingEdges[node] = [];
    }
  },
  /**
   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
   */
  removeNode(node) {
    if (this.hasNode(node)) {
      delete this.nodes[node];
      delete this.outgoingEdges[node];
      delete this.incomingEdges[node];
      // [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {
      [this.incomingEdges, this.outgoingEdges].forEach(edgeList => {
        Object.keys(edgeList).forEach(key => {
          const idx = edgeList[key].indexOf(node);
          if (idx >= 0) {
            edgeList[key].splice(idx, 1);
          }
        }, this);
      });
    }
  },
  /**
   * Check if a node exists in the graph
   */
  hasNode(node) {
    // return this.nodes.hasOwnProperty(node);

    return Object.prototype.hasOwnProperty.call(this.nodes, node);
  },
  /**
   * Get the data associated with a node name
   */
  getNodeData(node) {
    if (this.hasNode(node)) {
      return this.nodes[node];
    }
    throw new Error(`Node does not exist: ${node}`);
  },
  /**
   * Set the associated data for a given node name. If the node does not exist, this method will throw an error
   */
  setNodeData(node, data) {
    if (this.hasNode(node)) {
      this.nodes[node] = data;
    } else {
      throw new Error(`Node does not exist: ${node}`);
    }
  },
  /**
   * Add a dependency between two nodes. If either of the nodes does not exist,
   * an Error will be thrown.
   */
  addDependency(from, to) {
    if (!this.hasNode(from)) {
      throw new Error(`Node does not exist: ${from}`);
    }
    if (!this.hasNode(to)) {
      throw new Error(`Node does not exist: ${to}`);
    }
    if (this.outgoingEdges[from].indexOf(to) === -1) {
      this.outgoingEdges[from].push(to);
    }
    if (this.incomingEdges[to].indexOf(from) === -1) {
      this.incomingEdges[to].push(from);
    }
    return true;
  },
  /**
   * Remove a dependency between two nodes.
   */
  removeDependency(from, to) {
    let idx;
    if (this.hasNode(from)) {
      idx = this.outgoingEdges[from].indexOf(to);
      if (idx >= 0) {
        this.outgoingEdges[from].splice(idx, 1);
      }
    }
    if (this.hasNode(to)) {
      idx = this.incomingEdges[to].indexOf(from);
      if (idx >= 0) {
        this.incomingEdges[to].splice(idx, 1);
      }
    }
  },
  /**
   * Return a clone of the dependency graph. If any custom data is attached
   * to the nodes, it will only be shallow copied.
   */
  clone() {
    const source = this;
    const result = new DepGraph();
    const keys = Object.keys(source.nodes);
    keys.forEach(n => {
      result.nodes[n] = source.nodes[n];
      result.outgoingEdges[n] = source.outgoingEdges[n].slice(0);
      result.incomingEdges[n] = source.incomingEdges[n].slice(0);
    });
    return result;
  },
  /**
   * Get an array containing the direct dependencies of the specified node.
   *
   * Throws an Error if the specified node does not exist.
   */
  directDependenciesOf(node) {
    if (this.hasNode(node)) {
      return this.outgoingEdges[node].slice(0);
    }
    throw new Error(`Node does not exist: ${node}`);
  },
  /**
   * Get an array containing the nodes that directly depend on the specified node.
   *
   * Throws an Error if the specified node does not exist.
   */
  directDependantsOf(node) {
    if (this.hasNode(node)) {
      return this.incomingEdges[node].slice(0);
    }
    throw new Error(`Node does not exist: ${node}`);
  },
  /**
   * Get an array containing the nodes that the specified node depends on (transitively).
   *
   * Throws an Error if the graph has a cycle, or the specified node does not exist.
   *
   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
   * in the array.
   */
  dependenciesOf(node, leavesOnly) {
    if (this.hasNode(node)) {
      const result = [];
      const DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);
      DFS(node);
      const idx = result.indexOf(node);
      if (idx >= 0) {
        result.splice(idx, 1);
      }
      return result;
    }
    throw new Error(`Node does not exist: ${node}`);
  },
  /**
   * get an array containing the nodes that depend on the specified node (transitively).
   *
   * Throws an Error if the graph has a cycle, or the specified node does not exist.
   *
   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
   */
  dependantsOf(node, leavesOnly) {
    if (this.hasNode(node)) {
      const result = [];
      const DFS = createDFS(this.incomingEdges, leavesOnly, result, this.circular);
      DFS(node);
      const idx = result.indexOf(node);
      if (idx >= 0) {
        result.splice(idx, 1);
      }
      return result;
    }
    throw new Error(`Node does not exist: ${node}`);
  },
  /**
   * Get an array of nodes that have no dependants (i.e. nothing depends on them).
   */
  entryNodes() {
    const self = this;
    return Object.keys(this.nodes).filter(node => self.incomingEdges[node].length === 0);
  },
  /**
   * Construct the overall processing order for the dependency graph.
   *
   * Throws an Error if the graph has a cycle.
   *
   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
   */
  overallOrder(leavesOnly) {
    const self = this;
    const result = [];
    const keys = Object.keys(this.nodes);
    if (keys.length === 0) {
      return result; // Empty graph
    }

    if (!this.circular) {
      // Look for cycles - we run the DFS starting at all the nodes in case there
      // are several disconnected subgraphs inside this dependency graph.
      const CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);
      keys.forEach(n => {
        CycleDFS(n);
      });
    }
    const DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);
    // Find all potential starting points (nodes with nothing depending on them) an
    // run a DFS starting at these points to get the order
    keys.filter(node => self.incomingEdges[node].length === 0).forEach(n => {
      DFS(n);
    });

    // If we're allowing cycles - we need to run the DFS against any remaining
    // nodes that did not end up in the initial result (as they are part of a
    // subgraph that does not have a clear starting point)
    if (this.circular) {
      keys.filter(node => result.indexOf(node) === -1).forEach(n => DFS(n));
    }
    return result;
  }
};

// Create some aliases
DepGraph.prototype.directDependentsOf = DepGraph.prototype.directDependantsOf;
DepGraph.prototype.dependentsOf = DepGraph.prototype.dependantsOf;

function prettifyXml(source) {
  const xmlDoc = new DOMParser().parseFromString(source, 'application/xml');
  const xsltDoc = new DOMParser().parseFromString([
  // describes how we want to modify the XML - indent everything
  '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">', '  <xsl:output method="xml" indent="yes" omit-xml-declaration="yes"/>', '  <xsl:strip-space elements="*"/>', '  <xsl:template match="text()">',
  // change to just text() to strip space in text nodes
  '    <xsl:value-of select="normalize-space(.)"/>', '  </xsl:template>', '  <xsl:template match="node()|@*">', '    <xsl:copy>', '        <xsl:apply-templates select="node()|@*"/>', '    </xsl:copy>', '  </xsl:template>', '</xsl:stylesheet>'].join('\n'), 'application/xml');
  const xsltProcessor = new XSLTProcessor();
  xsltProcessor.importStylesheet(xsltDoc);
  const resultDoc = xsltProcessor.transformToDocument(xmlDoc);
  const resultXml = new XMLSerializer().serializeToString(resultDoc);
  return resultXml;
}

const XFORMS_NAMESPACE_URI = 'http://www.w3.org/2002/xforms';
const createdNamespaceResolversByXPathQueryAndNode = new Map();

// A global registry of function names that are declared in Fore by a developer using the
// `fx-function` element. These should be available without providing a prefix as well
const globallyDeclaredFunctionLocalNames = [];
function getCachedNamespaceResolver(xpath, node) {
  if (!createdNamespaceResolversByXPathQueryAndNode.has(xpath)) {
    return null;
  }
  return createdNamespaceResolversByXPathQueryAndNode.get(xpath).get(node) || null;
}
function setCachedNamespaceResolver(xpath, node, resolver) {
  if (!createdNamespaceResolversByXPathQueryAndNode.has(xpath)) {
    return createdNamespaceResolversByXPathQueryAndNode.set(xpath, new Map());
  }
  return createdNamespaceResolversByXPathQueryAndNode.get(xpath).set(node, resolver);
}
const xhtmlNamespaceResolver = prefix => {
  if (!prefix) {
    return 'http://www.w3.org/1999/xhtml';
  }
  return undefined;
};

/**
 * Resolve an id in scope. Behaves like the algorithm defined on https://www.w3.org/community/xformsusers/wiki/XForms_2.0#idref-resolve
 *
 * @param {string} id
 * @param {Node} sourceObject
 * @param {string} nodeName
 *
 * @returns {HTMLElement} The element with that ID, resolved with respect to repeats
 */
function resolveId(id, sourceObject, nodeName = null) {
  const query = 'outermost(ancestor-or-self::fx-fore[1]/(descendant::fx-fore|descendant::*[@id = $id]))[not(self::fx-fore)]';
  /*
        if (nodeName === 'fx-instance') {
            // Instance elements can only be in the `model` element
            // query = 'ancestor-or-self::fx-fore[1]/fx-model/fx-instance[@id = $id]';
             const fore = Fore.getFore(sourceObject);
            const instances = fore.getModel().instances;
            const targetInstance = instances.find(i => i.id === id);
            return targetInstance;
        return document.getElementById(id);
  }
    */
  if (sourceObject.nodeType === Node.TEXT_NODE) {
    sourceObject = sourceObject.parentNode;
  }
  if (sourceObject.nodeType === Node.ATTRIBUTE_NODE) {
    sourceObject = sourceObject.ownerElement;
  }
  if (sourceObject.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    sourceObject = sourceObject.parentNode.host;
  }
  const ownerForm = sourceObject.localName === 'fx-fore' ? sourceObject : sourceObject.closest('fx-fore');
  const elementsWithId = ownerForm.querySelectorAll(`[id='${id}']`);
  if (elementsWithId.length === 1) {
    // A single one is found. Assume no ID reuse.
    const targetObject = elementsWithId[0];
    if (nodeName && targetObject.localName !== nodeName) {
      return null;
    }
    return targetObject;
  }
  const allMatchingTargetObjects = evaluateXPathToNodes$1(query, sourceObject, null, {
    id
  }, {
    namespaceResolver: xhtmlNamespaceResolver
  });
  if (allMatchingTargetObjects.length === 0) {
    return null;
  }
  if (allMatchingTargetObjects.length === 1 && evaluateXPathToBoolean$1('(ancestor::fx-fore | ancestor::fx-repeat)[last()]/self::fx-fore', allMatchingTargetObjects[0], null, null, {
    namespaceResolver: xhtmlNamespaceResolver
  })) {
    // If the target element is not repeated, then the search for the target object is trivial since
    // there is only one associated with the target element that bears the matching ID. This is true
    // regardless of whether or not the source object is repeated. However, if the target element is
    // repeated, then additional information must be used to help select a target object from among
    // those associated with the identified target element.
    const targetObject = allMatchingTargetObjects[0];
    if (nodeName && targetObject.localName !== nodeName) {
      return null;
    }
    return targetObject;
  }

  // SPEC:

  // 12.2.1 References to Elements within a repeat Element

  // When the target element that is identified by the IDREF of a source object has one or more
  // repeat elements as ancestors, then the set of ancestor repeats are partitioned into two
  // subsets, those in common with the source element and those that are not in common. Any ancestor
  // repeat elements of the target element not in common with the source element are descendants of
  // the repeat elements that the source and target element have in common, if any.

  // For the repeat elements that are in common, the desired target object exists in the same set of
  // run-time objects that contains the source object. Then, for each ancestor repeat of the target
  // element that is not in common with the source element, the current index of the repeat
  // determines the set of run-time objects that contains the desired target object.
  for (const ancestorRepeatItem of evaluateXPathToNodes$1('ancestor::fx-repeatitem => reverse()', sourceObject, null, null, {
    namespaceResolver: xhtmlNamespaceResolver
  })) {
    const foundTargetObjects = allMatchingTargetObjects.filter(to => XPathUtil.contains(ancestorRepeatItem, to));
    switch (foundTargetObjects.length) {
      case 0:
        // Nothing found: ignore
        break;
      case 1:
        {
          // A single one is found: the target object is directly in a common repeat
          const targetObject = foundTargetObjects[0];
          if (nodeName && targetObject.localName !== nodeName) {
            return null;
          }
          return targetObject;
        }
      default:
        {
          // Multiple target objects are found: they are in a repeat that is not common with the
          // source object We found a target object in a common repeat! We now need to find the one
          // that is in the repeatitem identified at the current index
          const targetObject = foundTargetObjects.find(to => evaluateXPathToNodes$1('every $ancestor of ancestor::fx-repeatitem satisfies $ancestor is $ancestor/../child::fx-repeatitem[../@repeat-index]', to, null, {}));
          if (!targetObject) {
            // Nothing valid found for whatever reason. This might be something dynamic?
            return null;
          }
          if (nodeName && targetObject.localName !== nodeName) {
            return null;
          }
          return targetObject;
        }
    }
  }
  // We found no target objects in common repeats. The id is unresolvable
  return null;
}

// Make namespace resolving use the `instance` element that is related to here
const xmlDocument = new DOMParser().parseFromString('<xml />', 'text/xml');
const instanceReferencesByQuery = new Map();
function findInstanceReferences(xpathQuery) {
  if (!xpathQuery.includes('instance')) {
    // No call to the instance function anyway: short-circuit and prevent AST processing
    return [];
  }
  if (instanceReferencesByQuery.has(xpathQuery)) {
    return instanceReferencesByQuery.get(xpathQuery);
  }
  const xpathAST = parseScript(xpathQuery, {}, xmlDocument);
  const instanceReferences = evaluateXPathToStrings$1(`descendant::xqx:functionCallExpr
				[xqx:functionName = "instance"]
				/xqx:arguments
				/xqx:stringConstantExpr
				/xqx:value`, xpathAST, null, {}, {
    namespaceResolver: prefix => prefix === 'xqx' ? 'http://www.w3.org/2005/XQueryX' : undefined
  });
  instanceReferencesByQuery.set(xpathQuery, instanceReferences);
  return instanceReferences;
}
/**
 * @typedef {function(string):string} NamespaceResolver
 */

/**
 * @function
 * Resolve a namespace. Needs a namespace prefix and the element that is most closely related to the
 * XPath in which the namespace is being resolved. The prefix will be resolved by using the
 * ancestry of said element.
 *
 * It has two ways of doing so:
 *
 * - If the prefix is defined in an `xmlns:XXX="YYY"` namespace declaration, it will return 'YYY'.
 * - If the prefix is the empty prefix and there is an `xpath-default-namespace="YYY"` attribute in
 * - the * ancestry, that attribute will be used and 'YYY' will be returned
 *
 * @param  {string} xpathQuery
 * @param  {HTMLElement} formElement
 * @returns {NamespaceResolver} The namespace resolver for this context
 */
function createNamespaceResolver(xpathQuery, formElement) {
  const cachedResolver = getCachedNamespaceResolver(xpathQuery, formElement);
  if (cachedResolver) {
    return cachedResolver;
  }
  let instanceReferences = findInstanceReferences(xpathQuery);
  if (instanceReferences.length === 0) {
    // No instance functions. Look up further in the hierarchy to see if we can deduce the intended context from there
    const ancestorComponent = formElement.parentNode && formElement.parentNode.nodeType === formElement.ELEMENT_NODE && formElement.parentNode.closest('[ref]');
    if (ancestorComponent) {
      const resolver = createNamespaceResolver(ancestorComponent.getAttribute('ref'), ancestorComponent);
      setCachedNamespaceResolver(xpathQuery, formElement, resolver);
      return resolver;
    }
    // Nothing found: let's just assume we're supposed to use the `default` instance
    instanceReferences = ['default'];
  }
  if (instanceReferences.length === 1) {
    // console.log(`resolving ${xpathQuery} with ${instanceReferences[0]}`);
    let instance;
    if (instanceReferences[0] === 'default') {
      /**
       * @type {HTMLElement}
       */
      const actualForeElement = evaluateXPathToFirstNode$1('ancestor-or-self::fx-fore[1]', formElement, null, null, {
        namespaceResolver: xhtmlNamespaceResolver
      });
      instance = actualForeElement && actualForeElement.querySelector('fx-instance');
    } else {
      instance = resolveId(instanceReferences[0], formElement, 'fx-instance');
    }
    if (instance && instance.hasAttribute('xpath-default-namespace')) {
      const xpathDefaultNamespace = instance.getAttribute('xpath-default-namespace');
      /*
            console.log(
              `Resolving the xpath ${xpathQuery} with the default namespace set to ${xpathDefaultNamespace}`,
            );
      */
      /**
       * @type {NamespaceResolver}
       */
      const resolveNamespacePrefix = prefix => {
        if (!prefix) {
          return xpathDefaultNamespace;
        }
        return undefined;
      };
      setCachedNamespaceResolver(xpathQuery, formElement, resolveNamespacePrefix);
      return resolveNamespacePrefix;
    }
  }
  if (instanceReferences.length > 1) {
    console.warn(`More than one instance is used in the query "${xpathQuery}". The default namespace resolving will be used`);
  }
  const xpathDefaultNamespace = evaluateXPathToString$1('ancestor-or-self::*/@xpath-default-namespace[last()]', formElement) || '';

  /**
   * @type {NamespaceResolver}
   */
  const resolveNamespacePrefix = function resolveNamespacePrefix(prefix) {
    if (prefix === '') {
      return xpathDefaultNamespace;
    }

    // Note: ideally we should use Node#lookupNamespaceURI. However, the nodes we are passed are
    // XML. The best we can do is emulate the `xmlns:xxx` namespace declarations by regarding them as
    // attributes. Which they technically ARE NOT!

    return evaluateXPathToString$1('ancestor-or-self::*/@*[name() = "xmlns:" || $prefix][last()]', formElement, null, {
      prefix
    });
  };
  setCachedNamespaceResolver(xpathQuery, formElement, resolveNamespacePrefix);
  return resolveNamespacePrefix;
}
function createNamespaceResolverForNode(query, contextNode, formElement) {
  if ((contextNode && contextNode.ownerDocument || contextNode) === window.document) {
    // Running a query on the HTML DOM. Don't bother resolving namespaces in any other way
    return xhtmlNamespaceResolver;
  }
  return createNamespaceResolver(query, formElement);
}

/**
 * Implementation of the functionNameResolver passed to FontoXPath to
 * redirect function resolving for unprefixed functions to either the fn or the xf namespace
 */
// eslint-disable-next-line no-unused-vars
function functionNameResolver({
  prefix,
  localName
}, _arity) {
  switch (localName) {
    // TODO: put the full XForms library functions set here
    case 'context':
    case 'base64encode':
    case 'boolean-from-string':
    case 'current':
    case 'depends':
    case 'event':
    case 'fore-attr':
    case 'index':
    case 'instance':
    case 'json2xml':
    case 'xml2Json':
    case 'log':
    case 'parse':
    case 'local-date':
    case 'local-dateTime':
    case 'logtree':
    case 'uri':
    case 'uri-fragment':
    case 'uri-host':
    case 'uri-param':
    case 'uri-path':
    case 'uri-relpath':
    case 'uri-port':
    case 'uri-query':
    case 'uri-scheme':
    case 'uri-scheme-specific-part':
      return {
        namespaceURI: XFORMS_NAMESPACE_URI,
        localName
      };
    default:
      if (prefix === '' && globallyDeclaredFunctionLocalNames.includes(localName)) {
        // The function has been declared without a prefix and is called here without a prefix.
        // Just make this work. It is the developer-friendly way
        return {
          namespaceURI: 'http://www.w3.org/2005/xquery-local-functions',
          localName
        };
      }
      if (prefix === 'fn' || prefix === '') {
        return {
          namespaceURI: 'http://www.w3.org/2005/xpath-functions',
          localName
        };
      }
      if (prefix === 'local') {
        return {
          namespaceURI: 'http://www.w3.org/2005/xquery-local-functions',
          localName
        };
      }
      return null;
  }
}

/**
 * Get the variables in scope of the form element. These are the values of the variables that
 * logically precede the formElement that declares the XPath
 *
 * @param  {Node}  formElement  The element that declares the XPath
 *
 * @returns  {Object}  A key-value mapping of the variables
 */
function getVariablesInScope(formElement) {
  let closestActualFormElement = formElement;
  while (closestActualFormElement && !('inScopeVariables' in closestActualFormElement)) {
    closestActualFormElement = closestActualFormElement.nodeType === Node.ATTRIBUTE_NODE ? closestActualFormElement.ownerElement : closestActualFormElement.parentNode;
  }
  if (!closestActualFormElement) {
    return {};
  }
  const variables = {};
  if (closestActualFormElement.inScopeVariables) {
    for (const key of closestActualFormElement.inScopeVariables.keys()) {
      const varElementOrValue = closestActualFormElement.inScopeVariables.get(key);
      if (!varElementOrValue) {
        continue;
      }
      if (varElementOrValue.nodeType) {
        // We are a var element, set the value to the value computed there
        variables[key] = varElementOrValue.value;
        // variables[key] = varElementOrValue.inScopeVariables.get(key);
      } else {
        // We are a direct value. This is used to leak in event variables
        variables[key] = varElementOrValue;
      }
    }
  }
  return variables;
}

/**
 * Evaluate an XPath to _any_ type. When possible, prefer to use any other function to ensure the
 * type of the output is more predictable.
 *
 * @param  {string} xpath  The XPath to run
 * @param  {Node} contextNode The start of the XPath
 * @param  {import('./ForeElementMixin.js').default} formElement  The form element associated to the XPath
 * @param  {Object} variables  Any variables to pass to the XPath
 * @param  {Object} options  Any options to pass to the XPath
 */
/*
export function evaluateXPath(xpath, contextNode, formElement, variables = {}, options={}, domFacade = null) {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);

    return fxEvaluateXPath(
        xpath,
        contextNode,
        domFacade,
        {...variablesInScope, ...variables},
        fxEvaluateXPath.ALL_RESULTS_TYPE,
        {
			debug: true,
            currentContext: {formElement, variables},
            moduleImports: {
                xf: XFORMS_NAMESPACE_URI,
            },
            functionNameResolver,
            namespaceResolver,
			language: options.language || evaluateXPath.XPATH_3_1
        },
    );
}
*/
function evaluateXPath(xpath, contextNode, formElement, variables = {}, options = {}) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);
    const result = evaluateXPath$1(xpath, contextNode, null, {
      ...variablesInScope,
      ...variables
    }, evaluateXPath$1.ALL_RESULTS_TYPE, {
      debug: true,
      currentContext: {
        formElement,
        variables
      },
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      functionNameResolver,
      namespaceResolver,
      language: options.language || evaluateXPath$1.XPATH_3_1_LANGUAGE
    });
    // console.log('evaluateXPath',xpath, result);
    return result;
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));

    /*
        formElement.dispatchEvent(
            new CustomEvent('error', {
                composed: false,
                bubbles: true,
                cancelable:true,
                detail: {
                    origin: formElement,
                    message: `Expression '${xpath}' failed`,
                    expr:xpath,
                    level:'Error'},
            }),
        );
    */
    // Return 'nothing' in hope the rest of the page can forgive this
    return [];
  }
}
/**
 * Evaluate an XPath to the first Node
 *
 * @param  {string} xpath  The XPath to run
 * @param  {Node} contextNode The start of the XPath
 * @param  {import('./ForeElementMixin.js').default} formElement  The form element associated to the XPath
 * @returns {Node} The first node found in the XPath
 */
function evaluateXPathToFirstNode(xpath, contextNode, formElement) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);
    const result = evaluateXPathToFirstNode$1(xpath, contextNode, null, variablesInScope, {
      defaultFunctionNamespaceURI: XFORMS_NAMESPACE_URI,
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      currentContext: {
        formElement
      },
      functionNameResolver,
      namespaceResolver
    });
    // console.log('evaluateXPathToFirstNode',xpath, result);
    return result;
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));
  }
}

/**
 * Evaluate an XPath to all nodes
 *
 * @param  {string} xpath  The XPath to run
 * @param  {Node} contextNode The start of the XPath
 * @param  {import('./ForeElementMixin.js').default} formElement  The form element associated to the XPath
 * @return {Node[]}  All nodes
 */
function evaluateXPathToNodes(xpath, contextNode, formElement) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);
    const result = evaluateXPathToNodes$1(xpath, contextNode, null, variablesInScope, {
      currentContext: {
        formElement
      },
      functionNameResolver,
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      namespaceResolver
    });
    // console.log('evaluateXPathToNodes',xpath, result);
    return result;
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));
  }
}

/**
 * Evaluate an XPath to a boolean
 *
 * @param  {string} xpath  The XPath to run
 * @param  {Node} contextNode The start of the XPath
 * @param  {import('./ForeElementMixin.js').default} formElement  The form element associated to the XPath
 * @return {boolean}
 */
function evaluateXPathToBoolean(xpath, contextNode, formElement) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);
    return evaluateXPathToBoolean$1(xpath, contextNode, null, variablesInScope, {
      currentContext: {
        formElement
      },
      functionNameResolver,
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      namespaceResolver
    });
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));
  }
}

/**
 * Evaluate an XPath to a string
 *
 * @param  {string}     xpath             The XPath to run
 * @param  {Node}       contextNode       The start of the XPath
 * @param  {Node}       formElement       The form element associated to the XPath
 * @param  {Node}       formElement       The element where the XPath is defined: used for namespace resolving
 * @param  {import('fontoxpath').IDomFacade}  [domFacade=null]  A DomFacade is used in bindings to intercept DOM
 * access. This is used to determine dependencies between bind elements.
 * @return {string}
 */
function evaluateXPathToString(xpath, contextNode, formElement, domFacade = null) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);
    return evaluateXPathToString$1(xpath, contextNode, domFacade, variablesInScope, {
      currentContext: {
        formElement
      },
      functionNameResolver,
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      namespaceResolver
    });
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));
  }
}

/**
 * Evaluate an XPath to a set of strings
 *
 * @param  {string}     xpath             The XPath to run
 * @param  {Node}       contextNode       The start of the XPath
 * @param  {Node}       formElement       The form element associated to the XPath
 * @param  {Node}       formElement       The element where the XPath is defined: used for namespace resolving
 * @param  {import('fontoxpath').IDomFacade}  [domFacade=null]  A DomFacade is used in bindings to intercept DOM
 * access. This is used to determine dependencies between bind elements.
 * @return {string[]}
 */
function evaluateXPathToStrings(xpath, contextNode, formElement, domFacade = null) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    return evaluateXPathToStrings$1(xpath, contextNode, domFacade, {}, {
      currentContext: {
        formElement
      },
      functionNameResolver,
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      namespaceResolver
    });
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));
  }
}

/**
 * Evaluate an XPath to a number
 *
 * @param  {string}     xpath             The XPath to run
 * @param  {Node}       contextNode       The start of the XPath
 * @param  {Node}       formElement       The form element associated to the XPath
 * @param  {Node}       formElement       The element where the XPath is defined: used for namespace resolving
 * @param  {import('fontoxpath').IDomFacade}  [domFacade=null]  A DomFacade is used in bindings to intercept DOM
 * access. This is used to determine dependencies between bind elements.
 * @return {number}
 */
function evaluateXPathToNumber(xpath, contextNode, formElement, domFacade = null) {
  try {
    const namespaceResolver = createNamespaceResolverForNode(xpath, contextNode, formElement);
    const variablesInScope = getVariablesInScope(formElement);
    return evaluateXPathToNumber$1(xpath, contextNode, domFacade, variablesInScope, {
      currentContext: {
        formElement
      },
      functionNameResolver,
      moduleImports: {
        xf: XFORMS_NAMESPACE_URI
      },
      namespaceResolver
    });
  } catch (e) {
    formElement.dispatchEvent(new CustomEvent('error', {
      composed: false,
      bubbles: true,
      detail: {
        origin: formElement,
        message: `Expression '${xpath}' failed`,
        expr: xpath,
        level: 'Error'
      }
    }));
  }
}
const contextFunction = (dynamicContext, string) => {
  const caller = dynamicContext.currentContext.formElement;
  let instance = null;
  if (string) {
    instance = resolveId(string, caller);
  } else {
    instance = XPathUtil.getParentBindingElement(caller);
  }
  if (instance) {
    if (instance.nodeName === 'FX-REPEAT') {
      const {
        nodeset
      } = instance;
      for (let parent = caller; parent; parent = parent.parentNode) {
        if (parent.parentNode === instance) {
          const offset = Array.from(parent.parentNode.children).indexOf(parent);
          return nodeset[offset];
        }
      }
    }
    return instance.nodeset;
  }
  return caller.getInScopeContext();
};

// todo: implement
const currentFunction = (dynamicContext, string) => {
  dynamicContext.currentContext.formElement;
  return null;
};
const elementFunction = (dynamicContext, string) => {
  dynamicContext.currentContext.formElement;
  const newElement = document.createElement(string);
  return newElement;
};

/**
 * @param id as string
 * @return instance data for given id serialized to string.
 */
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'context'
}, [], 'item()?', contextFunction);

/**
 * @param id as string
 * @return instance data for given id serialized to string.
 */
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'context'
}, ['xs:string'], 'item()?', contextFunction);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'current'
}, ['xs:string'], 'item()?', currentFunction);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'element'
}, ['xs:string'], 'item()?', elementFunction);

/**
 * @param id as string
 * @return instance data for given id serialized to string.
 */
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'log'
}, ['xs:string?'], 'xs:string?', (dynamicContext, string) => {
  const {
    formElement
  } = dynamicContext.currentContext;
  const instance = resolveId(string, formElement, 'fx-instance');
  if (instance) {
    if (instance.getAttribute('type') === 'json') {
      console.warn('log() does not work for JSON yet');
      // return JSON.stringify(instance.getDefaultContext());
    } else {
      const def = new XMLSerializer().serializeToString(instance.getDefaultContext());
      return prettifyXml(def);
    }
  }
  return null;
});
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'fore-attr'
}, ['xs:string?'], 'xs:string?', (dynamicContext, string) => {
  const {
    formElement
  } = dynamicContext.currentContext;
  let parent = formElement;
  if (formElement.nodeType === Node.TEXT_NODE) {
    parent = formElement.parentNode;
  }
  const foreElement = parent.closest('fx-fore');
  if (foreElement.hasAttribute(string)) {
    return foreElement.getAttribute(string);
  }
  return null;
});
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'parse'
}, ['xs:string?'], 'element()?', (_dynamicContext, string) => {
  const parser = new DOMParser();
  const out = parser.parseFromString(string, 'application/xml');
  console.log('parse', out);

  /*
              const {formElement} = dynamicContext.currentContext;
              const instance = resolveId(string, formElement, 'fx-instance');
              if (instance) {
                  if (instance.getAttribute('type') === 'json') {
                      console.warn('log() does not work for JSON yet');
                      // return JSON.stringify(instance.getDefaultContext());
                  } else {
                      const def = new XMLSerializer().serializeToString(instance.getDefaultContext());
                      return Fore.prettifyXml(def);
                  }
              }
      */
  return out.firstElementChild;
});
function buildTree(tree, data) {
  if (!data) return;
  if (data.nodeType === Node.ELEMENT_NODE) {
    if (data.children) {
      const details = document.createElement('details');
      details.setAttribute('data-path', data.nodeName);
      const summary = document.createElement('summary');
      let display = ` <${data.nodeName}`;
      Array.from(data.attributes).forEach(attr => {
        display += ` ${attr.nodeName}="${attr.nodeValue}"`;
      });
      let contents;
      if (data.firstChild && data.firstChild.nodeType === Node.TEXT_NODE && data.firstChild.data.trim() !== '') {
        // console.log('whoooooooooopp');
        contents = data.firstChild.nodeValue;
        display += `>${contents}</${data.nodeName}>`;
      } else {
        display += '>';
      }
      summary.textContent = display;
      details.appendChild(summary);
      if (data.childElementCount !== 0) {
        details.setAttribute('open', 'open');
      } else {
        summary.setAttribute('style', 'list-style:none;');
      }
      tree.appendChild(details);
      Array.from(data.children).forEach(child => {
        // if(child.nodeType === Node.ELEMENT_NODE){
        // child.parentNode.appendChild(buildTree(child));
        buildTree(details, child);
        // }
      });
    }
  } /* else if(data.nodeType === Node.ATTRIBUTE_NODE){
        //create span for now
        // const span = document.createElement('span');
        // span.style.background = 'grey';
        // span.textContent = data.value;
        // tree.appendChild(span);
        tree.setAttribute(data.nodeName,data.value);
    }else {
        tree.textContent = data;
    } */

  // return tree;
}

registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'logtree'
}, ['xs:string?'], 'element()?', (dynamicContext, string) => {
  const {
    formElement
  } = dynamicContext.currentContext;
  const instance = resolveId(string, formElement, 'fx-instance');
  if (instance) {
    // const def = new XMLSerializer().serializeToString(instance.getDefaultContext());
    // const def = JSON.stringify(instance.getDefaultContext());

    const treeDiv = document.createElement('div');
    treeDiv.setAttribute('class', 'logtree');
    // const datatree = buildTree(tree,instance.getDefaultContext());
    // return tree.appendChild(datatree);
    // return  buildTree(root,instance.getDefaultContext());;
    const form = dynamicContext.currentContext.formElement;
    const logtree = form.querySelector('.logtree');
    if (logtree) {
      logtree.parentNode.removeChild(logtree);
    }
    const tree = buildTree(treeDiv, instance.getDefaultContext());
    if (tree) {
      form.appendChild(tree);
    }
  }
  return null;
});
const instance = (dynamicContext, string) => {
  // Spec: https://www.w3.org/TR/xforms-xpath/#The_XForms_Function_Library#The_instance.28.29_Function
  // TODO: handle no string passed (null will be passed instead)

  /**
   * @type {import('./fx-fore.js').FxFore}
   */
  const formElement = evaluateXPathToFirstNode$1('ancestor-or-self::fx-fore[1]', dynamicContext.currentContext.formElement, null, null, {
    namespaceResolver: xhtmlNamespaceResolver
  });
  let lookup = null;
  if (string === null || string === 'default') {
    lookup = formElement.getModel().getDefaultInstance();
  } else {
    lookup = formElement.getModel().getInstance(string);
    if (!lookup) {
      document.querySelector('fx-fore').dispatchEvent(new CustomEvent('error', {
        composed: true,
        bubbles: true,
        detail: {
          origin: 'functions',
          message: `Instance not found '${string}'`,
          level: 'Error'
        }
      }));
    }
  }
  const context = lookup.getDefaultContext();
  if (!context) {
    return null;
  }
  return context;
};
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'index'
}, ['xs:string?'], 'xs:integer?', (dynamicContext, string) => {
  const {
    formElement
  } = dynamicContext.currentContext;
  if (string === null) {
    return 1;
  }
  const repeat = resolveId(string, formElement, 'fx-repeat');

  // const def = instance.getInstanceData();
  if (repeat) {
    return repeat.getAttribute('index');
  }
  return Number(1);
});

// Note that this is not to spec. The spec enforces elements to be returned from the
// instance. However, we allow instances to actually be JSON!
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'instance'
}, [], 'item()?', domFacade => instance(domFacade, null));
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'instance'
}, ['xs:string?'], 'item()?', instance);
const jsonToXml = (_dynamicContext, json) => {
  const escapeXml = str => str.replace(/[^\u0009\u000A\u000D\u0020-\uD7FF\uE000-\uFFFD]/g, char => `\\u${char.charCodeAt(0).toString(16).padStart(4, '0')}`);
  const convert = (obj, parent) => {
    const type = typeof obj;
    if (type === 'number') {
      parent.setAttribute('type', 'number');
      parent.textContent = obj.toString();
    } else if (type === 'boolean') {
      parent.setAttribute('type', 'boolean');
      parent.textContent = obj.toString();
    } else if (obj === null) {
      const node = document.createElement('_');
      node.setAttribute('type', 'null');
      parent.appendChild(node);
    } else if (type === 'string') {
      parent.textContent = escapeXml(obj);
    } else if (Array.isArray(obj)) {
      parent.setAttribute('type', 'array');
      obj.forEach(item => {
        const node = document.createElement('_');
        convert(item, node);
        node.textContent = item;
        parent.appendChild(node);
      });
    } else if (type === 'object') {
      parent.setAttribute('type', 'object');
      Object.entries(obj).forEach(([key, value]) => {
        if (value) {
          const childNode = document.createElement(key.replace(/[^a-zA-Z0-9_]/g, '_'));
          convert(value, childNode);
          parent.appendChild(childNode);
        }
      });
    }
  };
  const root = document.createElement('json');
  if (Array.isArray(json)) {
    root.setAttribute('type', 'array');
  } else {
    root.setAttribute('type', 'object');
  }
  convert(json, root);
  // return root.outerHTML;
  console.log('xml', root);
  return root;
};
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'json2xml'
}, ['item()?'], 'item()?', jsonToXml);
const xmlToJson = (_dynamicContext, xml) => {
  const isElementNode = node => node.nodeType === Node.ELEMENT_NODE;
  const isTextNode = node => node.nodeType === Node.TEXT_NODE;
  const parseNode = node => {
    if (isElementNode(node)) {
      const obj = {};
      if (node.hasAttributes()) {
        obj.type = node.getAttribute('type');
      }
      if (node.childNodes.length === 1 && isTextNode(node.firstChild)) {
        return node.textContent;
      }
      for (const child of node.childNodes) {
        const childName = child.nodeName;
        const childValue = parseNode(child);
        if (obj[childName]) {
          if (!Array.isArray(obj[childName])) {
            obj[childName] = [obj[childName]];
          }
          obj[childName].push(childValue);
        } else {
          obj[childName] = childValue;
        }
      }
      return obj;
    }
    if (isTextNode(node)) {
      return node.textContent;
    }
    return undefined;
  };
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xml, 'application/xml');
  const root = xmlDoc.documentElement;
  return parseNode(root);
};
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'xmltoJson'
}, ['item()?'], 'item()?', xmlToJson);

/*
// Example usage:
const xml = '<json type="object"><given>Mark</given><family>Smith</family></json>';
console.log(xmlToJson(xml));
*/

registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'depends'
}, ['node()*'], 'item()?', (_dynamicContext, nodes) =>
// console.log('depends on : ', nodes[0]);
nodes[0]);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'event'
}, ['xs:string?'], 'item()?', (dynamicContext, arg) => {
  if (!arg) return null;
  for (let ancestor = dynamicContext.currentContext.formElement; ancestor; ancestor = ancestor.parentNode) {
    if (!ancestor.currentEvent) {
      continue;
    }

    // We have a current event. read the property either from detail, or from the event
    // itself.
    // Check detail for custom events! This is how that is passed along
    if (ancestor.currentEvent.detail && typeof ancestor.currentEvent.detail === 'object' && arg in ancestor.currentEvent.detail) {
      return ancestor.currentEvent.detail[arg];
    }

    // arg might be `code`, so currentEvent.code should work
    if (arg.includes('.')) {
      return _propertyLookup(ancestor.currentEvent, arg);
    }
    return ancestor.currentEvent[arg] || null;
  }
  return null;
});
function _propertyLookup(obj, path) {
  const parts = path.split('.');
  if (parts.length == 1) {
    return obj[parts[0]];
  }
  return _propertyLookup(obj[parts[0]], parts.slice(1).join('.'));
}

// Implement the XForms standard functions here.
registerXQueryModule(`
    module namespace xf="${XFORMS_NAMESPACE_URI}";

    declare %public function xf:boolean-from-string($str as xs:string) as xs:boolean {
        lower-case($str) = "true" or $str = "1"
    };
`);

// How to run XQUERY:
/**
 registerXQueryModule(`
 module namespace my-custom-namespace = "my-custom-uri";
 (:~
 Insert attribute somewhere
 ~:)
 declare %public %updating function my-custom-namespace:do-something ($ele as element()) as xs:boolean {
	if ($ele/@done) then false() else
	(insert node
	attribute done {"true"}
	into $ele, true())
};
 `)
 // At some point:
 const contextNode = null;
 const pendingUpdatesAndXdmValue = evaluateUpdatingExpressionSync('ns:do-something(.)', contextNode, null, null, {moduleImports: {'ns': 'my-custom-uri'}})

 console.log(pendingUpdatesAndXdmValue.xdmValue); // this is true or false, see function

 executePendingUpdateList(pendingUpdatesAndXdmValue.pendingUpdateList, null, null, null);
 */

/**
 * @param input as string
 * @return {string}
 */
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'base64encode'
}, ['xs:string?'], 'xs:string?', (_dynamicContext, string) => btoa(string));
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'local-date'
}, [], 'xs:string?', (_dynamicContext, _string) => new Date().toLocaleDateString());
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'local-dateTime'
}, [], 'xs:string?', (_dynamicContext, _string) => new Date().toLocaleString());
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri'
}, [], 'xs:string?', (_dynamicContext, _string) => window.location.href);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-fragment'
}, [], 'xs:string?', (_dynamicContext, _arg) => window.location.hash);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-host'
}, [], 'xs:string?', (_dynamicContext, _arg) => window.location.host);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-query'
}, [], 'xs:string?', (_dynamicContext, _arg) => window.location.search);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-relpath'
}, [], 'xs:string?', (_dynamicContext, _arg) => {
  const path = new URL(window.location.href).pathname;
  return path.substring(0, path.lastIndexOf('/') + 1);
});
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-path'
}, [], 'xs:string?', (_dynamicContext, _arg) => new URL(window.location.href).pathname);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-port'
}, [], 'xs:string?', (_dynamicContext, _arg) => window.location.port);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-param'
}, ['xs:string?'], 'xs:string?', (_dynamicContext, arg) => {
  if (!arg) return null;
  const {
    search
  } = window.location;
  const urlparams = new URLSearchParams(search);
  const param = urlparams.get(arg);
  return param || '';
});
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-scheme'
}, [], 'xs:string?', (_dynamicContext, _arg) => new URL(window.location.href).protocol);
registerCustomXPathFunction({
  namespaceURI: XFORMS_NAMESPACE_URI,
  localName: 'uri-scheme-specific-part'
}, [], 'xs:string?', (_dynamicContext, _arg) => {
  const uri = window.location.href;
  return uri.substring(uri.indexOf(':') + 1, uri.length);
});

/**
 * @param {Node} node
 * @returns {HTMLElement}
 */
function _getElement(node) {
  if (node && node.nodeType && node.nodeType === Node.ATTRIBUTE_NODE) {
    // The context of an attribute is the ref of the element it's defined on
    return node.ownerElement;
  }
  if (node.nodeType === Node.ELEMENT_NODE) {
    // The context of a query should be the element having a ref
    return node;
  }

  // For text nodes, just start looking from the parent element
  return node.parentNode;
}
function _getForeContext(node) {
  return XPathUtil.getClosest('fx-fore', node);
}
function _getModelInContext(node) {
  // const ownerForm = node.closest('fx-fore');
  const ownerForm = _getForeContext(node);
  return ownerForm.getModel();
}
function _getInitialContext(node, ref) {
  const parentBind = XPathUtil.getClosest('[ref]', node);
  const localFore = XPathUtil.getClosest('fx-fore', node);
  const model = _getModelInContext(node);
  if (parentBind !== null) {
    /*
        make sure that the closest ref belongs to the same fx-fore element
        */
    const parentBindFore = parentBind.closest('fx-fore');
    if (localFore === parentBindFore) {
      return parentBind.nodeset;
    }
    return model.getDefaultInstance().getDefaultContext();
  }
  if (XPathUtil.isAbsolutePath(ref)) {
    const instanceId = XPathUtil.getInstanceId(ref, node);
    if (instanceId) {
      return model.getInstance(instanceId).getDefaultContext();
    }
    return model.getDefaultInstance().getDefaultContext();
  }
  // should always return default context if all other fails
  return model.getDefaultInstance().getDefaultContext();
}

/**
 * Get the inscope context for an XPath defined on an element, attribute or in a textnode. Uses the
 * current iterate status, repeats, etcetera
 *
 * @param {Node} node The context node at this point. Can be an attribute
 * @param {string} ref The XPath to resolve for
 * @return {Node} The context item for this XPath
 */
function getInScopeContext(node, ref) {
  // console.log('getInScopeContext', ref, node);

  //todo: check for multi-step pathes
  const parentElement = _getElement(node);
  // console.log('getInScopeContext parent', parentElement);

  if (parentElement.nodeName === 'FX-FORE') {
    const context = parentElement.getModel().getDefaultInstance()?.getDefaultContext();
    if (!context) {
      // Edge-case, we are in an inner fore. Use the outer fore's default context
      return getInScopeContext(parentElement.parentNode, ref);
    }
    return context;
  }
  const parentBind = XPathUtil.getClosest('[ref]', parentElement.parentNode);
  if (parentBind && (parentBind.nodeName === 'FX-GROUP' || parentBind.nodeName === 'FX-CONTROL')) {
    return parentBind.nodeset;
  }
  const parentActionWithIterateExpr = parentElement.matches('[iterate]') ? parentElement : XPathUtil.getClosest('[iterate]', parentElement.parentNode);
  if (parentActionWithIterateExpr && parentActionWithIterateExpr.currentContext) {
    return parentActionWithIterateExpr.currentContext;
  }
  const repeatItem = XPathUtil.getClosest('fx-repeatitem', parentElement);
  if (repeatItem) {
    if (node.nodeName === 'context') {
      return evaluateXPathToFirstNode(node.nodeValue, repeatItem.nodeset, _getForeContext(parentElement));
    }
    return repeatItem.nodeset;
  }

  // ### check for repeatitems created by fx-repeat-attributes - this could possibly be unified with standard repeats
  // const repeatItemFromAttrs = XPathUtil.getClosest('.fx-repeatitem', parentElement);
  // const repeatItemFromAttrs = XPathUtil.getClosest('.fx-repeatitem', parentElement);
  const repeatItemFromAttrs = parentElement.closest('.fx-repeatitem');
  if (repeatItemFromAttrs) {
    // ### determine correct inscopecontext by determining the index of the repeatitem in its parent list and
    // ### using that as an index on the repeat nodeset
    const parent = repeatItemFromAttrs.parentNode;
    const index = Array.from(parent.children).indexOf(repeatItemFromAttrs);

    // ### fetching nodeset from fx-repeat-attributes element
    const repeatFromAttributes = XPathUtil.getClosest('fx-repeat-attributes', parentElement);
    return repeatFromAttributes.nodeset[index];
  }
  if (parentElement.hasAttribute('context')) {
    const initialContext = _getInitialContext(parentElement.parentNode, ref);
    const contextAttr = parentElement.getAttribute('context');
    return evaluateXPathToFirstNode(contextAttr, initialContext, _getForeContext(parentElement));
  }
  if (node.nodeType === Node.ATTRIBUTE_NODE && node.nodeName === 'context') {
    const initialContext = _getInitialContext(node.ownerElement.parentNode, ref);
    const contextAttr = node.ownerElement.getAttribute('context');
    return evaluateXPathToFirstNode(contextAttr, initialContext, _getForeContext(parentElement));
  }
  if (node.nodeType === Node.ATTRIBUTE_NODE && node.nodeName === 'ref') {
    // Note: do not consider the ref of the owner element since it should not be used to define the
    // context
    if (node.ownerElement.hasAttribute('context')) {
      const initialContext = _getInitialContext(node.ownerElement.parentNode, ref);
      const contextAttr = node.ownerElement.getAttribute('context');
      return evaluateXPathToFirstNode(contextAttr, initialContext, _getForeContext(parentElement));
    }

    // Never resolve the context from a ref itself!
    return _getInitialContext(parentElement.parentNode, ref);
  }

  // if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('context')) {
  //   const initialContext = _getInitialContext(node.parentNode, ref);
  //   const contextAttr = node.getAttribute('context');
  //   return evaluateXPathToFirstNode(contextAttr, initialContext, _getForeContext(parentElement));
  // }
  return _getInitialContext(parentElement, ref);
}

/**
 * Class hosting common utility functions used throughout all fore elements
 *
 * @example ../doc/demo.html
 */
class Fore {
  /**
   * Loads and return a piece of HTML
   * @param url {String} - the Url to load from
   * @returns {Promise<string>}
   */
  static async loadHtml(url) {
    try {
      const response = await fetch(url, {
        method: 'GET',
        mode: 'cors',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'text/html'
        }
      });
      const responseContentType = response.headers.get('content-type').toLowerCase();
      if (responseContentType.startsWith('text/html')) {
        return response.text();
      }
      Fore.dispatch(this, 'error', {
        message: `Response has wrong contentType '${responseContentType}'. Should be 'text/html'`,
        level: 'Error'
      });
    } catch (error) {
      Fore.dispatch(this, 'error', {
        message: `Html couldn't be loaded from '${url}'`,
        level: 'Error'
      });
    }
  }

  /**
   * loads a Fore element from given `src`. Always returns the first occurrence of a `<fx-fore>`. The retured element
   * will replace the `replace` element in the DOM.
   *
   * @param {Element} replace the element with a `src` attribute to resolv.
   * @param {string} src the Url to resolve
   * @param {string} selector a querySelector expression to fetch certain element from loaded document
   * @returns {Promise<HTMLElement>} The replacement element
   */
  static async loadForeFromSrc(replace, src, selector) {
    if (!src) {
      Fore.dispatch(this, 'error', {
        detail: {
          message: "No 'src' attribute present"
        }
      });
      return null;
    }
    const data = await Fore.loadHtml(src);
    const parsed = new DOMParser().parseFromString(data, 'text/html');
    // const theFore = parsed.querySelector('fx-fore');
    const foreElement = parsed.querySelector(selector);
    // console.log('foreElement', foreElement)
    if (!foreElement) {
      Fore.dispatch(this, 'error', {
        detail: {
          message: `Fore element not found in '${src}'. Maybe wrapped within 'template' element?`
        }
      });
      return;
    }
    foreElement.setAttribute('from-src', src);
    const thisAttrs = replace.attributes;
    Array.from(thisAttrs).forEach(attr => {
      if (attr.name !== 'src') {
        foreElement.setAttribute(attr.name, attr.value);
      }
    });
    replace.replaceWith(foreElement);
    return foreElement;
  }
  static buildPredicates(node) {
    let attrPredicate = '';
    Array.from(node.attributes).forEach(attr => {
      // attrMap.set(attr.nodeName,attr.nodeValue);
      // if(attr.nodeName !== 'xmlns'){
      //   if(attr.nodeValue !== ''){
      //     attrPredicate += `[@${attr.nodeName}='${attr.nodeValue}']`;
      //   }else{
      attrPredicate += `[@${attr.nodeName}]`;
      // }
      // }
    });

    return attrPredicate;
  }

  /**
   * returns true if target element is the widget itself or some element within the widget.
   * @param {HTMLElement} target an event target
   * @returns {boolean}
   */
  static isWidget(target) {
    if (target?.classList.contains('widget')) return true;
    let parent = target.parentNode;
    while (parent && parent.nodeName !== 'FX-CONTROL') {
      if (parent?.classList?.contains('widget')) return true;
      parent = parent.parentNode;
    }
    return false;
  }

  /**
   * Get a string that can be used as a path to a node
   *
   * @param {Node} node
   * @returns {string}
   */
  static getDomNodeIndexString(node) {
    const indexes = [];
    let currentNode = node;
    while (currentNode && currentNode.parentNode) {
      const parent = currentNode.parentNode;
      if (parent.childNodes && parent.childNodes.length > 0) {
        const index = [...parent.childNodes].indexOf(currentNode);
        indexes.unshift(index);
      }
      currentNode = parent;
    }
    return indexes.join('.');
  }

  /**
   * Get the expression part of something
   * @param {string} input
   * @returns {string}
   */
  static getExpression(input) {
    if (input.startsWith('{') && input.endsWith('}')) {
      return input.substring(1, input.length - 1);
    }
    return input;
  }

  /**
   * returns the next `fx-fore` element upwards in tree
   *
   * @param {HTMLElement|Text} start
   * @returns {import('./fx-fore.js').FxFore}
   */
  static getFore(start) {
    return start.nodeType === Node.TEXT_NODE ? start.parentNode.closest('fx-fore') : start.closest('fx-fore');
  }
  static get ACTION_ELEMENTS() {
    return ['FX-ACTION', 'FX-DELETE', 'FX-DISPATCH', 'FX-HIDE', 'FX-INSERT', 'FX-LOAD', 'FX-MESSAGE', 'FX-REBUILD', 'FX-RECALCULATE', 'FX-REFRESH', 'FX-RENEW', 'FX-RELOAD', 'FX-REPLACE', 'FX-RESET', 'FX-RETAIN', 'FX-RETURN', 'FX-REVALIDATE', 'FX-SEND', 'FX-SETFOCUS', 'FX-SETINDEX', 'FX-SETVALUE', 'FX-SHOW', 'FX-TOGGLE', 'FX-UPDATE'];
  }
  static createUUID() {
    // http://www.ietf.org/rfc/rfc4122.txt
    const s = [];
    const hexDigits = '0123456789abcdef';
    for (let i = 0; i < 36; i += 1) {
      s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }
    s[14] = '4'; // bits 12-15 of the time_hi_and_version field to 0010
    s[19] = hexDigits.substr(s[19] & 0x3 | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
    s[8] = s[13] = s[18] = s[23] = '-';
    const uuid = s.join('');
    return uuid;
  }
  static get XFORMS_NAMESPACE_URI() {
    // todo: should be centralized somewhere as constant. Exists in several? places
    return 'http://www.w3.org/2002/xforms';
  }

  /**
   * @param {string} elementName
   * @returns {boolean}
   */
  static isActionElement(elementName) {
    return Fore.ACTION_ELEMENTS.includes(elementName);
  }
  static get UI_ELEMENTS() {
    return ['FX-ALERT', 'FX-CONTROL', 'FX-DIALOG', 'FX-FILENAME', 'FX-MEDIATYPE', 'FX-GROUP', 'FX-HINT', 'FX-ITEMS', 'FX-OUTPUT', 'FX-RANGE', 'FX-REPEAT', 'FX-REPEATITEM', 'FX-REPEAT-ATTRIBUTES', 'FX-SWITCH', 'FX-SECRET', 'FX-SELECT', 'FX-SUBMIT', 'FX-TEXTAREA', 'FX-TRIGGER', 'FX-UPLOAD', 'FX-VAR'];
  }
  static get MODEL_ELEMENTS() {
    return ['FX-BIND', 'FX-FUNCTION', 'FX-MODEL', 'FX-INSTANCE', 'FX-SUBMISSION'];
  }

  /**
   * @param {string} elementName
   * @returns {boolean}
   */
  static isUiElement(elementName) {
    Fore.UI_ELEMENTS.includes(elementName);
    return Fore.UI_ELEMENTS.includes(elementName);
  }

  /**
   * recursively refreshes all UI Elements.
   *
   * @param {HTMLElement} startElement
   * @param {(boolean|{reason:'index-function', elementLocalnamesWithChanges: string[]})} force Whether to do a forced refresh. Forced
   * refreshes are very bad for performance, try to limit them. If the forced refresh is because index functions may change, it is better to pass the reason
   * @returns {Promise<void>}
   */
  static async refreshChildren(startElement, force) {
    const refreshed = new Promise(resolve => {
      /*
      if there's an 'refresh-on-view' attribute the element wants to be handled by
      handleIntersect function that calls the refresh of the respective element and
      not the global one.
       */
      // if(!force && startElement.hasAttribute('refresh-on-view')) return;

      /*  ### attempt with querySelectorAll is even slower than iterating recursively
       const children = startElement.querySelectorAll('[ref]');
      Array.from(children).forEach(uiElement => {
        if (Fore.isUiElement(uiElement.nodeName) && typeof uiElement.refresh === 'function') {
          uiElement.refresh();
        }
      });
      */
      const {
        children
      } = startElement;
      if (children) {
        for (const element of Array.from(children)) {
          if (element.nodeName.toUpperCase() === 'FX-FORE') {
            break;
          }
          if (Fore.isUiElement(element.nodeName) && typeof element.refresh === 'function') {
            /**
             * @type {import('./ForeElementMixin.js').default}
             */
            const bound = element;
            if (!force) {
              continue;
            }
            if (force === true) {
              // Unconditional force refresh
              bound.refresh(force);
              continue;
            }
            if (typeof force !== 'object') {
              continue;
            }
            if (force.reason === 'index-function' && bound.dependencies.isInvalidatedByIndexFunction()) {
              bound.refresh(force);
              continue;
            }
            if (bound.dependencies.isInvalidatedByChildlistChanges(force.elementLocalnamesWithChanges)) {
              bound.refresh(force);
              continue;
            }

            // console.log('refreshing', element, element?.ref);
            // console.log('refreshing ',element);
          }

          if (!(element.inert === true)) {
            // testing for inert catches model and action elements and should just leave updateable html elements
            Fore.refreshChildren(element, force);
          }
        }
      }
      resolve('done');
    });
    return refreshed;
  }
  static copyDom(inputElement) {
    console.time('convert');
    const target = new DOMParser().parseFromString('<fx-fore></fx-fore>', 'text/html');
    console.log('copyDom new doc', target);
    console.log('copyDom new body', target.body);
    console.log('copyDom new body', target.querySelector('fx-fore'));
    const newFore = target.querySelector('fx-fore');
    this.convertFromSimple(inputElement, newFore);
    newFore.removeAttribute('convert');
    console.log('converted', newFore);
    console.timeEnd('convert');
    return newFore;
  }
  static convertFromSimple(startElement, targetElement) {
    const children = startElement.childNodes;
    if (children) {
      Array.from(children).forEach(node => {
        const lookFor = `FX-${node.nodeName.toUpperCase()}`;
        if (Fore.MODEL_ELEMENTS.includes(lookFor) || Fore.UI_ELEMENTS.includes(lookFor) || Fore.ACTION_ELEMENTS.includes(lookFor)) {
          const conv = targetElement.ownerDocument.createElement(lookFor);
          console.log('conv', node, conv);
          targetElement.appendChild(conv);
          Fore.copyAttributes(node, conv);
          Fore.convertFromSimple(node, conv);
        } else {
          if (node.nodeType === Node.TEXT_NODE) {
            const copied = targetElement.ownerDocument.createTextNode(node.textContent);
            targetElement.appendChild(copied);
          }
          if (node.nodeType === Node.ELEMENT_NODE) {
            const copied = targetElement.ownerDocument.createElement(node.nodeName);
            targetElement.appendChild(copied);
            Fore.copyAttributes(node, targetElement);
            Fore.convertFromSimple(node, copied);
          }
        }
      });
    }
  }
  static copyAttributes(source, target) {
    return Array.from(source.attributes).forEach(attribute => {
      target.setAttribute(attribute.nodeName, attribute.nodeValue);
    });
  }

  /**
   * returns the proper content-type for instance.
   *
   * @param instance an fx-instance element
   * @param contentType - the contentType
   * @returns {string|null}
   */
  static getContentType(instance, contentType) {
    if (contentType === 'application/x-www-form-urlencoded') {
      return 'application/x-www-form-urlencoded; charset=UTF-8';
    }
    if (instance.type === 'xml') {
      return 'application/xml; charset=UTF-8';
    }
    if (instance.type === 'json') {
      return 'application/json';
    }
    console.warn('content-type unknown ', instance.type);
    return null;
  }
  static async handleResponse(response) {
    const {
      status
    } = response;
    if (status >= 400) {
      // console.log('response status', status);
      alert(`response status:  ${status} - failed to load data for '${this.src}' - stopping.`);
      throw new Error(`failed to load data - status: ${status}`);
    }
    const responseContentType = response.headers.get('content-type').toLowerCase();
    // console.log('********** responseContentType *********', responseContentType);
    if (responseContentType.startsWith('text/html')) {
      // const htmlResponse = response.text();
      // return new DOMParser().parseFromString(htmlResponse, 'text/html');
      // return response.text();
      return response.text().then(result =>
      // console.log('xml ********', result);
      new DOMParser().parseFromString(result, 'text/html'));
    }
    if (responseContentType.startsWith('text/plain') || responseContentType.startsWith('text/markdown')) {
      // console.log("********** inside  res plain *********");
      return response.text();
    }
    if (responseContentType.startsWith('application/json')) {
      // console.log("********** inside res json *********");
      return response.json();
    }
    if (responseContentType.startsWith('application/xml')) {
      const text = await response.text();
      // console.log('xml ********', result);
      return new DOMParser().parseFromString(text, 'application/xml');
    }
    return 'done';
  }

  /*
  static evaluateAttributeTemplateExpression(expr, node) {
    const matches = expr.match(/{[^}]*}/g);
    if (matches) {
      matches.forEach(match => {
        console.log('match ', match);
        const naked = match.substring(1, match.length - 1);
        const inscope = getInScopeContext(node, naked);
        const result = evaluateXPathToString(naked, inscope, node.getOwnerForm());
        const replaced = expr.replaceAll(match, result);
        console.log('replacing ', expr, ' with ', replaced);
        expr = replaced;
      });
    }
    return expr;
  }
  */

  static fadeInElement(element) {
    const duration = 600;
    let fadeIn = () => {
      // Stop all current animations
      if (element.getAnimations) {
        element.getAnimations().map(anim => anim.finish());
      }

      // Play the animation with the newly specified duration
      fadeIn = element.animate({
        opacity: [0, 1]
      }, duration);
      return fadeIn.finished;
    };
    return fadeIn();
  }
  static fadeOutElement(element, duration) {
    // const duration = duration;
    let fadeOut = () => {
      // Stop all current animations
      if (element.getAnimations) {
        element.getAnimations().map(anim => anim.finish());
      }

      // Play the animation with the newly specified duration
      fadeOut = element.animate({
        opacity: [1, 0]
      }, duration);
      return fadeOut.finished;
    };
    return fadeOut();
  }
  static async dispatch(target, eventName, detail) {
    if (!XPathUtil.contains(target?.ownerDocument, target)) {
      // The target is gone from the document. This happens when we are done with a refresh that removed the component
      return;
    }
    const event = new CustomEvent(eventName, {
      composed: false,
      bubbles: true,
      detail
    });
    event.listenerPromises = [];
    target.dispatchEvent(event);

    // By now, all listeners for the event should have registered their completion promises to us.
    if (event.listenerPromises.length) {
      await Promise.all(event.listenerPromises);
    }
    // console.log('!!! DISPATCH_DONE', eventName);
  }

  static formatXml(xml) {
    const reg = /(>)(<)(\/*)/g;
    const wsexp = / *(.*) +\n/g;
    const contexp = /(<.+>)(.+\n)/g;
    xml = xml.replace(reg, '$1\n$2$3').replace(wsexp, '$1\n').replace(contexp, '$1\n$2');
    const lines = xml.split('\n');
    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i];
      Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />
      Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>
      Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)
    }
  }
  static stringifiedComponent(element) {
    return `<${element.localName} ${Array.from(element.attributes).map(attr => `${attr.name}="${attr.value}"`).join(' ')}></${element.localName}>`;
  }
  /*
  static async loadForeFromUrl(hostElement, url) {
    // console.log('########## loading Fore from ', this.src, '##########');
    await fetch(url, {
      method: 'GET',
      mode: 'cors',
      credentials: 'include',
      headers: {
        'Content-Type': 'text/html',
      },
    })
      .then(response => {
        const responseContentType = response.headers.get('content-type').toLowerCase();
        console.log('********** responseContentType *********', responseContentType);
        if (responseContentType.startsWith('text/html')) {
          return response.text().then(result =>
            // console.log('xml ********', result);
            new DOMParser().parseFromString(result, 'text/html'),
          );
        }
        return 'done';
      })
      .then(data => {
        // const theFore = fxEvaluateXPathToFirstNode('//fx-fore', data.firstElementChild);
        const theFore = data.querySelector('fx-fore');
        // console.log('thefore', theFore)
        if (!theFore) {
          hostElement.dispatchEvent(
            new CustomEvent('error', {
              composed: false,
              bubbles: true,
              detail: {
                message: 'cyclic graph',
              },
            }),
          );
        }
        const imported = document.importNode(theFore,true);
        console.log(`########## loaded fore as component ##### ${hostElement.url}`);
        imported.addEventListener(
            'model-construct-done',
            e => {
              // console.log('subcomponent ready', e.target);
              const defaultInst = imported.querySelector('fx-instance');
              // console.log('defaultInst', defaultInst);
              if(hostElement.initialNode){
                const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');
                // Note: Clone the input to prevent the inner fore from editing the outer node
                doc.firstElementChild.appendChild(hostElement.initialNode.cloneNode(true));
                // defaultinst.setInstanceData(this.initialNode);
                defaultInst.setInstanceData(doc);
              }
              // console.log('new data', defaultInst.getInstanceData());
              // theFore.getModel().modelConstruct();
              imported.getModel().updateModel();
              imported.refresh();
              return 'done';
             },
            { once: true },
        );
         const dummy = hostElement.querySelector('input');
        if (hostElement.hasAttribute('shadow')) {
          dummy.parentNode.removeChild(dummy);
          hostElement.shadowRoot.appendChild(imported);
        } else {
          // console.log(this, 'replacing widget with',theFore);
          dummy.replaceWith(imported);
          // this.appendChild(imported);
        }
      })
      /!*.catch(error => {
        hostElement.dispatchEvent(
          new CustomEvent('error', {
            composed: false,
            bubbles: true,
            detail: {
              error: error,
              message: `'${url}' not found or does not contain Fore element.`,
            },
          }),
        );
      });*!/
  }
  */

  /**
   * clear all text nodes and attribute values to get a 'clean' template.
   * @param n
   * @private
   */
  /*
    static clear(n) {
      n.textContent = '';
      if (n.hasAttributes()) {
        const attrs = n.attributes;
        for (let i = 0; i < attrs.length; i+= 1) {
          attrs[i].value = '';
        }
      }
      const { children } = n;
      for (let i = 0; i < children.length; i+= 1) {
        Fore.clear(children[i]);
      }
    }
  */
}
Fore.READONLY_DEFAULT = false;
Fore.REQUIRED_DEFAULT = false;
Fore.RELEVANT_DEFAULT = true;
Fore.CONSTRAINT_DEFAULT = true;
Fore.TYPE_DEFAULT = 'xs:string';

async function handleResponse(fxInstance, response) {
  const {
    status
  } = response;
  if (status >= 400) {
    // console.log('response status', status);
    alert(`response status:  ${status} - failed to load data for '${fxInstance.src}' - stopping.`);
    throw new Error(`failed to load data - status: ${status}`);
  }
  const responseContentType = response.headers.get('content-type').toLowerCase();
  // console.log('********** responseContentType *********', responseContentType);
  if (responseContentType.startsWith('text/html')) {
    // const htmlResponse = response.text();
    // return new DOMParser().parseFromString(htmlResponse, 'text/html');
    // return response.text();
    return response.text().then(result =>
    // console.log('xml ********', result);
    new DOMParser().parseFromString(result, 'text/html'));
  }
  if (responseContentType.startsWith('text/')) {
    // console.log("********** inside  res plain *********");
    return response.text();
  }
  if (responseContentType.startsWith('application/json')) {
    // console.log("********** inside res json *********");
    return response.json();
  }
  if (responseContentType.startsWith('application/xml') || responseContentType.startsWith('text/xml')) {
    // See https://www.rfc-editor.org/rfc/rfc7303
    const text = await response.text();
    // console.log('xml ********', result);
    return new DOMParser().parseFromString(text, 'application/xml');
  }
  throw new Error(`unable to handle response content type: ${responseContentType}`);
}

/**
 * Container for data instances.
 *
 * Offers several ways of loading data from either inline content or via 'src' attribute which will use the fetch
 * API to resolve data.
 */
class FxInstance extends HTMLElement {
  constructor() {
    super();
    this.model = this.parentNode;
    this.attachShadow({
      mode: 'open'
    });
    this.originalInstance = null;
    this.partialInstance = null;
    this.credentials = '';
  }
  connectedCallback() {
    // console.log('connectedCallback ', this);
    if (this.hasAttribute('src')) {
      this.src = this.getAttribute('src');
    }
    if (this.hasAttribute('id')) {
      this.id = this.getAttribute('id');
    } else {
      this.id = 'default';
    }
    this.credentials = this.hasAttribute('credentials') ? this.getAttribute('credentials') : 'same-origin';
    if (!['same-origin', 'include', 'omit'].includes(this.credentials)) {
      console.error(`fx-submission: the value of credentials is not valid. Expected 'same-origin', 'include' or 'omit' but got '${this.credentials}'`, this);
    }
    if (this.hasAttribute('type')) {
      this.type = this.getAttribute('type');
    } else {
      this.type = 'xml';
      this.setAttribute('type', this.type);
    }
    const style = `
            :host {
                display: none;
            }
            :host * {
                display:none;
            }
            ::slotted(*){
                display:none;
            }
        `;
    const html = `
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;
    this.partialInstance = {};
  }

  /**
   * Is called by fx-model during initialization phase (model-construct)
   * @returns {Promise<void>}
   */
  async init() {
    // console.log('fx-instance init');
    await this._initInstance();
    // console.log(`### <<<<< instance ${this.id} loaded >>>>> `);
    this.dispatchEvent(new CustomEvent('instance-loaded', {
      composed: true,
      bubbles: true,
      detail: {
        instance: this
      }
    }));
    return this;
  }
  reset() {
    // this._useInlineData();
    this.instanceData = this.originalInstance.cloneNode(true);
  }
  evalXPath(xpath) {
    const formElement = this.parentElement.parentElement;
    const result = evaluateXPathToFirstNode(xpath, this.getDefaultContext(), formElement);
    return result;
  }

  /**
   * returns the current instance data
   *
   * @returns {Document | T | any}
   */
  getInstanceData() {
    if (!this.instanceData) {
      this.createInstanceData();
    }
    return this.instanceData;
  }
  setInstanceData(data) {
    if (!data) {
      this.createInstanceData();
      return;
    }
    this._setInitialData(data);
    // this.instanceData = data;
  }

  /**
   * return the default context (root node of respective instance) for XPath evalution.
   *
   * @returns {Document|T|any|Element}
   */
  getDefaultContext() {
    // Note: use the getter here: it might provide us with stubbed data if anything async is racing,
    // such as an @src attribute
    const instanceData = this.getInstanceData();
    if (this.type === 'xml') {
      return instanceData.firstElementChild;
    }
    return instanceData;
  }

  /**
   * does the actual loading of data. Handles inline data, data loaded via fetch() or data constructed from
   * querystring.
   *
   * @returns {Promise<void>}
   * @private
   */
  async _initInstance() {
    if (this.src === '#querystring') {
      /*
       * generate XML data from URL querystring
       * todo: there's no variant to generate JSON yet
       */
      // eslint-disable-next-line no-restricted-globals
      const query = new URLSearchParams(location.search);
      const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');
      const root = doc.firstElementChild;
      for (const p of query) {
        const newNode = doc.createElement(p[0]);
        newNode.appendChild(doc.createTextNode(p[1]));
        root.appendChild(newNode);
      }
      this._setInitialData(doc);
    } else if (this.src) {
      await this._loadData();
    } else if (this.childNodes.length !== 0) {
      this._useInlineData();
    }
  }
  createInstanceData() {
    if (this.type === 'xml') {
      // const doc = new DOMParser().parseFromString('<data data-id="default"></data>', 'application/xml');
      const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');
      this.instanceData = doc;
      this.originalInstance = this.instanceData.cloneNode(true);
    }
    if (this.type === 'json') {
      this.instanceData = {};
      this.originalInstance = [...this.instanceData];
    }
    if (this.type === 'text') {
      this.instanceData = this.innerText;
      this.originalInstance = this.innerText;
      console.log('text data', this.instanceData);
    }
  }
  async _loadData() {
    const url = `${this.src}`;
    if (url.startsWith('localStore')) {
      const key = url.substring(url.indexOf(':') + 1);
      const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');
      this.instanceData = doc;
      // ### does it make sense to store originalData here?

      if (!key) {
        console.warn('no key specified for localStore');
        return;
      }
      const serialized = localStorage.getItem(key);
      if (!serialized) {
        console.warn(`Data for key ${key} cannot be found`);
        this._useInlineData();
        return;
      }
      const data = new DOMParser().parseFromString(serialized, 'application/xml');
      // let data = this._parse(serialized, instance);
      doc.firstElementChild.replaceWith(data.firstElementChild);
      return;
    }
    const contentType = Fore.getContentType(this, 'get');
    try {
      const response = await fetch(url, {
        method: 'GET',
        credentials: this.credentials,
        mode: 'cors',
        headers: {
          'Content-Type': contentType
        }
      });
      const data = await handleResponse(this, response);
      this._setInitialData(data);
      /*
      if (data.nodeType) {
        this._setInitialData(data);
        this.instanceData = data;
        this.originalInstance = this.instanceData.cloneNode(true);
        console.log('instanceData loaded: ', this.id, this.instanceData);
        return;
      }
      this.instanceData = data;
      this.originalInstance = [...data];
      */
    } catch (error) {
      throw new Error(`failed loading data ${error}`);
    }
  }
  _setInitialData(data) {
    this.instanceData = data;
    if (data.nodeType) {
      this.originalInstance = this.instanceData.cloneNode(true);
    } else {
      this.originalInstance = {
        ...this.instanceData
      };
    }
  }
  _getContentType() {
    if (this.type === 'xml') {
      return 'application/xml';
    }
    if (this.type === 'json') {
      return 'application/json';
    }
    console.warn('content-type unknown ', this.type);
    return null;
  }
  _useInlineData() {
    if (this.type === 'xml') {
      // console.log('innerHTML ', this.innerHTML);
      const instanceData = new DOMParser().parseFromString(this.innerHTML, 'application/xml');

      // console.log('fx-instance init id:', this.id);
      // this.instanceData = instanceData;
      this._setInitialData(instanceData);
      // console.log('instanceData ', this.instanceData);
      // console.log('instanceData ', this.instanceData.firstElementChild);

      // console.log('fx-instance data: ', this.instanceData);
      // this.instanceData.firstElementChild.setAttribute('id', this.id);
      // todo: move innerHTML out to shadowDOM (for later reset)
    } else if (this.type === 'json') {
      // this.instanceData = JSON.parse(this.textContent);
      this._setInitialData(JSON.parse(this.textContent));
    } else if (this.type === 'html') {
      // this.instanceData = this.firstElementChild.children;
      this._setInitialData(this.firstElementChild.children);
    } else if (this.type === 'text') {
      // this.instanceData = this.textContent;
      this._setInitialData(this.textContent);
    } else {
      console.warn('unknow type for data ', this.type);
    }
  }

  // _handleResponse() {
  //   console.log('_handleResponse ');
  //   const ajax = this.shadowRoot.getElementById('loader');
  //   const instanceData = new DOMParser().parseFromString(ajax.lastResponse, 'application/xml');
  //   this.instanceData = instanceData;
  //   console.log('data: ', this.instanceData);
  // }

  /*
  _handleError() {
    const loader = this.shadowRoot.getElementById('loader');
    console.log('_handleResponse ', loader.lastError);
  }
  */
}

if (!customElements.get('fx-instance')) {
  customElements.define('fx-instance', FxInstance);
}

/**
 * Class for holding ModelItem facets.
 *
 * A ModelItem annotates nodes that are referred by a fx-bind element with facets for calculation and validation.
 *
 * Each bound node in an instance has exactly one ModelItem associated with it.
 */
class ModelItem {
  /**
   *
   * @param {string} path calculated normalized path expression linking to data
   * @param {string} ref relative binding expression
   * @param {boolean} readonly - boolean to signal readonly/readwrite state
   * @param {boolean} relevant - boolean to signal relevant/non-relevant state
   * @param {boolean} required - boolean to signal required/optional state
   * @param {boolean} constraint - boolean boolean to signal valid/invalid state
   * @param {string} type - string expression to set a datatype
   * @param {Node} node - the node the 'ref' expression is referring to
   * @param {import('./fx-bind').FxBind} bind - the fx-bind element having created this modelItem
   * @param {string} instance - the fx-instance id having created this modelItem
   */
  constructor(path, ref, readonly, relevant, required, constraint, type, node, bind, instance) {
    /**
     * @type {string}
     */
    this.path = path;
    /**
     * @type {string}
     */
    this.ref = ref;
    /**
     * @type {boolean}
     */
    this.constraint = constraint;
    /**
     * @type {boolean}
     */
    this.readonly = readonly;
    /**
     * @type {boolean}
     */
    this.relevant = relevant;
    /**
     * @type {boolean}
     */
    this.required = required;
    /**
     * @type {string}
     */
    this.type = type;
    /**
     * @type {Node}
     */
    this.node = node;
    /**
     * @type {import('./fx-bind').FxBind}
     */
    this.bind = bind;
    this.changed = false;
    /**
     * @type {import('./ui/fx-alert').FxAlert[]}
     */
    this.alerts = [];
    /**
     * @type {import('./ui/abstract-control').default[]}
     */
    this.boundControls = [];
    // this.value = this._getValue();
    this.instanceId = instance;
  }

  /*
  get ref(){
      return this.bind.ref;
  }
  */

  get value() {
    if (!this.node) {
      return null;
    }
    if (!this.node.nodeType) return this.node;
    if (this.node.nodeType === Node.ATTRIBUTE_NODE) {
      return this.node.nodeValue;
    }
    return this.node.textContent;
  }

  /**
   * @param  {Node} newVal
   */
  set value(newVal) {
    // console.log('modelitem.setvalue oldVal', this.value);
    // console.log('modelitem.setvalue newVal', newVal);

    if (newVal.nodeType === Node.DOCUMENT_NODE) {
      this.node.replaceWith(newVal.firstElementChild);
      this.node = newVal.firstElementChild;
      // this.node.appendChild(newVal.firstElementChild);
    } else if (newVal.nodeType === Node.ELEMENT_NODE) {
      this.node.replaceWith(newVal);
      this.node = newVal;
      // this.node.appendChild(newVal);
    } else if (this.node.nodeType === Node.ATTRIBUTE_NODE) {
      this.node.nodeValue = newVal;
    } else {
      this.node.textContent = newVal;
    }
  }
  addAlert(alert) {
    if (!this.alerts.includes(alert)) {
      this.alerts.push(alert);
    }
  }
  cleanAlerts() {
    this.alerts = [];
  }
}

/**
 * The model of this Fore scope. It holds all the intances, binding, submissions and custom functions that
 * as required.
 *
 * The model is updatin by executing rebuild (as needed), recalculate and revalidate in turn.
 *
 * After the cycle is run all modelItems have updated their stete to reflect latest computations.
 *
 */
class FxModel extends HTMLElement {
  constructor() {
    super();
    // this.id = '';

    /**
     * @type {import('./fx-instance.js').FxInstance[]}
     */
    this.instances = [];
    /**
     * @type {import('./modelitem.js').ModelItem[]}
     */
    this.modelItems = [];
    this.defaultContext = {};
    this.changed = [];

    // this.mainGraph = new DepGraph(false);
    this.inited = false;
    this.modelConstructed = false;
    this.attachShadow({
      mode: 'open'
    });
    this.computes = 0;
    this.fore = {};
  }
  get formElement() {
    return this.parentElement;
  }
  connectedCallback() {
    // console.log('connectedCallback ', this);
    this.setAttribute('inert', 'true');
    this.shadowRoot.innerHTML = `
            <slot></slot>
        `;

    /*
      this.addEventListener('model-construct-done', () => {
        // this.modelConstructed = true;
        // console.log('model-construct-done fired ', this.modelConstructed);
        // console.log('model-construct-done fired ', e.detail.model.instances);
      },
      { once: true },
    );
    */

    this.skipUpdate = false;
    this.fore = this.parentNode;
  }

  /**
   * @param {FxModel}           model        The model to create a model item for
   * @param {string}            ref          The XPath ref that led to this model item
   * @param {Node}              node         The node the XPath led to
   * @param {ForeElementMixin}  formElement  The form element making this model. Used to resolve variables against
   */
  static lazyCreateModelItem(model, ref, node, formElement) {
    // console.log('lazyCreateModelItem ', node);
    const instanceId = XPathUtil.resolveInstance(formElement, ref);
    if (model.parentNode.createNodes && (node === null || node === undefined)) {
      // ### intializing ModelItem with default values (as there is no <fx-bind> matching for given ref)
      const mi = new ModelItem(undefined, ref, Fore.READONLY_DEFAULT, false, Fore.REQUIRED_DEFAULT, Fore.CONSTRAINT_DEFAULT, Fore.TYPE_DEFAULT, null, this, instanceId);

      // console.log('new ModelItem is instanceof ModelItem ', mi instanceof ModelItem);
      model.registerModelItem(mi);
      return mi;
    }
    let targetNode = {};
    if (node === null || node === undefined) return null;
    if (node.nodeType === Node.TEXT_NODE) {
      // const parent = node.parentNode;
      // console.log('PARENT ', parent);
      targetNode = node.parentNode;
    } else {
      targetNode = node;
    }

    // const path = fx.evaluateXPath('path()',node);
    let path;
    if (node.nodeType) {
      path = XPathUtil.getPath(node, instanceId);
    } else {
      path = null;
      targetNode = node;
    }
    // const path = XPathUtil.getPath(node);

    // ### intializing ModelItem with default values (as there is no <fx-bind> matching for given ref)
    const mi = new ModelItem(path, ref, Fore.READONLY_DEFAULT, Fore.RELEVANT_DEFAULT, Fore.REQUIRED_DEFAULT, Fore.CONSTRAINT_DEFAULT, Fore.TYPE_DEFAULT, targetNode, this, instanceId);

    // console.log('new ModelItem is instanceof ModelItem ', mi instanceof ModelItem);
    model.registerModelItem(mi);
    return mi;
  }

  /**
   * modelConstruct starts actual processing of the model by
   *
   * 1. loading instances if present or constructing one
   * 2. calling updateModel to run the model update cycle of rebuild, recalculate and revalidate
   *
   * @event model-construct-done is fired once all instances have be loaded or after generating instance
   *
   */
  async modelConstruct() {
    console.info(`%cdispatching model-construct for #${this.parentNode.id}`, 'background:lightblue; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');

    // this.dispatchEvent(new CustomEvent('model-construct', { detail: this }));
    Fore.dispatch(this, 'model-construct', {
      model: this
    });

    // console.time('instance-loading');
    const instances = this.querySelectorAll('fx-instance');
    if (instances.length > 0) {
      const promises = [];
      instances.forEach(instance => {
        promises.push(instance.init());
      });

      // Wait until all the instances are built
      await Promise.all(promises);
      this.instances = Array.from(instances);
      // console.log('_modelConstruct this.instances ', this.instances);
      // Await until the model-construct-done event is handled off
      this.modelConstructed = true;
      await Fore.dispatch(this, 'model-construct-done', {
        model: this
      });
      this.inited = true;
      this.updateModel();
    } else {
      // ### if there's no instance one will created
      console.log(`### <<<<< dispatching model-construct-done for '${this.fore.id}' >>>>>`);
      this.modelConstructed = true;
      await this.dispatchEvent(new CustomEvent('model-construct-done', {
        composed: false,
        bubbles: true,
        detail: {
          model: this
        }
      }));
    }
    const functionlibImports = Array.from(this.querySelectorAll('fx-functionlib'));
    await Promise.all(functionlibImports.map(lib => lib.readyPromise));
    // console.timeEnd('instance-loading');
    this.inited = true;
  }
  registerModelItem(modelItem) {
    // console.log('ModelItem registered ', modelItem);
    this.modelItems.push(modelItem);
  }

  /**
   * update action triggering the update cycle
   */
  updateModel() {
    // console.time('updateModel');
    this.rebuild();
    /*
        if (this.skipUpdate){
            console.info('%crecalculate/revalidate skipped - no bindings', 'font-style: italic; background: #90a4ae; color:lightgrey; padding:0.3rem 5rem 0.3rem 0.3rem;display:block;width:100%;');
            return;
        }
    */
    this.recalculate();
    this.revalidate();
    // console.log('updateModel finished with modelItems ', this.modelItems);

    // console.timeEnd('updateModel');
  }

  rebuild() {
    // console.log(`### <<<<< rebuild() '${this.fore.id}' >>>>>`);

    this.mainGraph = new DepGraph(false); // do: should be moved down below binds.length check but causes errors in tests.
    this.modelItems = [];

    // trigger recursive initialization of the fx-bind elements
    const binds = this.querySelectorAll('fx-model > fx-bind');
    if (binds.length === 0) {
      // console.log('skipped model update');
      this.skipUpdate = true;
      return;
    }
    binds.forEach(bind => {
      bind.init(this);
    });
    console.log('mainGraph', this.mainGraph);
    console.log('rebuild mainGraph calc order', this.mainGraph.overallOrder());

    // this.dispatchEvent(new CustomEvent('rebuild-done', {detail: {maingraph: this.mainGraph}}));
    Fore.dispatch(this, 'rebuild-done', {
      maingraph: this.mainGraph
    });
    console.log('mainGraph', this.mainGraph);
  }

  /**
   * recalculation of all modelItems. Uses dependency graph to determine order of computation.
   *
   * todo: use 'changed' flag on modelItems to determine subgraph for recalculation. Flag already exists but is not used.
   */
  recalculate() {
    if (!this.mainGraph) {
      return;
    }

    // console.log(`### <<<<< recalculate() '${this.fore.id}' >>>>>`);

    // console.log('changed nodes ', this.changed);
    this.computes = 0;
    this.subgraph = new DepGraph(false);
    // ### create the subgraph for all changed modelItems
    if (this.changed.length !== 0) {
      // ### build the subgraph
      this.changed.forEach(modelItem => {
        this.subgraph.addNode(modelItem.path, modelItem.node);
        // const dependents = this.mainGraph.dependantsOf(modelItem.path, false);
        // this._addSubgraphDependencies(modelItem.path);
        if (this.mainGraph.hasNode(modelItem.path)) {
          // const dependents = this.mainGraph.directDependantsOf(modelItem.path)

          const all = this.mainGraph.dependantsOf(modelItem.path, false);
          const dependents = all.reverse();
          if (dependents.length !== 0) {
            dependents.forEach(dep => {
              // const subdep = this.mainGraph.dependentsOf(dep,false);
              // subgraph.addDependency(dep, modelItem.path);
              const val = this.mainGraph.getNodeData(dep);
              this.subgraph.addNode(dep, val);
              if (dep.includes(':')) {
                const path = dep.substring(0, dep.indexOf(':'));
                this.subgraph.addNode(path, val);
                const deps = this.mainGraph.dependentsOf(modelItem.path, false);
                // if we find the dep to be first in list of dependents we are dependent on ourselves not adding edge to modelItem.path
                if (deps.indexOf(dep) !== 0) {
                  this.subgraph.addDependency(dep, modelItem.path);
                }
              }
              // subgraph.addDependency(dep,modelItem.path);
            });
          }
        }
      });

      // ### compute the subgraph
      const ordered = this.subgraph.overallOrder(false);
      ordered.forEach(path => {
        if (this.mainGraph.hasNode(path)) {
          const node = this.mainGraph.getNodeData(path);
          this.compute(node, path);
        }
      });
      const toRefresh = [...this.changed];
      this.formElement.toRefresh = toRefresh;
      this.changed = [];
      Fore.dispatch(this, 'recalculate-done', {
        graph: this.subgraph,
        computes: this.computes
      });
    } else {
      const v = this.mainGraph.overallOrder(false);
      v.forEach(path => {
        const node = this.mainGraph.getNodeData(path);
        this.compute(node, path);
      });
      Fore.dispatch(this, 'recalculate-done', {
        graph: this.mainGraph,
        computes: this.computes
      });
    }
    console.log(`${this.parentElement.id} recalculate finished with modelItems `, this.modelItems);
  }

  /*
      _addSubgraphDependencies(path){
          const dependents = this.mainGraph.directDependantsOf(path)
           const alreadyInGraph = this.subgraph.incomingEdges[path];
          // const alreadyInGraph = path in this.subgraph;
          if(dependents.length !== 0 && alreadyInGraph.length === 0){
               dependents.forEach(dep => {
                  // const val= this.mainGraph.getNodeData(dep);
                  // this.subgraph.addNode(dep,val);
                  if(dep.includes(':')){
                      const subpath = dep.substring(0, dep.indexOf(':'));
                      // this.subgraph.addNode(subpath,val);
                      this.subgraph.addDependency(subpath,dep);
                      this.subgraph.addDependency(dep,path);
                      /!*
                                          const subdeps = this.mainGraph.directDependantsOf(path);
                                          console.log('subdeps',path, subdeps);
                                          subdeps.forEach(sdep => {
                                              const sval= this.mainGraph.getNodeData(sdep);
                                              this.subgraph.addNode(sdep,sval);
                                              console.log('subdep',sdep);
                                          });
                      *!/
                      if(this.subgraph.incomingEdges[dep] === 0){
                          this._addSubgraphDependencies(subpath)
                      }
                   }
              });
           }
       }
  */

  /**
   * (re-) computes a modelItem.
   * @param {Node} node - the node the modelItem is attached to
   * @param {string} path - the canonical XPath of the node
   */
  compute(node, path) {
    const modelItem = this.getModelItem(node);
    if (modelItem && path.includes(':')) {
      const property = path.split(':')[1];
      if (property) {
        /*
                        if (property === 'readonly') {
                            // make sure that calculated items are always readonly
                            if(modelItem.bind['calculate']){
                                modelItem.readonly =  true;
                            }else {
                                const expr = modelItem.bind[property];
                                const compute = evaluateXPathToBoolean(expr, modelItem.node, this);
                                modelItem.readonly = compute;
                            }
                        }
        */
        const expr = modelItem.bind[property];
        if (property === 'calculate') {
          const compute = evaluateXPath(expr, modelItem.node, this);
          modelItem.value = compute;
          modelItem.readonly = true; // calculated nodes are always readonly
        } else if (property !== 'constraint' && property !== 'type') {
          // ### re-compute the Boolean value of all facets expect 'constraint' and 'type' which are handled in revalidate()
          if (expr) {
            const compute = evaluateXPathToBoolean(expr, modelItem.node, this);
            modelItem[property] = compute;
            /*
                                    console.log(
                                      `recalculating path ${path} - Expr:'${expr}' computed`,
                                      modelItem[property],
                                    );
                        */
          }
        }
      }

      this.computes += 1;
    }
  }

  /**
   * Iterates all modelItems to calculate the validation status.
   *
   * Model alerts are given on 'fx-bind' elements as either attribute `alert` or as `fx-alert` child elements.
   *
   * During model-construct all model alerts are added to the modelItem if any
   *
   * to revalidate:
   * Gets the `constraint` attribute declaration from modelItem.bind
   * Computes the XPath to a Boolean
   * Updates the modelItem.constraint property
   *
   * todo: type checking
   * todo: run browser validation API
   *
   */
  revalidate() {
    if (this.modelItems.length === 0) return true;

    // console.log(`### <<<<< revalidate() '${this.fore.id}' >>>>>`);

    // reset submission validation
    // this.parentNode.classList.remove('submit-validation-failed')
    let valid = true;
    this.modelItems.forEach(modelItem => {
      // console.log('validating node ', modelItem.node);
      const {
        bind
      } = modelItem;
      if (bind) {
        /*
                        todo: investigate why bind is an element when created in fx-bind.init() and an fx-bind object when
                          created lazily.
                        */
        if (typeof bind.hasAttribute === 'function' && bind.hasAttribute('constraint')) {
          const constraint = bind.getAttribute('constraint');
          if (constraint && modelItem.node) {
            const compute = evaluateXPathToBoolean(constraint, modelItem.node, this);
            // console.log('modelItem validity computed: ', compute);
            modelItem.constraint = compute;
            this.formElement.addToRefresh(modelItem); // let fore know that modelItem needs refresh
            if (!compute) {
              console.log('validation failed on modelitem ', modelItem);
              valid = false;
            }
          }
        }
        if (typeof bind.hasAttribute === 'function' && bind.hasAttribute('required')) {
          const required = bind.getAttribute('required');
          if (required) {
            const compute = evaluateXPathToBoolean(required, modelItem.node, this);
            // console.log('modelItem required computed: ', compute);
            modelItem.required = compute;
            this.formElement.addToRefresh(modelItem); // let fore know that modelItem needs refresh
            if (!modelItem.node.textContent) {
              /*
              console.log(
                'node is required but has no value ',
                XPathUtil.getDocPath(modelItem.node),
              );
              */
              valid = false;
            }
            // if (!compute) valid = false;
            /*
                                    if (!this.modelConstructed) {
                                      // todo: get alert from attribute or child element
                                      const alert = bind.getAlert();
                                      if (alert) {
                                        modelItem.addAlert(alert);
                                      }
                                    }
                        */
          }
        }
      }
    });

    console.log('modelItems after revalidate: ', this.modelItems);
    return valid;
  }
  addChanged(modelItem) {
    if (this.inited) {
      this.changed.push(modelItem);
    }
  }

  /**
   *
   * @param {Node} node
   * @returns {ModelItem}
   */
  getModelItem(node) {
    return this.modelItems.find(m => m.node === node);
  }

  /**
   * get the default evaluation context for this model.
   * @returns {Element}
   */
  getDefaultContext() {
    return this.instances[0].getDefaultContext();
  }

  /**
   * @returns {import('./fx-instance.js').FxInstance}
   */
  getDefaultInstance() {
    /*
        if (this.instances.length === 0) {
            throw new Error('No instances defined. Fore cannot work without any <data/> elements.');
        }
    */
    if (this.instances.length) {
      return this.instances[0];
    }
    return this.getInstance('default');
  }
  getDefaultInstanceData() {
    return this.instances[0].getInstanceData();
  }
  getInstance(id) {
    // console.log('getInstance ', id);
    // console.log('instances ', this.instances);
    // console.log('instances array ',Array.from(this.instances));

    let found;
    if (id === 'default') {
      found = this.instances[0];
    }
    // ### lookup in local instances first
    if (!found) {
      const instArray = Array.from(this.instances);
      found = instArray.find(inst => inst.id === id);
      this.fore.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? this.fore.parentNode.host.closest('fx-fore') : this.fore.parentNode.closest('fx-fore');
    }
    // ### lookup in parent Fore if present
    if (!found) {
      // const parentFore = this.fore.parentNode.closest('fx-fore');
      const parentFore = this.fore.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? this.fore.parentNode.host.closest('fx-fore') : this.fore.parentNode.closest('fx-fore');
      if (parentFore) {
        // console.log('shared instances from parent', this.parentNode.id);
        const parentInstances = parentFore.getModel().instances;
        const shared = parentInstances.filter(shared => shared.hasAttribute('shared'));
        found = shared.find(found => found.id === id);
      }
    }
    if (found) {
      return found;
    }
    if (id === 'default') {
      return this.getDefaultInstance(); // if id is not found always defaults to first in doc order
    }

    if (!found && this.fore.strict) {
      // return this.getDefaultInstance(); // if id is not found always defaults to first in doc order
      Fore.dispatch(this, 'error', {
        origin: this,
        message: `Instance '${id}' does not exist`,
        level: 'Error'
      });
    }
    return null;
  }
  evalBinding(bindingExpr) {
    // console.log('MODEL.evalBinding ', bindingExpr);
    // default context of evaluation is always the default instance
    const result = this.instances[0].evalXPath(bindingExpr);
    return result;
  }
}
FxModel.dataChanged = false;
if (!customElements.get('fx-model')) {
  customElements.define('fx-model', FxModel);
}

class DependentXPathQueries {
  constructor() {
    /**
     * @type {Set<string>}
     */
    this._xpaths = new Set();
    this._parentDependencies = null;
  }

  /**
   * Returns true if this Fore element should be refreshed if a result of an index function changes
   *
   * @returns {boolean}
   */
  isInvalidatedByIndexFunction() {
    for (const xpath of this._xpaths) {
      // TODO: this can be done a lot better with parsing / checking for function references
      if (xpath.includes('index(')) {
        return true;
      }
    }

    // We can also depend on the index function if it was used in our ancestry
    return !!this._parentDependencies?.isInvalidatedByIndexFunction();
  }

  /**
   * Detects whether there are XPaths that may be affected by child list changes to nodes with the given local names
   *
   * It does this pessimistically, assuming that any descendant axis can be affected by these changes
   *
   * @param {string[]} affectedLocalNames
   */
  isInvalidatedByChildlistChanges(affectedLocalNames) {
    // Scan for any XPath part that may jump over a node without checking what the type is. Can also
    // be done dynamically, by listening for the `bucket` parameter of all the dom accessors
    const flaggedConstructs = ['//', 'ancestor', 'descendant', 'element(', '*', '..', 'following', 'preceding'];
    for (const xpath of this._xpaths) {
      if (flaggedConstructs.some(c => xpath.includes(c))) {
        return true;
      }
      if (affectedLocalNames.some(n => xpath.includes(n))) {
        return true;
      }
    }
    // We can also depend on these elements if it was used in our ancestry
    return !!this._parentDependencies?.isInvalidatedByChildlistChanges(affectedLocalNames);
  }

  /**
   * Add an XPath to the dependencies
   *
   * @param {string} xpath the XPath to add
   */
  addXPath(xpath) {
    this._xpaths.add(xpath);
  }

  /**
   * Reset the dependencies on refresh
   *
   */
  resetDependencies() {
    this._xpaths.clear();
  }

  /**
   * @param {DependentXPathQueries} deps
   */
  setParentDependencies(deps) {
    this._parentDependencies = deps;
  }
}

/**
 * Mixin containing all general functions that are shared by all Fore element classes.
 * @extends {HTMLElement}
 */
class ForeElementMixin extends HTMLElement {
  static get properties() {
    return {
      /**
       * context object for evaluation
       */
      context: {
        type: Object
      },
      /**
       * the model of this element
       */
      model: {
        type: Object
      },
      /**
       * The modelitem object associated to the bound node holding the evaluated state.
       */
      modelItem: {
        type: Object
      },
      /**
       * the node(s) bound by this element
       */
      nodeset: {
        type: Object
      },
      /**
       * XPath binding expression pointing to bound node
       */
      ref: {
        type: String
      },
      inScopeVariables: {
        type: Map
      }
    };
  }
  constructor() {
    super();
    this.context = null;
    this.model = null;
    this.modelItem = null;
    this.ref = this.hasAttribute('ref') ? this.getAttribute('ref') : '';
    /**
     * @type {Map<string, import('./fx-var.js').FxVariable>}
     */
    this.inScopeVariables = new Map();
    this.dependencies = new DependentXPathQueries();
  }
  connectedCallback() {
    if (this.parentElement) {
      this.dependencies.setParentDependencies(this.parentElement?.closest('[ref]')?.dependencies);
    }
  }

  /**
   * @returns {import('./fx-model.js').FxModel}
   */
  getModel() {
    // console.log('getModel this ', this);
    if (this.model) {
      return this.model;
    }
    // const ownerForm = this.closest('fx-fore');
    // const ownerForm = this.getOwnerForm(this);
    const ownerForm = this.getOwnerForm();
    return ownerForm.querySelector('fx-model');
  }

  /**
   *
   * @returns {import('./fx-fore.js').FxFore} The fx-fore element associated with this form node
   */
  getOwnerForm() {
    let currentElement = this;
    while (currentElement && currentElement.parentNode) {
      // console.log('current ', currentElement);

      if (currentElement.nodeName.toUpperCase() === 'FX-FORE') {
        return currentElement;
      }
      if (currentElement.parentNode instanceof DocumentFragment) {
        currentElement = currentElement.parentNode.host;
      } else {
        currentElement = currentElement.parentNode;
      }
    }
    return currentElement;
  }

  /**
   * evaluation of fx-bind and UiElements differ in details so that each class needs it's own implementation.
   */
  evalInContext() {
    this.dependencies.resetDependencies();
    // const inscopeContext = this.getInScopeContext();
    const model = this.getModel();
    if (!model) {
      return;
    }
    let inscopeContext;
    if (this.hasAttribute('context')) {
      inscopeContext = getInScopeContext(this.getAttributeNode('context') || this, this.context);
    }
    if (this.hasAttribute('ref')) {
      inscopeContext = getInScopeContext(this.getAttributeNode('ref') || this, this.ref);
      this.dependencies.addXPath(this.ref);
    }
    if (!inscopeContext && this.getModel().instances.length !== 0) {
      // ### always fall back to default context with there's neither a 'context' or 'ref' present
      inscopeContext = this.getModel().getDefaultInstance().getDefaultContext();
      // console.warn('no in scopeContext for ', this);
      // console.warn('using default context ', this);
      // return;
    }

    if (this.ref === '') {
      this.nodeset = inscopeContext;
    } else if (Array.isArray(inscopeContext)) {
      /*
      inscopeContext.forEach(n => {
      if (XPathUtil.isSelfReference(this.ref)) {
      this.nodeset = inscopeContext;
      } else {
      const localResult = evaluateXPathToFirstNode(this.ref, n, this);
      // console.log('local result: ', localResult);
      this.nodeset.push(localResult);
      }
      });
      */
      // this.nodeset = evaluateXPathToFirstNode(this.ref, inscopeContext[0], this);
      this.nodeset = evaluateXPath(this.ref, inscopeContext[0], this);
    } else {
      // this.nodeset = fx.evaluateXPathToFirstNode(this.ref, inscopeContext, null, {namespaceResolver: this.namespaceResolver});
      if (!inscopeContext) return;
      const {
        nodeType
      } = inscopeContext;
      if (nodeType && !XPathUtil.isAbsolutePath(this.ref)) {
        this.nodeset = evaluateXPathToFirstNode(this.ref, inscopeContext, this);
      } else {
        [this.nodeset] = evaluateXPath(this.ref, inscopeContext, this);
      }
    }
    // console.log('UiElement evaluated to nodeset: ', this.nodeset);
  }

  /**
   * resolves template expressions for a single attribute
   * @param {string} expr an attribute value containing curly brackets containing XPath expressions to evaluate
   * @param {Node} node the attribute node used for scoped resolution
   * @returns {string}
   * @protected
   */
  evaluateAttributeTemplateExpression(expr, node) {
    const matches = expr.match(/{[^}]*}/g);
    if (matches) {
      matches.forEach(match => {
        // console.log('match ', match);
        const naked = match.substring(1, match.length - 1);
        const inscope = getInScopeContext(node, naked);
        const result = evaluateXPathToString(naked, inscope, this);
        const replaced = expr.replaceAll(match, result);
        // console.log('replacing ', expr, ' with ', replaced);
        expr = replaced;
      });
    }
    return expr;
  }
  isNotBound() {
    return !this.hasAttribute('ref');
  }
  isBound() {
    return this.hasAttribute('ref');
  }
  getBindingExpr() {
    if (this.hasAttribute('ref')) {
      return this.getAttribute('ref');
    }
    // try to get closest parent bind
    const parent = XPathUtil.getClosest('[ref]', this.parentNode);
    if (!parent) {
      return 'instance()'; // the default instance
    }

    return parent.getAttribute('ref');
  }

  /**
   * @returns {import('./fx-instance.js').FxInstance}
   */
  getInstance() {
    if (this.ref.startsWith('instance(')) {
      const instId = XPathUtil.getInstanceId(this.ref);
      return this.getModel().getInstance(instId);
    }
    return this.getModel().getInstance('default');
  }
  _getParentBindingElement(start) {
    if (start.parentNode.host) {
      const {
        host
      } = start.parentNode;
      if (host.hasAttribute('ref')) {
        return host;
      }
    } else if (start.parentNode) {
      if (start.parentNode.hasAttribute('ref')) {
        return this.parentNode;
      }
      this._getParentBindingElement(this.parentNode);
    }
    return null;
  }

  /**
   * @returns {import('./modelitem.js').ModelItem}
   */
  getModelItem() {
    if (!this.getModel()) return;
    const mi = this.getModel().getModelItem(this.nodeset);
    if (mi) {
      this.modelItem = mi;
    }
    const repeated = XPathUtil.getClosest('fx-repeatitem', this);
    let existed;
    if (repeated) {
      const {
        index
      } = repeated;
      if (Array.isArray(this.nodeset)) {
        existed = this.getModel().getModelItem(this.nodeset[index - 1]);
      } else {
        existed = this.getModel().getModelItem(this.nodeset);
      }
    } else {
      existed = this.nodeset ? this.getModel().getModelItem(this.nodeset) : null;
    }
    if (!existed) {
      const lazyCreatedModelItem = FxModel.lazyCreateModelItem(this.getModel(), this.ref, this.nodeset, this);
      this.modelItem = lazyCreatedModelItem;
      return lazyCreatedModelItem;
    }
    this.modelItem = existed;
    return existed;
  }

  /**
   * Returns the effective value for the element.
   * a: look for 'value' attribute and if present evaluate it and return the resulting value
   * b: look for textContent and return the value if present
   * c: return null
   * @returns {string}
   */
  getValue() {
    if (this.hasAttribute('value')) {
      const valAttr = this.getAttribute('value');
      try {
        const inscopeContext = getInScopeContext(this, valAttr);
        return evaluateXPathToString(valAttr, inscopeContext, this.getOwnerForm());
      } catch (error) {
        console.error(error);
        Fore.dispatch(this, 'error', {
          message: error
        });
      }
    }
    if (this.textContent) {
      return this.textContent;
    }
    return null;
  }

  /**
   * @returns {Node}
   */
  getInScopeContext() {
    return getInScopeContext(this.getAttributeNode('ref') || this, this.ref);
  }

  /**
   * Set variables in scope here
   * @param {Map} inScopeVariables
   */
  setInScopeVariables(inScopeVariables) {
    this.inScopeVariables = inScopeVariables;
  }
}

/**
 * FxBind declaratively attaches constraints to nodes in the data (instances).
 *
 * It's major task is to create ModelItem Objects for each Node in the data their ref is pointing to.
 *
 * References and constraint attributes use XPath statements to point to the nodes they are attributing.
 *
 * Note: why is fx-bind not extending BoundElement? Though fx-bind has a 'ref' attr it is not bound in the sense of
 * getting updates about changes of the bound nodes. Instead it  acts as a factory for modelItems that are used by
 * BoundElements to track their state.
 *
 * @customElements
 */
class FxBind extends ForeElementMixin {
  constructor() {
    super();
    this.nodeset = [];
    this.model = {};
    this.contextNode = {};
    this.inited = false;
  }
  connectedCallback() {
    // console.log('connectedCallback ', this);
    // this.id = this.hasAttribute('id')?this.getAttribute('id'):;
    this.constraint = this.getAttribute('constraint');
    this.ref = this.getAttribute('ref');
    this.readonly = this.getAttribute('readonly');
    this.required = this.getAttribute('required');
    this.relevant = this.getAttribute('relevant');
    this.type = this.hasAttribute('type') ? this.getAttribute('type') : FxBind.TYPE_DEFAULT;
    this.calculate = this.getAttribute('calculate');
  }

  /**
   * initializes the bind element by evaluating the binding expression.
   *
   * For each node referred to by the binding expr a ModelItem object is created.
   *
   * @param model
   */
  init(model) {
    this.model = model;
    // console.log('init binding ', this);
    this._getInstanceId();
    this.bindType = this.getModel().getInstance(this.instanceId).type;
    // console.log('binding type ', this.bindType);

    if (this.bindType === 'xml') {
      this._evalInContext();
      this._buildBindGraph();
      this._createModelItems();
    }
    // todo: support json

    // ### process child bindings
    this._processChildren(model);
  }
  _buildBindGraph() {
    if (this.bindType === 'xml') {
      this.nodeset.forEach(node => {
        const instance = XPathUtil.resolveInstance(this, this.ref);
        const path = XPathUtil.getPath(node, instance);
        this.model.mainGraph.addNode(path, node);

        /* ### catching references in the 'ref' itself...
        todo: investigate cases where 'ref' attributes use predicates pointing to other nodes. These would not be handled
        in current implementation.
         General question: are there valid use-cases for using a 'filter' expression to narrow the nodeset
          where to apply constraints? Guess yes and if it's 'just' for reducing the amount of necessary modelItem objects.
         */
        // const foreignRefs = this.getReferences(this.ref);

        if (this.calculate) {
          this.model.mainGraph.addNode(`${path}:calculate`, node);
          // Calculated values are a dependency of the model item.
          this.model.mainGraph.addDependency(path, `${path}:calculate`);
        }
        const calculateRefs = this._getReferencesForProperty(this.calculate, node);
        if (calculateRefs.length !== 0) {
          this._addDependencies(calculateRefs, node, path, 'calculate');
        }
        if (!this.calculate) {
          const readonlyRefs = this._getReferencesForProperty(this.readonly, node);
          if (readonlyRefs.length !== 0) {
            this._addDependencies(readonlyRefs, node, path, 'readonly');
          } else if (this.readonly) {
            this.model.mainGraph.addNode(`${path}:readonly`, node);
          }
        }

        // const requiredRefs = this.requiredReferences;
        const requiredRefs = this._getReferencesForProperty(this.required, node);
        if (requiredRefs.length !== 0) {
          this._addDependencies(requiredRefs, node, path, 'required');
        } else if (this.required) {
          this.model.mainGraph.addNode(`${path}:required`, node);
        }
        const relevantRefs = this._getReferencesForProperty(this.relevant, node);
        if (relevantRefs.length !== 0) {
          this._addDependencies(relevantRefs, node, path, 'relevant');
        } else if (this.relevant) {
          this.model.mainGraph.addNode(`${path}:relevant`, node);
        }
        const constraintRefs = this._getReferencesForProperty(this.constraint, node);
        if (constraintRefs.length !== 0) {
          this._addDependencies(constraintRefs, node, path, 'constraint');
        } else if (this.constraint) {
          this.model.mainGraph.addNode(`${path}:constraint`, node);
          this.model.mainGraph.addDependency(path, `${path}:constraint`);
        }
      });
    }
  }

  /**
   * Add the dependencies of this bind
   *
   * @param  {Node[]}  refs The nodes that are referenced by this bind. these need to be resolved before
   * this bind can be resolved.
   * @param  {Node}    node The start of the reference
   * @param  {string}  path The path to the start of the reference
   * @param  {string}  property The property with this dependency
   */
  _addDependencies(refs, node, path, property) {
    // console.log('_addDependencies',path);
    const nodeHash = `${path}:${property}`;
    if (refs.length !== 0) {
      if (!this.model.mainGraph.hasNode(nodeHash)) {
        this.model.mainGraph.addNode(nodeHash, node);
      }
      refs.forEach(ref => {
        const instance = XPathUtil.resolveInstance(this, path);
        const otherPath = XPathUtil.getPath(ref, instance);
        // console.log('otherPath', otherPath)

        // todo: nasty hack to prevent duplicate pathes like 'a[1]' and 'a[1]/text()[1]' to end up as separate nodes in the graph
        if (!otherPath.endsWith('text()[1]')) {
          if (!this.model.mainGraph.hasNode(otherPath)) {
            this.model.mainGraph.addNode(otherPath, ref);
          }
          this.model.mainGraph.addDependency(nodeHash, otherPath);
        }
      });
    } else {
      this.model.mainGraph.addNode(nodeHash, node);
    }
  }
  _processChildren(model) {
    const childbinds = this.querySelectorAll(':scope > fx-bind');
    Array.from(childbinds).forEach(bind => {
      // console.log('init child bind ', bind);
      bind.init(model);
    });
  }
  getAlert() {
    if (this.hasAttribute('alert')) {
      return this.getAttribute('alert');
    }
    const alertChild = this.querySelector('fx-alert');
    if (alertChild) {
      return alertChild.innerHTML;
    }
    return null;
  }

  /**
   * overwrites
   */
  _evalInContext() {
    const inscopeContext = getInScopeContext(this.getAttributeNode('ref') || this, this.ref);

    // reset nodeset
    this.nodeset = [];
    if (this.ref === '' || this.ref === null) {
      this.nodeset = inscopeContext;
    } else if (Array.isArray(inscopeContext)) {
      inscopeContext.forEach(n => {
        if (XPathUtil.isSelfReference(this.ref)) {
          this.nodeset = inscopeContext;
        } else {
          // eslint-disable-next-line no-lonely-if
          if (this.ref) {
            const localResult = evaluateXPathToNodes(this.ref, n, this);
            localResult.forEach(item => {
              this.nodeset.push(item);
            });
            /*
                                                const localResult = fx.evaluateXPathToFirstNode(this.ref, n, null, {namespaceResolver:  this.namespaceResolver});
                                                this.nodeset.push(localResult);
                        */
          }
          // console.log('local result: ', localResult);
          // this.nodeset.push(localResult);
        }
      });
    } else {
      const inst = this.getModel().getInstance(this.instanceId);
      if (inst.type === 'xml') {
        this.nodeset = evaluateXPathToNodes(this.ref, inscopeContext, this);
      } else {
        this.nodeset = this.ref;
      }
    }
  }
  _createModelItems() {
    // console.log('#### ', thi+s.nodeset);

    if (Array.isArray(this.nodeset)) {
      // console.log('################################################ ', this.nodeset);
      // Array.from(this.nodeset).forEach((n, index) => {
      Array.from(this.nodeset).forEach(n => {
        // console.log('node ',n);
        // this._createModelItem(n, index);
        this._createModelItem(n);
      });
    } else {
      this._createModelItem(this.nodeset);
    }
  }

  /**
   * creates a ModelItem for given instance node.
   *
   * Please note that for textnode no ModelItem is created but instead the one of its parent is used which either
   * must exist and be initialized already when we hit the textnode.
   * @param node
   * @private
   */
  // _createModelItem(node, index) {
  _createModelItem(node) {
    // console.log('_createModelItem node', node, index);

    /*
                this.calculateReferences = this._getReferencesForProperty(this.calculate,node);
                this.readOnlyReferences = this._getReferencesForProperty(this.readonly,node);
                this.requiredReferences = this._getReferencesForProperty(this.required,node);
                this.relevantReferences = this._getReferencesForProperty(this.relevant,node);
                this.constraintReferences = this._getReferencesForProperty(this.constraint,node);
        */

    /*
        if bind is the dot expression we use the modelitem of the parent
         */
    if (XPathUtil.isSelfReference(this.ref)) {
      const parentBoundElement = XPathUtil.getClosest('fx-bind[ref]', this.parentElement);
      // console.log('parent bound element ', parentBoundElement);

      if (parentBoundElement) {
        // todo: Could be fancier by combining them
        parentBoundElement.required = this.required; // overwrite parent property!
      } else {
        console.error('no parent bound element');
      }
      return;
    }

    // let value = null;
    // const mItem = {};
    /*
    let targetNode = {};
    if (node.nodeType === node.TEXT_NODE) {
      // const parent = node.parentNode;
      // console.log('PARENT ', parent);
      targetNode = node.parentNode;
    } else {
      targetNode = node;
    }
    */
    const targetNode = node;

    // const path = fx.evaluateXPath('path()',node);
    // const path = this.getPath(node);
    const instanceId = XPathUtil.resolveInstance(this, this.ref);
    const path = XPathUtil.getPath(node, instanceId);
    // const shortPath = this.shortenPath(path);

    // ### constructing default modelitem - will get evaluated during recalculate()
    // ### constructing default modelitem - will get evaluated during recalculate()
    // ### constructing default modelitem - will get evaluated during recalculate()
    // const newItem = new ModelItem(shortPath,
    const newItem = new ModelItem(path, this.getBindingExpr(), FxBind.READONLY_DEFAULT, FxBind.RELEVANT_DEFAULT, FxBind.REQUIRED_DEFAULT, FxBind.CONSTRAINT_DEFAULT, this.type, targetNode, this, instanceId);
    const alert = this.getAlert();
    if (alert) {
      newItem.addAlert(alert);
    }
    this.getModel().registerModelItem(newItem);
  }

  /**
   * Get the nodes that are referred by the given XPath expression
   *
   * @param  {string}  propertyExpr  The XPath to get the referenced nodes from
   *
   * @return {Node[]}  The nodes that are referenced by the XPath
   *
   * todo: DependencyNotifyingDomFacade reports back too much in some cases like 'a[1]' and 'a[1]/text[1]'
   */
  _getReferencesForProperty(propertyExpr) {
    if (propertyExpr) {
      return this.getReferences(propertyExpr);
    }
    return [];
  }
  getReferences(propertyExpr) {
    const touchedNodes = new Set();
    const domFacade = new DependencyNotifyingDomFacade(otherNode => touchedNodes.add(otherNode));
    this.nodeset.forEach(node => {
      evaluateXPathToString(propertyExpr, node, this, domFacade);
    });
    return Array.from(touchedNodes.values());
  }

  /*
    static getReferencesForRef(ref,nodeset){
      if (ref && nodeset) {
        const touchedNodes = new Set();
        const domFacade = new DependencyNotifyingDomFacade(otherNode => touchedNodes.add(otherNode));
        nodeset.forEach(node => {
          evaluateXPathToString(ref, node, this, domFacade);
        });
       return Array.from(touchedNodes.values());
    }
    return [];
  }
  */

  _initBooleanModelItemProperty(property, node) {
    // evaluate expression to boolean
    const propertyExpr = this[property];
    // console.log('####### ', propertyExpr);
    const result = evaluateXPathToBoolean(propertyExpr, node, this);
    return result;
  }
  static shortenPath(path) {
    const steps = path.split('/');
    let result = '';
    for (let i = 2; i < steps.length; i += 1) {
      const step = steps[i];
      if (step.indexOf('{}') !== -1) {
        const q = step.split('{}');
        result += `/${q[1]}`;
      } else {
        result += `/${step}`;
      }
    }
    return result;
  }

  /**
   * return the instance id this bind is associated with. Resolves upwards in binds to either find an expr containing
   * and instance() function or if not found return 'default'.
   * @private
   */
  _getInstanceId() {
    const bindExpr = this.getBindingExpr();
    // console.log('_getInstanceId bindExpr ', bindExpr);
    if (bindExpr.startsWith('instance(')) {
      this.instanceId = XPathUtil.getInstanceId(bindExpr);
      return;
    }
    if (!this.instanceId && this.parentNode.nodeName === 'FX-BIND') {
      let parent = this.parentNode;
      while (parent && !this.instanceId) {
        const ref = parent.getBindingExpr();
        if (ref.startsWith('instance(')) {
          this.instanceId = XPathUtil.getInstanceId(ref);
          return;
        }
        if (parent.parentNode.nodeName !== 'FX-BIND') {
          this.instanceId = 'default';
          break;
        }
        parent = parent.parentNode;
      }
    }
    this.instanceId = 'default';
  }
}
FxBind.READONLY_DEFAULT = false;
FxBind.REQUIRED_DEFAULT = false;
FxBind.RELEVANT_DEFAULT = true;
FxBind.CONSTRAINT_DEFAULT = true;
FxBind.TYPE_DEFAULT = 'xs:string';
if (!customElements.get('fx-bind')) {
  customElements.define('fx-bind', FxBind);
}

class FxConnection extends ForeElementMixin {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this._url = '';
    this._socket = null;
    this._heartbeatInterval = FxConnection._defaultHeartbeatInterval;
    this._heartbeatTimer = null;
    this._messageFormat = FxConnection._defaultMessageFormat;
    this._onMessage = this._onMessage.bind(this);
  }
  _render() {
    const style = `
            :host {
                display: none;
            }
        `;
    const html = `
            <slot></slot>
${this._messageFormat === 'xml' ? '<fx-replace id="replace" ref="."></fx-replace>' : '<fx-setvalue id="setvalue" ref="."></fx-setvalue>'}
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;
  }
  static get observedAttributes() {
    return ['url', 'heartbeat', 'message-format'];
  }
  connectedCallback() {
    if (this.hasAttribute('url')) {
      this._url = this.getAttribute('url');
    }
    if (this.hasAttribute('heartbeat')) {
      this._heartbeatInterval = parseInt(this.getAttribute('heartbeat'));
      this._setupHeartbeat();
    }
    if (this.hasAttribute('message-format')) {
      this._messageFormat = this.getAttribute('message-format');
    }
    this._render();
    this.getOwnerForm().addEventListener('model-construct-done', e => {
      console.log('Fore model ready');
      this._connect();
      this.evalInContext();
    });
  }
  disconnectedCallback() {
    this._disconnect();
  }
  attributeChangedCallback(name, oldValue, newValue) {
    switch (name) {
      case 'url':
        this._url = newValue;
        this._connect();
        break;
      case 'heartbeat':
        this._heartbeatInterval = parseInt(newValue);
        this._setupHeartbeat();
        break;
      case 'messageformat':
        this._messageFormat = newValue;
        break;
    }
  }
  send(data) {
    this.evalInContext();
    data = this.nodeset;
    if (this._socket && this._socket.readyState === WebSocket.OPEN) {
      let message;
      switch (this._messageFormat) {
        case 'json':
          message = JSON.stringify(data);
          break;
        case 'xml':
          message = new XMLSerializer().serializeToString(data);
          break;
        case 'text':
          message = data.textContent;
          break;
        default:
          throw new Error(`Unsupported message format: ${this._messageFormat}`);
      }
      this._sendMessage(message);
    } else {
      throw new Error('WebSocket is not connected');
    }
  }
  _connect() {
    this._disconnect();
    if (this._url) {
      this._socket = new WebSocket(this._url);
      this._socket.addEventListener('open', this._onOpen.bind(this));
      this._socket.addEventListener('message', this._onMessage);
      this._socket.addEventListener('close', this._onClose.bind(this));
    }
  }
  _disconnect() {
    if (this._socket) {
      this._socket.removeEventListener('open', this._onOpen.bind(this));
      this._socket.removeEventListener('message', event => this._onMessage(event));
      this._socket.removeEventListener('close', this._onClose.bind(this));
      this._socket.close();
      this._socket = null;
    }
    if (this._heartbeatTimer) {
      clearInterval(this._heartbeatTimer);
      this._heartbeatTimer = null;
    }
  }
  _onOpen(event) {
    this.dispatchEvent(new CustomEvent('open', {
      detail: event
    }));
  }
  _onMessage(event) {
    let message;
    switch (this._messageFormat) {
      case 'json':
        message = JSON.parse(event.data);
        break;
      case 'xml':
        const parser = new DOMParser();
        message = parser.parseFromString(event.data, 'application/xml');
        this.getModelItem().value = message;
        FxModel.dataChanged = true;
        this.getModel().changed.push(this.modelItem);
        this.getModel().updateModel();
        this.getOwnerForm().refresh(true);
        break;
      case 'text':
        message = event.data;
        break;
      default:
        throw new Error(`Unsupported message format: ${this._messageFormat}`);
    }
    console.log('dispatching channel-message', message);
    Fore.dispatch(this, 'channel-message', {
      message
    });
  }
  _onClose(event) {
    this.dispatchEvent(new CustomEvent('close', {
      detail: event
    }));
  }
  _setupHeartbeat() {
    if (this._heartbeatInterval > 0) {
      if (this._heartbeatTimer) {
        clearInterval(this._heartbeatTimer);
      }
      this._heartbeatTimer = setInterval(() => {
        this._sendMessage('');
      }, this._heartbeatInterval);
    } else if (this._heartbeatTimer) {
      clearInterval(this._heartbeatTimer);
      this._heartbeatTimer = null;
    }
  }
  _sendMessage(message) {
    if (this._socket && this._socket.readyState === WebSocket.OPEN) {
      this._socket.send(message);
    }
  }
  static get _defaultHeartbeatInterval() {
    return 0;
  }
  static get _defaultMessageFormat() {
    return 'json';
  }
  get url() {
    return this._url;
  }
  set url(value) {
    this.setAttribute('url', value);
  }
  get heartbeat() {
    return this._heartbeatInterval;
  }
  set heartbeat(value) {
    this.setAttribute('heartbeat', value);
  }
  get messageformat() {
    return this._messageFormat;
  }
  set messageformat(value) {
    this.setAttribute('messageformat', value);
  }
}
if (!customElements.get('fx-connection')) {
  customElements.define('fx-connection', FxConnection);
}

/*!
 * Toastify js 1.11.2
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */

/**
 * Options used for Toastify
 * @typedef {Object} ToastifyConfigurationObject
 * @property {string} text - Message to be displayed in the toast
 * @property {Element} node - Provide a node to be mounted inside the toast. node takes higher precedence over text
 * @property {number} duration - Duration for which the toast should be displayed. -1 for permanent toast
 * @property {string|Element} selector - CSS ID Selector on which the toast should be added
 * @property {url} destination - URL to which the browser should be navigated on click of the toast
 * @property {boolean} newWindow - Decides whether the destination should be opened in a new window or not
 * @property {boolean} close - To show the close icon or not
 * @property {string} gravity - To show the toast from top or bottom
 * @property {string} position - To show the toast on left or right
 * @property {string} backgroundColor - Deprecated: Sets the background color of the toast
 * @property {url} avatar - Image/icon to be shown before text
 * @property {string} className - Ability to provide custom class name for further customization
 * @property {boolean} stopOnFocus - To stop timer when hovered over the toast (Only if duration is set)
 * @property {Function} callback - Invoked when the toast is dismissed
 * @property {Function} onClick - Invoked when the toast is clicked
 * @property {Object} offset - Ability to add some offset to axis
 * @property {boolean} escapeMarkup - Toggle the default behavior of escaping HTML markup
 * @property {Object} style - Use the HTML DOM style property to add styles to toast
 */

class Toastify {
  constructor(options) {
    this.defaults = {
      oldestFirst: true,
      text: "Toastify is awesome!",
      node: undefined,
      duration: 3000,
      selector: undefined,
      callback: function () {},
      destination: undefined,
      newWindow: false,
      close: false,
      gravity: "toastify-top",
      positionLeft: false,
      position: "",
      backgroundColor: "",
      avatar: "",
      className: "",
      stopOnFocus: true,
      onClick: function () {},
      offset: {
        x: 0,
        y: 0
      },
      escapeMarkup: true,
      style: {
        background: ""
      }
    };
    /**
     * The version of Toastify
     * @type {string}
     * @public
     */
    this.version = "1.11.2";

    /**
     * The configuration object to configure Toastify
     * @type {ToastifyConfigurationObject}
     * @public
     */
    this.options = {};

    /**
     * The element that is the Toast
     * @type {Element}
     * @public
     */
    this.toastElement = null;

    /**
     * The root element that contains all the toasts
     * @type {Element}
     * @private
     */
    this._rootElement = document.body;
    this._init(options);
  }

  /**
   * Display the toast
   * @public
   */
  showToast() {
    // Creating the DOM object for the toast
    this.toastElement = this._buildToast();

    // Getting the root element to with the toast needs to be added
    if (typeof this.options.selector === "string") {
      this._rootElement = document.getElementById(this.options.selector);
    } else if (this.options.selector instanceof HTMLElement || this.options.selector instanceof ShadowRoot) {
      this._rootElement = this.options.selector;
    } else {
      this._rootElement = document.body;
    }

    // Validating if root element is present in DOM
    if (!this._rootElement) {
      throw "Root element is not defined";
    }

    // Adding the DOM element
    this._rootElement.insertBefore(this.toastElement, this._rootElement.firstChild);

    // Repositioning the toasts in case multiple toasts are present
    this._reposition();
    if (this.options.duration > 0) {
      this.toastElement.timeOutValue = window.setTimeout(() => {
        // Remove the toast from DOM
        this._removeElement(this.toastElement);
      }, this.options.duration); // Binding `this` for function invocation
    }

    // Supporting function chaining
    return this;
  }

  /**
   * Hide the toast
   * @public
   */
  hideToast() {
    if (this.toastElement.timeOutValue) {
      clearTimeout(this.toastElement.timeOutValue);
    }
    this._removeElement(this.toastElement);
  }

  /**
   * Init the Toastify class
   * @param {ToastifyConfigurationObject} options - The configuration object to configure Toastify
   * @param {string} [options.text=Hi there!] - Message to be displayed in the toast
   * @param {Element} [options.node] - Provide a node to be mounted inside the toast. node takes higher precedence over text
   * @param {number} [options.duration=3000] - Duration for which the toast should be displayed. -1 for permanent toast
   * @param {string} [options.selector] - CSS Selector on which the toast should be added
   * @param {url} [options.destination] - URL to which the browser should be navigated on click of the toast
   * @param {boolean} [options.newWindow=false] - Decides whether the destination should be opened in a new window or not
   * @param {boolean} [options.close=false] - To show the close icon or not
   * @param {string} [options.gravity=toastify-top] - To show the toast from top or bottom
   * @param {string} [options.position=right] - To show the toast on left or right
   * @param {string} [options.backgroundColor] - Sets the background color of the toast (To be deprecated)
   * @param {url} [options.avatar] - Image/icon to be shown before text
   * @param {string} [options.className] - Ability to provide custom class name for further customization
   * @param {boolean} [options.stopOnFocus] - To stop timer when hovered over the toast (Only if duration is set)
   * @param {Function} [options.callback] - Invoked when the toast is dismissed
   * @param {Function} [options.onClick] - Invoked when the toast is clicked
   * @param {Object} [options.offset] - Ability to add some offset to axis
   * @param {boolean} [options.escapeMarkup=true] - Toggle the default behavior of escaping HTML markup
   * @param {Object} [options.style] - Use the HTML DOM style property to add styles to toast
   * @private
   */
  _init(options) {
    // Setting defaults
    this.options = Object.assign(this.defaults, options);
    if (this.options.backgroundColor) {
      // This is being deprecated in favor of using the style HTML DOM property
      console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
    }
    this.toastElement = null;
    this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : "toastify-top"; // toast position - top or bottom
    this.options.stopOnFocus = options.stopOnFocus === undefined ? true : options.stopOnFocus; // stop timeout on focus
    if (options.backgroundColor) {
      this.options.style.background = options.backgroundColor;
    }
  }

  /**
   * Build the Toastify element
   * @returns {Element}
   * @private
   */
  _buildToast() {
    // Validating if the options are defined
    if (!this.options) {
      throw "Toastify is not initialized";
    }

    // Creating the DOM object
    let divElement = document.createElement("div");
    divElement.className = `toastify on ${this.options.className}`;

    // Positioning toast to left or right or center (default right)
    divElement.className += ` toastify-${this.options.position}`;

    // Assigning gravity of element
    divElement.className += ` ${this.options.gravity}`;

    // Loop through our style object and apply styles to divElement
    for (const property in this.options.style) {
      divElement.style[property] = this.options.style[property];
    }

    // Adding the toast message/node
    if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
      // If we have a valid node, we insert it
      divElement.appendChild(this.options.node);
    } else {
      if (this.options.escapeMarkup) {
        divElement.innerText = this.options.text;
      } else {
        divElement.innerHTML = this.options.text;
      }
      if (this.options.avatar !== "") {
        let avatarElement = document.createElement("img");
        avatarElement.src = this.options.avatar;
        avatarElement.className = "toastify-avatar";
        if (this.options.position == "left") {
          // Adding close icon on the left of content
          divElement.appendChild(avatarElement);
        } else {
          // Adding close icon on the right of content
          divElement.insertAdjacentElement("afterbegin", avatarElement);
        }
      }
    }

    // Adding a close icon to the toast
    if (this.options.close === true) {
      // Create a span for close element
      let closeElement = document.createElement("span");
      closeElement.innerHTML = "&#10006;";
      closeElement.className = "toast-close";

      // Triggering the removal of toast from DOM on close click
      closeElement.addEventListener("click", event => {
        event.stopPropagation();
        this._removeElement(this.toastElement);
        window.clearTimeout(this.toastElement.timeOutValue);
      });

      //Calculating screen width
      const width = window.innerWidth > 0 ? window.innerWidth : screen.width;

      // Adding the close icon to the toast element
      // Display on the right if screen width is less than or equal to 360px
      if (this.options.position == "left" && width > 360) {
        // Adding close icon on the left of content
        divElement.insertAdjacentElement("afterbegin", closeElement);
      } else {
        // Adding close icon on the right of content
        divElement.appendChild(closeElement);
      }
    }

    // Clear timeout while toast is focused
    if (this.options.stopOnFocus && this.options.duration > 0) {
      // stop countdown
      divElement.addEventListener("mouseover", event => {
        window.clearTimeout(divElement.timeOutValue);
      });
      // add back the timeout
      divElement.addEventListener("mouseleave", () => {
        divElement.timeOutValue = window.setTimeout(() => {
          // Remove the toast from DOM
          this._removeElement(divElement);
        }, this.options.duration);
      });
    }

    // Adding an on-click destination path
    if (typeof this.options.destination !== "undefined") {
      divElement.addEventListener("click", event => {
        event.stopPropagation();
        if (this.options.newWindow === true) {
          window.open(this.options.destination, "_blank");
        } else {
          window.location = this.options.destination;
        }
      });
    }
    if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
      divElement.addEventListener("click", event => {
        event.stopPropagation();
        this.options.onClick();
      });
    }

    // Adding offset
    if (typeof this.options.offset === "object") {
      const x = this._getAxisOffsetAValue("x", this.options);
      const y = this._getAxisOffsetAValue("y", this.options);
      const xOffset = this.options.position == "left" ? x : `-${x}`;
      const yOffset = this.options.gravity == "toastify-top" ? y : `-${y}`;
      divElement.style.transform = `translate(${xOffset},${yOffset})`;
    }

    // Returning the generated element
    return divElement;
  }

  /**
   * Remove the toast from the DOM
   * @param {Element} toastElement
   */
  _removeElement(toastElement) {
    // Hiding the element
    toastElement.className = toastElement.className.replace(" on", "");

    // Removing the element from DOM after transition end
    window.setTimeout(() => {
      // remove options node if any
      if (this.options.node && this.options.node.parentNode) {
        this.options.node.parentNode.removeChild(this.options.node);
      }

      // Remove the element from the DOM, only when the parent node was not removed before.
      if (toastElement.parentNode) {
        toastElement.parentNode.removeChild(toastElement);
      }

      // Calling the callback function
      this.options.callback.call(toastElement);

      // Repositioning the toasts again
      this._reposition();
    }, 400); // Binding `this` for function invocation
  }

  /**
   * Position the toast on the DOM
   * @private
   */
  _reposition() {
    // Top margins with gravity
    let topLeftOffsetSize = {
      top: 15,
      bottom: 15
    };
    let topRightOffsetSize = {
      top: 15,
      bottom: 15
    };
    let offsetSize = {
      top: 15,
      bottom: 15
    };

    // Get all toast messages that have been added to the container (selector)
    let allToasts = this._rootElement.querySelectorAll(".toastify");
    let classUsed;

    // Modifying the position of each toast element
    for (let i = 0; i < allToasts.length; i++) {
      // Getting the applied gravity
      if (allToasts[i].classList.contains("toastify-top") === true) {
        classUsed = "toastify-top";
      } else {
        classUsed = "toastify-bottom";
      }
      let height = allToasts[i].offsetHeight;
      classUsed = classUsed.substr(9, classUsed.length - 1);
      // Spacing between toasts
      let offset = 15;
      let width = window.innerWidth > 0 ? window.innerWidth : screen.width;

      // Show toast in center if screen with less than or equal to 360px
      if (width <= 360) {
        // Setting the position
        allToasts[i].style[classUsed] = `${offsetSize[classUsed]}px`;
        offsetSize[classUsed] += height + offset;
      } else {
        if (allToasts[i].classList.contains("toastify-left") === true) {
          // Setting the position
          allToasts[i].style[classUsed] = `${topLeftOffsetSize[classUsed]}px`;
          topLeftOffsetSize[classUsed] += height + offset;
        } else {
          // Setting the position
          allToasts[i].style[classUsed] = `${topRightOffsetSize[classUsed]}px`;
          topRightOffsetSize[classUsed] += height + offset;
        }
      }
    }
  }

  /**
   * Helper function to get offset
   * @param {string} axis - 'x' or 'y'
   * @param {ToastifyConfigurationObject} options - The options object containing the offset object
   */
  _getAxisOffsetAValue(axis, options) {
    if (options.offset[axis]) {
      if (isNaN(options.offset[axis])) {
        return options.offset[axis];
      } else {
        return `${options.offset[axis]}px`;
      }
    }
    return '0px';
  }
}

// Returning the Toastify function to be assigned to the window object/module
function StartToastifyInstance(options) {
  return new Toastify(options);
}

/**
 *
 * Wrapper component for toastify-js - https://github.com/apvarun/toastify-js
 *
 * @event jinn-toast - will show the toast with text passed in event
 */
class JinnToast extends HTMLElement {
  static get properties() {
    return {
      avatar: {
        type: String
      },
      backgroundColor: {
        type: String
      },
      callback: {
        type: String
      },
      classProp: {
        type: String
      },
      close: {
        type: Boolean
      },
      destination: {
        type: String
      },
      duration: {
        type: Number
      },
      escapeMarkup: {
        type: Boolean
      },
      gravity: {
        type: String
      },
      newWindow: {
        type: Boolean
      },
      oldestFirst: {
        type: Boolean
      },
      position: {
        type: String
      },
      selector: {
        type: String
      },
      stopOnFocus: {
        type: Boolean
      },
      text: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  _initVar(name, defaultVal) {
    return this.hasAttribute(name) ? this.getAttribute(name) : defaultVal;
  }
  connectedCallback() {
    this.avatar = this._initVar('avatar', '');
    this.backgroundColor = this._initVar('backgroundColor', '');
    this.callback = this._initVar('callback', {});
    this.classProp = this._initVar('data-class', '');
    this.close = this._initVar('close', false) === 'true';
    this.destination = this._initVar('destination', undefined);
    this.duration = Number(this._initVar('duration', 3000));
    this.escapeMarkup = this._initVar('escapeMarkup', 'true') === 'true';
    this.gravity = this._initVar('gravity', 'top');
    this.newWindow = this._initVar('newWindow', 'false') === 'true';
    this.offSet = this._initVar('offSet', {});
    this.oldestFirst = this._initVar('oldestFirst', 'true') === 'true';
    this.position = this._initVar('position', 'right');
    // this.selector = this._initVar('selector','');
    this.stopOnFocus = this._initVar('stopOnFocus', 'true') === 'true';
    this.text = this._initVar('text', '');
    const style = `
        :host{
            display:none;
        }
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${this.renderHTML}
    `;

    /**
     * trigger toast via @jinn-toast events
     */
    this.addEventListener('jinn-toast', ev => {
      this.showToast(ev.detail.text);
    });
  }
  disconnectedCallback() {
    this.removeEventListener('jinn-toast', this.showToast);
  }
  showToast(text) {
    new StartToastifyInstance({
      avatar: this.avatar,
      // backgroundColor:this.backgroundColor,
      // callback: this.callback,
      className: this.classProp,
      close: this.close,
      destination: this.destination,
      duration: this.duration,
      escapeMarkup: this.escapeMarkup,
      gravity: this.gravity,
      newWindow: false,
      offset: this.offset,
      oldestFirst: this.oldestFirst,
      position: this.position,
      node: this.shadowRoot,
      stopOnFocus: this.stopOnFocus,
      text
    }).showToast();
  }
  renderHTML() {
    return `
      <slot></slot>
    `;
  }
}
if (!customElements.get('jinn-toast')) {
  window.customElements.define('jinn-toast', JinnToast);
}

const withDraggability = (superclass, isAlsoDraggable) =>
/**
 * Adds draggability to generic components.
 * Add the `dnd` attribute to make it draggable
 */
class DraggableComponent extends superclass {
  static get properties() {
    return {
      ...superclass.properties,
      dnd: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
  }
  connectedCallback() {
    this.drop = event => this._drop(event);
    this.addEventListener('drop', this.drop);
    this.dragOver = event => this._dragOver(event);
    this.addEventListener('dragover', this.dragOver);
    this.dragLeave = event => this._dragLeave(event);
    this.addEventListener('dragleave', this.dragLeave);
    this.dragEnd = event => this._dragEnd(event);
    this.addEventListener('dragend', this._dragEnd);
  }
  disconnectedCallback() {
    this.removeEventListener('drop', this.drop);
    this.removeEventListener('dragover', this.dragOver);
    this.removeEventListener('dragleave', this.dragLeave);
    this.removeEventListener('dragend', this.dragEnd);
  }
  _dragOver(event) {
    //		console.log('dragover ',this);
    //		console.log('event target ',event.target);
    if (event.target.classList.contains('no-drop')) {
      return false;
    }
    event.stopPropagation();
    const repeatItem = event.target.closest('fx-repeatitem');
    if (!this.getOwnerForm().draggedItem) {
      // Not dragging
      return;
    }
    // Only allow drag and drop in similar repeats
    if (this === this.getOwnerForm().draggedItem) {
      // Ignore: drop on itself
      return;
    }
    const {
      draggedItem
    } = this.getOwnerForm();
    if (this.accepts(draggedItem)) {
      this.classList.remove('no-drop');
    } else {
      this.classList.add('no-drop');
    }
    const thisClosestRepeat = this.hasAttribute('id') ? this : this.closest('[id]');
    const draggingClosestRepeat = draggedItem.hasAttribute('id') ? draggedItem : draggedItem.closest('[id]');
    if (thisClosestRepeat?.id === draggingClosestRepeat?.id) {
      if (repeatItem !== this.getOwnerForm().draggedItem) {
        this.classList.add('drag-over');
      }
      event.preventDefault();
    }
  }
  _dragLeave(event) {
    this.classList.remove('drag-over');
    this.classList.remove('no-drop');
  }
  _dragEnd(event) {
    const item = this.getOwnerForm().draggedItem;
    if (item.getAttribute('drop-action') === 'copy') {
      item.remove();
    }
    this.classList.remove('drag-over');
    //		event.stopPropagation();
  }

  _getDataNode() {
    const dataNode = this.getOwnerForm().draggedItem?.getModelItem()?.node;
    if (!dataNode) {
      return null;
    }
    const {
      draggedItem
    } = this.getOwnerForm();
    const thisClosestRepeat = this.hasAttribute('id') ? this : this.closest('[id]');
    const draggingClosestRepeat = draggedItem.hasAttribute('id') ? draggedItem : draggedItem.closest('[id]');
    if (thisClosestRepeat?.id !== draggingClosestRepeat?.id) {
      // Moving between different repeats: this can make the items 'lost': placed into a
      // different set
      return null;
    }
    return dataNode;
  }
  accepts(draggedItem) {
    if (!this.hasAttribute('accept')) {
      return;
    }
    const accept = this.getAttribute('accept');
    const isAccepted = draggedItem.matches(accept);
    // console.log('accepted', isAccepted);
    return isAccepted;
  }
  _drop(event) {
    this.classList.remove('drag-over');
    event.stopPropagation();
    if (this.localName === 'fx-droptarget') {
      if (this.children.length !== 0) {
        console.log('we have to do something');
      }
      let {
        draggedItem
      } = this.getOwnerForm();
      if (draggedItem.getAttribute('drop-action') === 'copy') {
        draggedItem = draggedItem.cloneNode(true);
      }
      if (!this.accepts(draggedItem)) {
        this.classList.remove('no-drop');
        return;
      }
      if (draggedItem === this) {
        return;
      }
      if (draggedItem.localName === 'fx-droptarget') {
        // todo : this looks still a bit weak
        if (this.hasAttribute('drop-position')) {
          this.replaceChildren(draggedItem);
          event.preventDefault();
          return;
        }
        if (this.parentNode.lastElementChild === this) {
          this.parentNode.append(draggedItem);
          event.stopImmediatePropagation();
          // return;
        } else if (draggedItem === this.previousElementSibling) {
          // insertBefore of draggedItem before us would be a no-op: it is already before us.
          // Instead: insert _after_ us, so we can still do something!
          this.parentNode.insertBefore(draggedItem, this.nextElementSibling);
        } else {
          this.parentNode.insertBefore(draggedItem, this);
        }
      } else {
        this.appendChild(draggedItem);
      }

      /*
      if(this.hasAttribute('drop-position')){
      if(this.getAttribute('drop-position') === 'before'){
      this.parentNode.insertBefore(draggedItem,this);
      } else {
      this.parentNode.append(draggedItem);
      }
      }else{
      this.replaceChildren(draggedItem);
      }
      */
      event.preventDefault();
      this.getOwnerForm().getModel().updateModel();
      this.getOwnerForm().refresh(true);
      return;
    }
    const dataNode = this._getDataNode();
    if (!dataNode) {
      return;
    }
    if (this.localName === 'fx-repeat') {
      // We are sure we'll handle this event!
      event.preventDefault();
      // Dropping on repeat itself always means to *append* the dropped item

      let contextNode = this.nodeset;
      if (Array.isArray(contextNode) && !contextNode.length) {
        // Guess: just append it to the context node. Hope that the `ref` is actually a
        // child axis, like `ref="./item"`. A ref like `./items/item` breaks.
        const context = getInScopeContext(this.getAttributeNode('ref') || this, this.ref);
        context.append(dataNode);
      } else {
        // Guess: just insert it after it to the context node. Hope that the `ref` is
        // actually listing siblings, like `ref="./item"` or
        // `ref="./items/item"`. `ref="descendant::item[@category='a']"` breaks
        contextNode = contextNode[contextNode.length - 1];
        contextNode.after(dataNode);
      }
    } else if (this.localName === 'fx-repeatitem') {
      const repeatItemNode = this.getModelItem().node;
      if (repeatItemNode.previousSibling === dataNode) {
        // moving before will make it do nothing, move after
        repeatItemNode.after(dataNode);
      } else {
        repeatItemNode.before(dataNode);
      }
    }

    // Note: full refresh needed since multiple model items may be affected.
    // TODO: Leverage the changedPaths trick
    this.getOwnerForm().getModel().updateModel();
    this.getOwnerForm().refresh(true);
  }
};

/**
 * `fx-repeat`
 *
 * Repeats its template for each node in its' bound nodeset.
 *
 * Template is a standard HTML `<template>` element. Once instanciated the template
 * is moved to the shadowDOM of the repeat for safe re-use.
 *
 *
 *
 * @customElement
 * @demo demo/todo.html
 *
 * todo: it should be seriously be considered to extend FxContainer instead but needs refactoring first.
 */
class FxRepeatAttributes extends withDraggability(ForeElementMixin) {
  static get properties() {
    return {
      ...super.properties,
      index: {
        type: Number
      },
      template: {
        type: Object
      },
      focusOnCreate: {
        type: String
      },
      initDone: {
        type: Boolean
      },
      repeatIndex: {
        type: Number
      },
      repeatSize: {
        type: Number
      },
      nodeset: {
        type: Array
      }
    };
  }
  constructor() {
    super();
    this.ref = '';
    this.dataTemplate = [];
    this.isDraggable = null;
    this.focusOnCreate = '';
    this.initDone = false;
    this.repeatIndex = 1;
    this.nodeset = [];
    this.inited = false;
    this.host = {};
    this.index = 1;
    this.repeatSize = 0;
    this.attachShadow({
      mode: 'open',
      delegatesFocus: true
    });
  }
  get repeatSize() {
    return this.querySelectorAll(':scope > .fx-repeatitem').length;
  }
  set repeatSize(size) {
    super.repeatSize = size;
  }
  setIndex(index) {
    // console.log('new repeat index ', index);
    this.index = index;
    const refd = this.querySelector('[data-ref]');
    const rItems = refd.querySelectorAll(':scope > *');
    this.applyIndex(rItems[this.index - 1]);
  }
  applyIndex(repeatItem) {
    this._removeIndexMarker();
    if (repeatItem) {
      repeatItem.setAttribute('repeat-index', '');
    }
  }
  get index() {
    return parseInt(this.getAttribute('index'), 10);
  }
  set index(idx) {
    this.setAttribute('index', idx);
  }
  _getRepeatedItems() {
    const refd = this.querySelector('[data-ref]');
    return refd.children;
  }
  async connectedCallback() {
    // console.log('connectedCallback',this);
    // this.display = window.getComputedStyle(this, null).getPropertyValue("display");
    this.ref = this.getAttribute('ref');
    // this.ref = this._getRef();
    // console.log('### fx-repeat connected ', this.id);
    this.addEventListener('item-changed', e => {
      // console.log('handle index event ', e);
      const {
        item
      } = e.detail;
      const repeatedItems = this._getRepeatedItems();
      const idx = Array.from(repeatedItems).indexOf(item);
      this.applyIndex(repeatedItems[idx]);
      this.index = idx + 1;
    });
    // todo: review - this is just used by append action - event consolidation ?
    document.addEventListener('index-changed', e => {
      e.stopPropagation();
      if (!e.target === this) return;
      const {
        index
      } = e.detail;
      this.index = Number(index);
      this.applyIndex(this.children[index - 1]);
    });
    /*
    document.addEventListener('insert', e => {
      const nodes = e.detail.insertedNodes;
      this.index = e.detail.position;
      console.log('insert catched', nodes, this.index);
    });
    */

    // if (this.getOwnerForm().lazyRefresh) {
    this.mutationObserver = new MutationObserver(mutations => {
      if (mutations[0].type === 'childList') {
        const added = mutations[0].addedNodes[0];
        if (added) {
          const instance = XPathUtil.resolveInstance(this, this.ref);
          const path = XPathUtil.getPath(added, instance);
          // this.dispatch('path-mutated',{'path':path,'nodeset':this.nodeset,'index': this.index});
          // this.index = index;
          // const prev = mutations[0].previousSibling.previousElementSibling;
          // const index = prev.index();
          // this.applyIndex(this.index -1);

          Fore.dispatch(this, 'path-mutated', {
            path,
            index: this.index
          });
        }
      }
    });
    // }
    this.getOwnerForm().registerLazyElement(this);
    const style = `
      :host{
      }
       .fade-out-bottom {
          -webkit-animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
          animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
      }
      .fade-out-bottom {
          -webkit-animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
          animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
      }
   `;
    const html = `
          <slot></slot>
    `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;

    // this.init();
  }

  async init() {
    // ### there must be a single 'template' child

    const inited = new Promise(resolve => {
      // console.log('##### repeat-attributes init ', this.id);
      // if(!this.inited) this.init();
      // does not use this.evalInContext as it is expecting a nodeset instead of single node
      this._evalNodeset();
      // console.log('##### ',this.id, this.nodeset);

      this._initTemplate();
      // this._initRepeatItems();

      this.setAttribute('index', this.index);
      this.inited = true;
      resolve('done');
    });
    return inited;
  }
  _getRef() {
    return this.getAttribute('ref');
  }

  /**
   * repeat has no own modelItems
   * @private
   */
  _evalNodeset() {
    // const inscope = this.getInScopeContext();
    const inscope = getInScopeContext(this.getAttributeNode('ref') || this, this.ref);
    // console.log('##### inscope ', inscope);
    // console.log('##### ref ', this.ref);
    // now we got a nodeset and attach MutationObserver to it

    if (this.mutationObserver && inscope.nodeName) {
      this.mutationObserver.observe(inscope, {
        childList: true,
        subtree: true
      });
    }
    const rawNodeset = evaluateXPath(this.ref, inscope, this);
    if (rawNodeset.length === 1 && Array.isArray(rawNodeset[0])) {
      // This XPath likely returned an XPath array. Just collapse to that array
      this.nodeset = rawNodeset[0];
      return;
    }
    this.nodeset = rawNodeset;
  }
  async refresh(force) {
    if (!this.inited) this.init();
    this._evalNodeset();
    let repeatItems = this.querySelectorAll('.fx-repeatitem');
    let repeatItemCount = repeatItems.length;
    let nodeCount = 1;
    if (Array.isArray(this.nodeset)) {
      nodeCount = this.nodeset.length;
    }

    // const contextSize = this.nodeset.length;
    const contextSize = nodeCount;
    // todo: review - cant the context really never be smaller than the repeat count?
    // todo: this code can be deprecated probably but check first
    if (contextSize < repeatItemCount) {
      for (let position = repeatItemCount; position > contextSize; position -= 1) {
        // remove repeatitem
        const itemToRemove = repeatItems[position - 1];
        itemToRemove.parentNode.removeChild(itemToRemove);
        this.getOwnerForm().unRegisterLazyElement(itemToRemove);
        // this._fadeOut(itemToRemove);
        // Fore.fadeOutElement(itemToRemove)
        this.getOwnerForm().someInstanceDataStructureChanged = true;
      }
    }
    if (contextSize > repeatItemCount) {
      for (let position = repeatItemCount + 1; position <= contextSize; position += 1) {
        // add new repeatitem

        const clonedTemplate = this._clone();
        if (!clonedTemplate) return;

        // ### cloned templates are always appended to the binding element - the one having the data-ref
        const bindingElement = this.querySelector('[data-ref]');
        bindingElement.appendChild(clonedTemplate);
        clonedTemplate.classList.add('fx-repeatitem');
        clonedTemplate.setAttribute('index', position);
        clonedTemplate.addEventListener('click', this._dispatchIndexChange);
        // this.addEventListener('focusin', this._handleFocus);
        clonedTemplate.addEventListener('focusin', this._dispatchIndexChange);

        // this._initVariables(clonedTemplate);

        // newItem.nodeset = this.nodeset[position - 1];
        // newItem.index = position;
        this.getOwnerForm().someInstanceDataStructureChanged = true;
      }
    }

    // ### update nodeset of repeatitems
    repeatItems = this.querySelectorAll(':scope > .fx-repeatitem');
    repeatItemCount = repeatItems.length;
    for (let position = 0; position < repeatItemCount; position += 1) {
      const item = repeatItems[position];
      this.getOwnerForm().registerLazyElement(item);
      if (item.nodeset !== this.nodeset[position]) {
        item.nodeset = this.nodeset[position];
      }
    }

    // Fore.refreshChildren(clone,true);
    const fore = this.getOwnerForm();
    if (!fore.lazyRefresh || force) {
      Fore.refreshChildren(this, force);
    }
    // this.style.display = 'block';
    // this.style.display = this.display;
    this.setIndex(this.index);
  }
  _dispatchIndexChange() {
    this.dispatchEvent(new CustomEvent('item-changed', {
      composed: false,
      bubbles: true,
      detail: {
        item: this,
        index: this.index
      }
    }));
  }

  // eslint-disable-next-line class-methods-use-this
  _fadeOut(el) {
    el.style.opacity = 1;
    (function fade() {
      // eslint-disable-next-line no-cond-assign
      if ((el.style.opacity -= 0.1) < 0) {
        el.style.display = 'none';
      } else {
        requestAnimationFrame(fade);
      }
    })();
  }

  // eslint-disable-next-line class-methods-use-this
  _fadeIn(el) {
    if (!el) return;
    el.style.opacity = 0;
    el.style.display = this.display;
    (function fade() {
      // setTimeout(() => {
      let val = parseFloat(el.style.opacity);
      // eslint-disable-next-line no-cond-assign
      if (!((val += 0.1) > 1)) {
        el.style.opacity = val;
        requestAnimationFrame(fade);
      }
      // }, 40);
    })();
  }

  async _initTemplate() {
    // const defaultSlot = this.shadowRoot.querySelector('slot');
    // todo: this is still weak - should handle that better maybe by an explicit slot?
    // this.template = this.firstElementChild;
    this.template = this.querySelector('template');

    /*
    if (this.template === null) {
      // console.error('### no template found for this repeat:', this.id);
      // todo: catch this on form element
      this.dispatchEvent(
        new CustomEvent('no-template-error', {
          composed: true,
          bubbles: true,
          detail: { message: `no template found for repeat:${this.id}` },
        }),
      );
    }
    */
    if (!this.template) {
      return;
    }
    this.shadowRoot.appendChild(this.template);
  }
  _initVariables(newRepeatItem) {
    const inScopeVariables = new Map(this.inScopeVariables);
    newRepeatItem.setInScopeVariables(inScopeVariables);
    (function registerVariables(node) {
      for (const child of node.children) {
        if ('setInScopeVariables' in child) {
          child.setInScopeVariables(inScopeVariables);
        }
        registerVariables(child);
      }
    })(newRepeatItem);
  }
  _clone() {
    this.template = this.shadowRoot.querySelector('template');
    if (!this.template) return;
    return this.template.content.firstElementChild.cloneNode(true);
  }
  _removeIndexMarker() {
    const refd = this.querySelector('[data-ref]');
    Array.from(refd.children).forEach(item => {
      item.removeAttribute('repeat-index');
    });
  }
  setInScopeVariables(inScopeVariables) {
    // Repeats are interesting: the variables should be scoped per repeat item, they should not be
    // able to see the variables in adjacent repeat items!
    this.inScopeVariables = new Map(inScopeVariables);
  }
}
if (!customElements.get('fx-repeat-attributes')) {
  window.customElements.define('fx-repeat-attributes', FxRepeatAttributes);
}

/**
 * Makes the dirty state of the form.
 *
 * Clean when there are no changes yet or all is submitted,
 * Dirty when there are unsaved changes.
 *
 * We might need a 'saving' state later
 */
const dirtyStates = {
  CLEAN: 'clean',
  DIRTY: 'dirty'
};

/**
 * Main class for Fore.Outermost container element for each Fore application.
 *
 * Root element for Fore. Kicks off initialization and displays messages.
 *
 * fx-fore is the outermost container for each form. A form can have exactly one model
 * with arbitrary number of instances.
 *
 * Main responsibilities are initialization and updating of model and instances, update of UI (refresh) and global messaging.
 *
 * @event compute-exception - dispatched in case the dependency graph is circular
 * @event refresh-done - dispatched after a refresh() run
 * @event ready - dispatched after Fore has fully been initialized
 * @event error - dispatches error when template expression fails to evaluate
 *
 * @ts-check
 */
class FxFore extends HTMLElement {
  static get properties() {
    return {
      /**
       * wether to create nodes that are missing in the loaded data and
       * auto-create nodes when there's a binding found in the UI.
       */
      createNodes: {
        type: Boolean
      },
      /**
       * ignore certain nodes for template expression search
       */
      ignoreExpressions: {
        type: String
      },
      /**
       * merge-partial
       */
      mergePartial: {
        type: Boolean
      },
      /**
       * Setting this marker attribute will refresh the UI in a lazy fashion just updating elements being
       * in viewport.
       *
       * this feature is still experimental and should be used with caution and extra testing
       */
      lazyRefresh: {
        type: Boolean
      },
      model: {
        type: Object
      },
      ready: {
        type: Boolean
      },
      strict: {
        type: Boolean
      },
      /**
       *
       */
      validateOn: {
        type: String
      },
      version: {
        type: String
      }
    };
  }

  /**
   * attaches handlers for
   *
   * - `model-construct-done` to trigger the processing of the UI
   * - `message` - to display a message triggered by an fx-message action
   * - `error` - to display an error message
   * - 'compute-exception`  - warn about circular dependencies in graph
   */
  constructor() {
    super();
    this.version = 'Version: 2.6.0 - built on June 10, 2025 12:45:43';
    this.model = {};
    this.inited = false;
    // this.addEventListener('model-construct-done', this._handleModelConstructDone);
    // todo: refactoring - these should rather go into connectedcallback
    this.addEventListener('message', this._displayMessage);
    // this.addEventListener('error', this._displayError);
    this.addEventListener('error', this._logError);
    this.addEventListener('warn', this._displayWarning);
    // this.addEventListener('log', this._logError);
    window.addEventListener('compute-exception', e => {
      console.error('circular dependency: ', e);
    });
    this.ready = false;
    this.storedTemplateExpressionByNode = new Map();

    // Stores the outer most action handler. If an action handler is already running, all
    // updates are included in that one
    this.outermostHandler = null;
    this.copiedElements = new WeakSet();
    this.dirtyState = dirtyStates.CLEAN;
    this.showConfirmation = false;
    const style = `
            :host {
                display: block;
            }
            :host ::slotted(fx-model){
                display:none;
            }

            #modalMessage .dialogActions{
                text-align:center;
            }
            .overlay {
              position: fixed;
              top: 0;
              bottom: 0;
              left: 0;
              right: 0;
              background: rgba(0, 0, 0, 0.7);
              transition: all 500ms;
              visibility: hidden;
              opacity: 0;
              z-index:10;
            }
            .overlay.show {
              visibility: visible;
              opacity: 1;
            }

            .popup {
              margin: 70px auto;
              background: #fff;
              border-radius: 5px;
              width: 30%;
              position: relative;
              transition: all 5s ease-in-out;
                            padding: 20px;

            }
            .popup h2 {
              margin-top: 0;
              width:100%;
              background:#eee;
              position:absolute;
              top:0;
              right:0;
              left:0;
              height:40px;
             border-radius: 5px;

            }
            .popup .close {
                position: absolute;
                top: 3px;
                right: 10px;
                transition: all 200ms;
                font-size: 30px;
                font-weight: bold;
                text-decoration: none;
                color: #333;
            }
            .popup .close:focus{
                outline:none;
            }

            .popup .close:hover {
                color: #06D85F;
            }
            #messageContent{
                margin-top:40px;
            }
            .warning{
                background:orange;
            }
        `;
    const html = `
<!--           <slot name="errors"></slot> -->
           <jinn-toast id="message" gravity="bottom" position="left"></jinn-toast>
           <jinn-toast id="sticky" gravity="bottom" position="left" duration="-1" close="true" data-class="sticky-message"></jinn-toast>
           <jinn-toast id="error" text="error" duration="-1" data-class="error" close="true" position="right" gravity="top" escape-markup="false"></jinn-toast>
           <jinn-toast id="warn" text="warning" duration="5000" data-class="warning" position="left" gravity="top"></jinn-toast>
           <slot id="default"></slot>
           <slot name="messages"></slot>
           <div id="modalMessage" class="overlay">
                <div class="popup">
                   <h2></h2>
                    <a class="close" href="#"  onclick="event.target.parentNode.parentNode.classList.remove('show')" autofocus>&times;</a>
                    <div id="messageContent"></div>
                </div>
           </div>
           <slot name="event"></slot>
        `;
    this.attachShadow({
      mode: 'open'
    });
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;
    this.toRefresh = [];
    this.initialRun = true;
    this._scanForNewTemplateExpressionsNextRefresh = false;
    this.repeatsFromAttributesCreated = false;
    this.validateOn = this.hasAttribute('validate-on') ? this.getAttribute('validate-on') : 'update';
    // this.mergePartial = this.hasAttribute('merge-partial')? true:false;
    this.mergePartial = false;
    this.createNodes = this.hasAttribute('create-nodes') ? true : false;
    this._localNamesWithChanges = new Set();
    this.setAttribute('role', 'form'); // set aria role
  }

  connectedCallback() {
    this.style.visibility = 'hidden';
    console.time('init');
    this.strict = !!this.hasAttribute('strict');
    /*
            document.addEventListener('ready', (e) =>{
              if(e.target !== this){
                // e.preventDefault();
                console.log('>>> e', e);
                console.log('event this', this);
                // console.log('event eventPhase', e.eventPhase);
                // console.log('event cancelable', e.cancelable);
                console.log('event target', e.target);
                console.log('event composed', e.composedPath());
                console.log('<<< event stopping');
                e.stopPropagation();
              }else{
                console.log('event proceed', this);
              }
              // e.stopImmediatePropagation();
            },true);
        */
    this.ignoreExpressions = this.hasAttribute('ignore-expressions') ? this.getAttribute('ignore-expressions') : null;
    this.lazyRefresh = this.hasAttribute('refresh-on-view');
    if (this.lazyRefresh) {
      const options = {
        root: null,
        rootMargin: '0px',
        threshold: 0.3
      };
      this.intersectionObserver = new IntersectionObserver(this.handleIntersect, options);
    }
    this.src = this.hasAttribute('src') ? this.getAttribute('src') : null;
    if (this.src) {
      this._loadFromSrc();
      return;
    }
    this._injectDevtools();
    const slot = this.shadowRoot.querySelector('slot#default');
    slot.addEventListener('slotchange', async event => {
      // preliminary addition for auto-conversion of non-prefixed element into prefixed elements. See fore.js
      // console.log(`### <<<<< slotchange on '${this.id}' >>>>>`);
      if (this.inited) return;
      if (this.hasAttribute('convert')) {
        this.replaceWith(Fore.copyDom(this));
        // Fore.copyDom(this);
        return;
      }
      if (this.ignoreExpressions) {
        this.ignoredNodes = Array.from(this.querySelectorAll(this.ignoreExpressions));
      }
      const children = event.target.assignedElements();
      let modelElement = children.find(modelElem => modelElem.nodeName.toUpperCase() === 'FX-MODEL');
      if (!modelElement) {
        const generatedModel = document.createElement('fx-model');
        this.appendChild(generatedModel);
        modelElement = generatedModel;
        // We are going to get a new slotchange event immediately, because we changed a slot.
        // so cancel this one.
        return;
      }
      if (!modelElement.inited) {
        console.info(`%cFore is processing fx-fore#${this.id}`, 'background:#64b5f6; color:white; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
        const variables = new Map();
        (function registerVariables(node) {
          for (const child of node.children) {
            if ('setInScopeVariables' in child) {
              child.setInScopeVariables(variables);
            }
            registerVariables(child);
          }
        })(this);
        await modelElement.modelConstruct();
        this._handleModelConstructDone();
      }
      this.model = modelElement;
      this._createRepeatsFromAttributes();
      this.inited = true;
    });
    this.addEventListener('path-mutated', () => {
      this.someInstanceDataStructureChanged = true;
    });
    this.addEventListener('refresh', () => {
      this.refresh(true);
    });
    if (this.hasAttribute('show-confirmation')) {
      this.showConfirmation = true;
    }
  }
  _injectDevtools() {
    if (this.ownerDocument.querySelector('fx-devtools')) {
      // There's already a devtools, so we can ignore this one.
      // One devtools can focus multiple fore elements
      return;
    }
    const {
      search
    } = window.location;
    const urlParams = new URLSearchParams(search);
    if (urlParams.has('inspect')) {
      const devtools = document.createElement('fx-devtools');
      document.body.appendChild(devtools);
    }
    if (urlParams.has('lens')) {
      const lens = document.createElement('fx-lens');
      document.body.appendChild(lens);
      lens.setAttribute('open', 'open');
    }
  }

  /**
   * Add a model item to the refresh list
   *
   * @param {import('./modelitem.js').ModelItem} modelItem
   * @returns {void}
   */
  addToRefresh(modelItem) {
    const found = this.toRefresh.find(mi => mi.path === modelItem.path);
    if (!found) {
      this.toRefresh.push(modelItem);
    }
  }

  /**
   * Signal something happened with an element with the given local name. This will be used in the
   * next (non-forceful) refresh to detect whether a component (usually a repeat) should update
   *
   * @param {string} localNameOfElement
   */
  signalChangeToElement(localNameOfElement) {
    this._localNamesWithChanges.add(localNameOfElement);
  }

  /**
   * Raise a flag that there might be new template expressions under some node. This happens with
   * repeats updating (new repeat items can have new template expressions) or switches changing their case (new case = new raw HTML)
   */
  scanForNewTemplateExpressionsNextRefresh() {
    // TODO: also ask for the root of any new HTML: this can prevent some very deep queries.
    this._scanForNewTemplateExpressionsNextRefresh = true;
  }
  markAsClean() {
    this.addEventListener('value-changed', () => {
      this.dirtyState = dirtyStates.DIRTY;
    }, {
      once: true
    });
    this.dirtyState = dirtyStates.CLEAN;
  }

  /**
   * loads a Fore from an URL given by `src`.
   *
   * Will extract the `fx-fore` element from that target file and use and replace current `fx-fore` element with the loaded one.
   * @private
   */
  async _loadFromSrc() {
    // console.log('########## loading Fore from ', this.src, '##########');
    await Fore.loadForeFromSrc(this, this.src, 'fx-fore');
  }

  /**
   * refreshes the UI by using IntersectionObserver API. This is the handler being called
   * by the observer whenever elements come into / move out of viewport.
   * @param entries
   * @param observer
   */
  handleIntersect(entries, observer) {
    // console.time('refreshLazy');

    entries.forEach(entry => {
      const {
        target
      } = entry;
      const fore = Fore.getFore(target);
      if (fore.initialRun) return;
      if (entry.isIntersecting) {
        // console.log('in view', entry);
        // console.log('repeat in view entry', entry.target);
        // const target = entry.target;
        // if(target.hasAttribute('refresh-on-view')){
        target.classList.add('loaded');
        // }

        // todo: too restrictive here? what if target is a usual html element? shouldn't it refresh downwards?
        if (typeof target.refresh === 'function') {
          // console.log('refreshing target', target);
          target.refresh(target, true);
        } else {
          // console.log('refreshing children', target);
          Fore.refreshChildren(target, true);
        }
      }
    });
    entries[0].target.getOwnerForm().dispatchEvent(new CustomEvent('refresh-done'));

    // console.timeEnd('refreshLazy');
  }

  evaluateToNodes(xpath, context) {
    return evaluateXPathToNodes(xpath, context, this);
  }
  disconnectedCallback() {
    this.removeEventListener('dragstart', this.dragstart);
    /*
            this.removeEventListener('model-construct-done', this._handleModelConstructDone);
            this.removeEventListener('message', this._displayMessage);
            this.removeEventListener('error', this._displayError);
            this.storedTemplateExpressionByNode=null;
            this.shadowRoot = undefined;
        */
  }

  /**
   * refreshes the whole UI by visiting each bound element (having a 'ref' attribute) and applying the state of
   * the bound modelItem to the bound element.
   *
   *
   * force - boolean - if true will refresh all children disregarding toRefresh array
   *
   */
  async forceRefresh() {
    // console.time('refresh');
    // console.group('### forced refresh', this);

    Fore.refreshChildren(this, true);
    this._updateTemplateExpressions();
    this._scanForNewTemplateExpressionsNextRefresh = false; // reset
    this._processTemplateExpressions();

    // console.log(`### <<<<< refresh-done ${this.id} >>>>>`);

    Fore.dispatch(this, 'refresh-done', {});

    // console.groupEnd();
    // console.timeEnd('refresh');
  }

  // async refresh(force, changedPaths) {
  /**
   * @param {(boolean|{reason:'index-function'})} [force]fx-fore
   */
  async refresh(force) {
    if (this.isRefreshing) {
      return;
    }
    if (force !== true && this._localNamesWithChanges.size > 0) {
      force = {
        ...(force || {
          reason: undefined
        }),
        elementLocalnamesWithChanges: Array.from(this._localNamesWithChanges)
      };
      this._localNamesWithChanges.clear();
    }
    this.isRefreshing = true;

    // refresh () {
    // ### refresh Fore UI elements
    // if (!this.initialRun && this.toRefresh.length !== 0) {
    // if (!this.initialRun && this.toRefresh.length !== 0) {
    if (!force && !this.initialRun && this.toRefresh.length !== 0) {
      this.refreshChanged(force);
    } else {
      // ### resetting visited state for controls to refresh
      /*
                  const visited = this.parentNode.querySelectorAll('.visited');
                  Array.from(visited).forEach(v =>{
                      v.classList.remove('visited');
                  });
      */

      if (this.inited) {
        console.log(`### <<<<< refresh() on '${this.id}' >>>>>`);
        Fore.refreshChildren(this, force);
      }
      // console.timeEnd('refreshChildren');
    }

    // ### refresh template expressions
    if (force || this.initialRun || this._scanForNewTemplateExpressionsNextRefresh) {
      this._updateTemplateExpressions();
      this._scanForNewTemplateExpressionsNextRefresh = false; // reset
    }

    this._processTemplateExpressions();

    // console.log('### <<<<< dispatching refresh-done - end of UI update cycle >>>>>');
    // this.dispatchEvent(new CustomEvent('refresh-done'));
    // this.initialRun = false;
    this.style.visibility = 'visible';
    console.info(`%crefresh-done on #${this.id}`, 'background:darkorange; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
    Fore.dispatch(this, 'refresh-done', {});

    // this.isRefreshing = true;
    // this.parentNode.closest('fx-fore')?.refresh(false, changedPaths);

    const subFores = Array.from(this.querySelectorAll('fx-fore'));
    /*
            calling the parent to refresh causes errors and inconsistent state. Also it is questionable
            if a child should actually interact with its parent in this way.
             This only affects the refreshing NOT the data mutation itself which is happening as expected.
             Current solution is that a child that wants the parent to refresh must do so by adding an additional
            event handler that dispatches an event upwards and having a handler in the parent to refresh itself.
             So refreshed propagate downwards but not upwards which is at least an option to consider.
             if(this.parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE){
                // await this.parentNode.closest('fx-fore')?.refresh(false);
            }
    */
    for (const subFore of subFores) {
      // subFore.refresh(false, changedPaths);
      if (subFore.ready) {
        // Do an unconditional hard refresh: there might be changes that are relevant
        await subFore.refresh(true);
      }
    }
    this.isRefreshing = false;
  }
  refreshChanged(force) {
    console.log('toRefresh', this.toRefresh);

    // ### after recalculation the changed modelItems are copied to 'toRefresh' array for processing
    this.toRefresh.forEach(modelItem => {
      // check if modelItem has boundControls - if so, call refresh() for each of them
      const controlsToRefresh = modelItem.boundControls;
      if (controlsToRefresh) {
        controlsToRefresh.forEach(ctrl => {
          ctrl.refresh(force);
        });
      }

      // ### check if other controls depend on current modelItem
      const {
        mainGraph
      } = this.getModel();
      if (mainGraph && mainGraph.hasNode(modelItem.path)) {
        const deps = this.getModel().mainGraph.dependentsOf(modelItem.path, false);
        // ### iterate dependant modelItems and refresh all their boundControls
        if (deps.length !== 0) {
          deps.forEach(dep => {
            // ### if changed modelItem has a 'facet' path we use the basePath that is the locationPath without facet name
            const basePath = XPathUtil.getBasePath(dep);
            const modelItemOfDep = this.getModel().modelItems.find(mip => mip.path === basePath);
            // ### refresh all boundControls
            modelItemOfDep.boundControls.forEach(control => {
              control.refresh(force);
            });
          });
        }
      }
    });
    this.toRefresh = [];
  }

  /**
   * entry point for processing of template expression enclosed in '{}' brackets.
   *
   * Expressions are found with an XPath search. For each node an entry is added to the storedTemplateExpressionByNode map.
   *
   *
   * @private
   */
  _updateTemplateExpressions() {
    const search = "(descendant-or-self::*!(text(), @*))[contains(., '{')][substring-after(., '{') => contains('}')][not(ancestor-or-self::fx-model)]";
    const tmplExpressions = evaluateXPathToNodes(search, this, this);
    // console.log('template expressions found ', tmplExpressions);

    if (!this.storedTemplateExpressions) {
      this.storedTemplateExpressions = [];
    }

    // console.log('######### storedTemplateExpressions', this.storedTemplateExpressions.length);

    /*
                storing expressions and their nodes for re-evaluation
                 */
    Array.from(tmplExpressions).forEach(node => {
      const ele = node.nodeType === Node.ATTRIBUTE_NODE ? node.ownerElement : node.parentNode;
      if (ele.closest('fx-fore') !== this) {
        // We found something in a sub-fore. Act like it's not there
        return;
      }
      if (this.storedTemplateExpressionByNode.has(node)) {
        // If the node is already known, do not process it twice
        return;
      }
      const expr = this._getTemplateExpression(node);

      // console.log('storedTemplateExpressionByNode', this.storedTemplateExpressionByNode);
      if (expr) {
        this.storedTemplateExpressionByNode.set(node, expr);
      }
    });
    // console.log('stored template expressions ', this.storedTemplateExpressionByNode);

    // TODO: Should we clean up nodes that existed but are now gone?
    this._processTemplateExpressions();
  }
  _processTemplateExpressions() {
    for (const node of Array.from(this.storedTemplateExpressionByNode.keys())) {
      if (node.nodeType === Node.ATTRIBUTE_NODE) {
        // Attribute nodes are not contained by the document, but their owner elements are!
        if (!XPathUtil.contains(this, node.ownerElement)) {
          this.storedTemplateExpressionByNode.delete(node);
          continue;
        }
      } else if (!XPathUtil.contains(this, node)) {
        // For all other nodes, if this `fore` element does not contain them, they are dead
        this.storedTemplateExpressionByNode.delete(node);
        continue;
      }
      this._processTemplateExpression({
        node,
        expr: this.storedTemplateExpressionByNode.get(node)
      });
    }
  }

  // eslint-disable-next-line class-methods-use-this
  _processTemplateExpression(exprObj) {
    // console.log('processing template expression ', exprObj);

    const {
      expr
    } = exprObj;
    const {
      node
    } = exprObj;
    // console.log('expr ', expr);
    this.evaluateTemplateExpression(expr, node);
  }

  /**
   * evaluate a template expression on a node either text- or attribute node.
   * @param {string} expr The string to parse for expressions
   * @param {Node} node the node which will get updated with evaluation result
   */
  evaluateTemplateExpression(expr, node) {
    // ### do not evaluate template expressions with nonrelevant sections
    if (node.nodeType === Node.ATTRIBUTE_NODE && node.ownerElement.closest('[nonrelevant]')) return;
    if (node.nodeType === Node.TEXT_NODE && node.parentNode.closest('[nonrelevant]')) return;
    if (node.nodeType === Node.ELEMENT_NODE && node.closest('[nonrelevant]')) return;

    // if(node.closest('[nonrelevant]')) return;
    const replaced = expr.replace(/{[^}]*}/g, match => {
      if (match === '{}') return match;
      const naked = match.substring(1, match.length - 1);
      const inscope = getInScopeContext(node, naked);
      if (!inscope) {
        console.warn('no inscope context for expr', naked);
        node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ATTRIBUTE_NODE ? node.parentNode : node;
        return match;
      }
      // Templates are special: they use the namespace configuration from the place where they are
      // being defined
      const instanceId = XPathUtil.getInstanceId(naked);

      // If there is an instance referred
      const inst = instanceId ? this.getModel().getInstance(instanceId) : this.getModel().getDefaultInstance();
      try {
        return evaluateXPathToString(naked, inscope, node, null, inst);
      } catch (error) {
        console.warn('ignoring unparseable expr', error);
        return match;
      }
    });

    // Update to the new value. Don't do it though if nothing changed to prevent iframes or
    // images from reloading for example
    if (node.nodeType === Node.ATTRIBUTE_NODE) {
      const parent = node.ownerElement;
      if (parent.getAttribute(node.nodeName) !== replaced) {
        parent.setAttribute(node.nodeName, replaced);
      }
    } else if (node.nodeType === Node.TEXT_NODE) {
      if (node.textContent !== replaced) {
        node.textContent = replaced;
      }
    }
  }

  // eslint-disable-next-line class-methods-use-this
  _getTemplateExpression(node) {
    if (this.ignoredNodes) {
      if (node.nodeType === Node.ATTRIBUTE_NODE) {
        node = node.ownerElement;
      }
      const found = this.ignoredNodes.find(n => n.contains(node));
      if (found) return null;
    }
    if (node.nodeType === Node.ATTRIBUTE_NODE) {
      return node.value;
    }
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent.trim();
    }
    return null;
  }

  /**
   * called when `model-construct-done` event is received to
   * start initing the UI.
   *
   * @private
   */
  _handleModelConstructDone() {
    this.markAsClean();
    if (this.showConfirmation) {
      window.addEventListener('beforeunload', event => {
        if (this.dirtyState === dirtyStates.DIRTY) {
          event.preventDefault();
          return true;
        }
        return false;
      });
    }
    this._initUI();
  }

  /**
   * If there's no instance element found in a fx-model during init it will construct
   * an instance from UI bindings.
   *
   * @returns {Promise<void>}
   * @private
   */
  async _lazyCreateInstance() {
    const model = this.querySelector('fx-model');

    // ##### lazy creation should NOT take place if there's a parent Fore using shared instances
    const parentFore = this.parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? this.parentNode.closest('fx-fore') : null;
    if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      console.log('fragment', this.parentNode);
    }
    if (parentFore) {
      const shared = parentFore.getModel().instances.filter(shared => shared.hasAttribute('shared'));
      if (shared.length !== 0) return;
    }

    // still need to catch just in case...
    try {
      if (model.instances.length === 0) {
        // console.log('### lazy creation of instance');
        const generatedInstance = document.createElement('fx-instance');
        model.appendChild(generatedInstance);
        const generated = document.implementation.createDocument(null, 'data', null);
        // const newData = this._generateInstance(this, generated.firstElementChild);
        this._generateInstance(this, generated.firstElementChild);
        generatedInstance.instanceData = generated;
        model.instances.push(generatedInstance);
        // console.log('generatedInstance ', this.getModel().getDefaultInstanceData());
        Fore.dispatch(this, 'instance-loaded', {
          instance: this
        });
      }
    } catch (e) {
      console.warn('lazyCreateInstance created an error attempting to create a document', e.message);
    }
  }

  /**
   * @param {Element} start
   * @param {Element} parent
   */
  _generateInstance(start, parent) {
    if (start.hasAttribute('ref') && !Fore.isActionElement(start.nodeName)) {
      const ref = start.getAttribute('ref');
      if (ref.includes('/')) {
        // console.log('complex path to create ', ref);
        const steps = ref.split('/');
        steps.forEach(step => {
          // const generated = document.createElement(ref);
          parent = this._generateNode(parent, step, start);
        });
      } else {
        parent = this._generateNode(parent, ref, start);
      }
    }
    if (start.hasChildNodes()) {
      const list = start.children;
      for (let i = 0; i < list.length; i += 1) {
        this._generateInstance(list[i], parent);
      }
    }
    return parent;
  }

  // eslint-disable-next-line class-methods-use-this
  _generateNode(parent, step, start) {
    const generated = parent.ownerDocument.createElement(step);
    if (start.children.length === 0) {
      generated.textContent = start.textContent;
    }
    parent.appendChild(generated);
    parent = generated;
    return parent;
  }

  /*
            _createStep(){
             }
          */

  /*
            _generateInstance(start, parent) {
              if (start.hasAttribute('ref')) {
                const ref = start.getAttribute('ref');
                 if(ref.includes('/')){
                  console.log('complex path to create ', ref);
                  const steps = ref.split('/');
                  steps.forEach(step => {
                    console.log('step ', step);
                   });
                }
                 // const generated = document.createElement(ref);
                const generated = parent.ownerDocument.createElement(ref);
                if (start.children.length === 0) {
                  generated.textContent = start.textContent;
                }
                parent.appendChild(generated);
                parent = generated;
              }
               if (start.hasChildNodes()) {
                const list = start.children;
                for (let i = 0; i < list.length; i += 1) {
                  this._generateInstance(list[i], parent);
                }
              }
              return parent;
            }
          */

  /**
   * Start the initialization of the UI by
   *
   * 1. checking if a instance needs to be generated
   * 2. attaching lazy loading intersection observers if `refresh-on-view` attributes are found
   * 3. doing a full refresh of the UI
   *
   * @returns {Promise<void>}
   * @private
   */
  async _initUI() {
    // console.log('### _initUI()');
    console.info(`%cinitUI #${this.id}`, 'background:lightblue; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
    if (!this.initialRun) return;
    this.classList.add('initialRun');
    await this._lazyCreateInstance();

    /*
            const options = {
              root: null,
              rootMargin: '0px',
              threshold: 0.3,
            };
        */

    // First refresh should be forced
    if (this.createNodes) {
      this.initData();
    }
    await this.refresh(true);

    // this.style.display='block'
    this.classList.add('fx-ready');
    document.body.classList.add('fx-ready');
    this.ready = true;
    this.initialRun = false;
    // console.log('### >>>>> dispatching ready >>>>>', this);
    console.info(`%c #${this.id} is ready`, 'background:lightblue; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');

    // console.log(`### <<<<< ${this.id} ready >>>>>`);

    // console.log('### modelItems: ', this.getModel().modelItems);
    Fore.dispatch(this, 'ready', {});
    // console.log('dataChanged', FxModel.dataChanged);
    console.timeEnd('init');
    this.addEventListener('dragstart', this._handleDragStart);
    //	this.addEventListener('dragend', this._handleDragEnd);
    this.handleDrop = event => this._handleDrop(event);
    this.ownerDocument.body.addEventListener('drop', this.handleDrop);
    this.ownerDocument.body.addEventListener('dragover', e => {
      e.preventDefault();
      e.stopPropagation();
      e.dataTransfer.dropEffect = 'move';
    });
  }

  /**
   * @param  {HTMLElement}  root The root of the data initialization. fx-repeat overrides this when it makes new repeat items
   *
   */
  initData(root = this) {
    // const created = new Promise(resolve => {
    // console.log('INIT');
    // const boundControls = Array.from(root.querySelectorAll('[ref]:not(fx-model *),fx-repeatitem'));

    const boundControls = Array.from(root.querySelectorAll('fx-control[ref],fx-upload[ref],fx-group[ref],fx-repeat[ref], fx-switch[ref]'));
    if (root.matches('fx-repeatitem')) {
      boundControls.unshift(root);
    }
    // console.log('_initD', boundControls);
    for (let i = 0; i < boundControls.length; i++) {
      const bound = boundControls[i];

      /*
      ignore bound elements that are enclosed with a control like <select> or <fx-items> and repeated items
       */
      if (!bound.matches('fx-repeatitem') && !bound.parentNode.closest('fx-control')) {
        // Repeat items are dumb. They do not respond to evalInContext
        bound.evalInContext();
      }
      if (bound.nodeset !== null) {
        // console.log('Node exists', control.nodeset);
        continue;
      }
      // console.log('Node does not exists', control.ref);

      // We need to create that node!
      const previousControl = boundControls[i - 1];

      // Previous control can either be an ancestor of us, or a previous node, which can be a sibling, or a child of a sibling.
      // First: parent
      if (previousControl.contains(bound)) {
        // Parent is here.
        // console.log('insert into', control,previousControl);
        // console.log('insert into nodeset', control.nodeset);
        const parentNodeset = previousControl.nodeset;
        // console.log('parentNodeset', parentNodeset);

        // const parentModelItemNode = parentModelItem.node;
        const ref = bound.ref;
        // const newElement = parentModelItemNode.ownerDocument.createElement(ref);
        if (parentNodeset.querySelector(`[ref="${ref}"]`)) {
          console.log(`Node with ref "${ref}" already exists.`);
          continue;
        }
        const newElement = this._createNodes(ref, parentNodeset);

        // Plonk it in at the start!
        parentNodeset.insertBefore(newElement, parentNodeset.firstChild);
        bound.evalInContext();
        // console.log('CREATED child', newElement);
        // console.log('new control evaluated to ', control.nodeset);
        // Done!
        continue;
      }
      // console.log('previousControl', previousControl);
      // console.log('control', control);
      // Is previousControl a sibling or a descendant of a logical sibling? Keep looking backwards until we share parents!
      const ourParent = XPathUtil.getParentBindingElement(bound);
      // console.log('ourParent', ourParent);
      let siblingControl = null;
      /*
            for (let j = i - 1; j >= 0; --j) {
                const potentialSibling = boundControls[j];
                if (XPathUtil.getParentBindingElement(potentialSibling) === ourParent) {
                    siblingControl = potentialSibling;
                    break; // Exit once the sibling is found
                }
            }
      */
      for (let j = i - 1; j > 0; --j) {
        const siblingOrDescendant = boundControls[j];
        if (XPathUtil.getParentBindingElement(siblingOrDescendant) === ourParent) {
          siblingControl = siblingOrDescendant;
          break;
        }
      }
      if (!siblingControl) {
        throw new Error('Unexpected! there must be a sibling right?');
      }
      // console.log('sibling', siblingControl);
      // todo: review: should this not just be inscopeContext?
      const parentNodeset = ourParent.nodeset;
      const ref = bound.ref;
      let referenceNodeset = siblingControl.nodeset;
      const newElement = this._createNodes(ref, parentNodeset);

      // We know which node to insert this new element to, but it might be a descendant of a child of the actual parent. Walk up until we have a reference under our parent
      while (referenceNodeset?.parentNode && referenceNodeset?.parentNode !== parentNodeset) {
        referenceNodeset = referenceNodeset.parentNode;
      }

      // Insert before the next sibling our our logical previous sibling
      parentNodeset.insertBefore(newElement, referenceNodeset.nextElementSibling);
      /*
            console.log('control inscope', control.getInScopeContext());
            console.log('control ref', control.ref);
            console.log('control new element parent', newElement.parentNode.nodeName);
      */
      bound.evalInContext();
      // console.log('new control evaluated to ', control.nodeset);
      // console.log('CREATED sibling', newElement);
    }
    // console.log('DATA', this.getModel().getDefaultContext());
  }

  _createNodes(ref, referenceNode) {
    // console.log('creating', ref)
    // console.log('ownerDoc', referenceNode.ownerDocument);
    /*
        const existingNode = evaluateXPathToFirstNode(ref, referenceNode, this);
        if(existingNode){
            console.log(`Node already exists for ref: ${ref}`);
            return existingNode;
        }
    console.log(`creating new node for ref: ${ref}`);
    */
    let newElement;
    if (ref.includes('/')) {
      // multi-step ref expressions
      newElement = XPathUtil.createNodesFromXPath(ref, referenceNode.ownerDocument, this);
      // console.log('new subtree', newElement);
      return newElement;
    } else {
      return XPathUtil.createNodesFromXPath(ref, referenceNode.ownerDocument, this);
    }
  }
  _handleDragStart(event) {
    const draggedItem = event.target.closest('[draggable="true"]');
    this.originalDraggedItem = draggedItem;
    console.log('DRAG START', this);
    if (draggedItem.getAttribute('drop-action') === 'copy') {
      event.dataTransfer.dropEffect = 'copy';
      event.dataTransfer.effectAllowed = 'copy';
      this.draggedItem = draggedItem.cloneNode(true);
      this.draggedItem.setAttribute('drop-action', 'move');
      this.copiedElements.add(this.draggedItem);
    } else {
      event.dataTransfer.dropEffect = 'move';
      event.dataTransfer.effectAllowed = 'move';
      this.draggedItem = draggedItem;
    }
  }
  _handleDrop(event) {
    console.log('DROP ON BODY', this);
    if (!this.draggedItem) {
      return;
    }
    // A drop on 'body' should be a removal.
    if (event.dataTransfer.dropEffect === 'none') {
      if (this.copiedElements.has(this.originalDraggedItem)) {
        this.originalDraggedItem.remove();
      }
    }
    this.originalDraggedItem = null;
    this.draggedItem = null;
    event.stopPropagation();
  }
  registerLazyElement(element) {
    if (this.intersectionObserver) {
      // console.log('registerLazyElement',element);
      this.intersectionObserver.observe(element);
    }
  }
  unRegisterLazyElement(element) {
    if (this.intersectionObserver) {
      this.intersectionObserver.unobserve(element);
    }
  }

  /**
   *
   * @returns {FxModel}
   */
  getModel() {
    return this.querySelector('fx-model');
  }
  _displayMessage(e) {
    // console.log('_displayMessage',e);
    const {
      level
    } = e.detail;
    const msg = e.detail.message;
    this._showMessage(level, msg);
    e.stopPropagation();
  }
  _displayError(e) {
    // const { error } = e.detail;
    const msg = e.detail.message;
    // this._showMessage('modal', msg);
    const toast = this.shadowRoot.querySelector('#error');
    toast.showToast(msg);
  }
  _displayWarning(e) {
    const msg = e.detail.message;
    // this._showMessage('modal', msg);
    const path = XPathUtil.shortenPath(evaluateXPathToString('path()', e.target, this));
    const toast = this.shadowRoot.querySelector('#warn');
    toast.showToast(`WARN: ${path}:${msg}`);
  }
  _logError(e) {
    e.stopPropagation();
    e.preventDefault();
    console.error('ERROR', e.detail.message);
    console.error(e.detail.origin);
    if (e.detail.expr) {
      console.error('Failing expression', e.detail.expr);
    }
    if (this.strict) {
      this._displayError(e);
    }
  }
  _copyToClipboard(target) {
    console.log('copyToClipboard', target.value);
    navigator.clipboard.writeText(target.value);
  }
  _showMessage(level, msg) {
    if (level === 'modal') {
      // this.$.messageContent.innerText = msg;
      // this.$.modalMessage.open();

      this.shadowRoot.getElementById('messageContent').innerText = msg;
      // this.shadowRoot.getElementById('modalMessage').open();
      this.shadowRoot.getElementById('modalMessage').classList.add('show');
    } else if (level === 'sticky' || level === 'error' || level === 'warn') {
      // const notification = this.$.modeless;
      this.shadowRoot.querySelector(`#${level}`).showToast(msg);
    } else {
      const toast = this.shadowRoot.querySelector('#message');
      toast.showToast(msg);
    }
  }

  /**
   * wraps the element having a 'data-ref' attribute with an fx-repeat-attributes element.
   * @private
   */
  _createRepeatsFromAttributes() {
    if (this.repeatsFromAttributesCreated) return;
    const repeats = this.querySelectorAll('[data-ref]');
    if (repeats) {
      Array.from(repeats).forEach(item => {
        if (item.closest('fx-control')) return;
        /*
                        const parentRepeat = item.closest('fx-repeat');
                        if(parentRepeat){
                            this.dispatchEvent(
                                new CustomEvent('log', {
                                    composed: false,
                                    bubbles: true,
                                    cancelable:true,
                                    detail: { id:this.id, message: `nesting elements with data-ref attributes within fx-repeat is not supported by now`, level:'Error'},
                                }),
                            );
                        }
        */

        const table = item.parentNode.closest('table');
        let host;
        if (table) {
          host = table.cloneNode(true);
        } else {
          host = item.cloneNode(true);
        }
        // ### clone original item to move it into fx-repeat-attributes
        // const host = item.cloneNode(true);

        // ### create wrapper element
        const repeatFromAttr = new FxRepeatAttributes();
        // const repeatFromAttr = document.createElement('fx-repeat-attributes');

        // ### copy the value of 'data-ref' to 'ref' on fx-repeat-attributes
        repeatFromAttr.setAttribute('ref', item.getAttribute('data-ref'));
        // item.removeAttribute('data-ref');

        // ### append the cloned original element to fx-repeat-attributes
        repeatFromAttr.appendChild(host);

        // ### insert fx-repeat-attributes element before element with the 'data-ref'
        // repeats[0].parentNode.insertBefore(repeatFromAttr,repeats[0]);

        if (table) {
          table.parentNode.insertBefore(repeatFromAttr, table);
          table.parentNode.removeChild(table);
        } else {
          item.parentNode.insertBefore(repeatFromAttr, item);
          item.parentNode.removeChild(item);
        }

        // ### remove original item from DOM
        item.setAttribute('insertPoint', '');
      });
    }
    this.repeatsFromAttributesCreated = true;
  }
}
FxFore.outermostHandler = null;
FxFore.draggedItem = null;
if (!customElements.get('fx-fore')) {
  customElements.define('fx-fore', FxFore);
}

class Relevance {
  static handleRelevance(boundElement) {
    const modelItem = boundElement.getModelItem();
    if (modelItem && modelItem.relevant) {
      boundElement.removeAttribute('nonrelevant');
      boundElement.setAttribute('relevant', '');
      Fore.dispatch(this, 'relevant', {});
    } else {
      boundElement.removeAttribute('relevant');
      boundElement.setAttribute('nonrelevant', '');
      Fore.dispatch(this, 'nonrelevant', {});
    }
  }
  static selectRelevant(element, type) {
    // console.log('selectRelevant', type);
    switch (type) {
      case 'xml':
        return Relevance._relevantXmlNodes(element);
      default:
        console.warn(`relevance selection not supported for type:${element.type}`);
        return element.nodeset;
    }
  }
  static _relevantXmlNodes(element) {
    // ### no relevance selection - current nodeset is used 'as-is'
    const nonrelevant = element.getAttribute('nonrelevant');
    if (nonrelevant === 'keep') {
      return element.nodeset;
    }

    // first check if nodeset of submission is relevant - otherwise bail out
    const mi = element.getModel().getModelItem(element.nodeset);
    if (mi && !mi.relevant) return null;
    const root = element.nodeset.cloneNode(false);
    if (element.nodeset.children.length === 0 && Relevance._isRelevant(element, element.nodeset)) {
      return element.nodeset;
    }
    return Relevance._filterRelevant(element, element.nodeset, root);
  }
  static _filterRelevant(element, node, result) {
    const {
      childNodes
    } = node;
    Array.from(childNodes).forEach(n => {
      if (Relevance._isRelevant(element, n)) {
        const clone = n.cloneNode(false);
        result.appendChild(clone);
        const {
          attributes
        } = n;
        if (attributes) {
          Array.from(attributes).forEach(attr => {
            if (element.nonrelevant === 'empty' && !Relevance._isRelevant(element, attr)) {
              clone.setAttribute(attr.nodeName, '');
            } else if (Relevance._isRelevant(element, attr)) {
              clone.setAttribute(attr.nodeName, attr.value);
            } else {
              // if (element.nonrelevant === 'empty') {
              //   clone.setAttribute(attr.nodeName, '');
              // } else{
              clone.removeAttribute(attr.nodeName);
              // }
            }
            /*
            if (Relevance._isRelevant(element, attr)) {
              clone.setAttribute(attr.nodeName, attr.value);
            } else if (element.nonrelevant === 'empty') {
              clone.setAttribute(attr.nodeName, '');
            } else {
              clone.removeAttribute(attr.nodeName);
            }
            */
          });
        }

        return Relevance._filterRelevant(element, n, clone);
      }
      return null;
    });
    return result;
  }
  static _isRelevant(element, node) {
    const mi = element.getModel().getModelItem(node);

    // ### remove empty attributes as these usually are not expected in most XML languages.
    if (node.nodeType === Node.ATTRIBUTE_NODE && node.nodeValue === '') {
      return false;
    }
    // ### no modelItem means no constraints
    if (!mi) {
      return true;
    }
    // ### modelItem 'relevant' is defined and 'true'
    if (mi.relevant) {
      return true;
    }
    return false;
  }
}

/**
 * todo: validate='false'
 */
class FxSubmission extends ForeElementMixin {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.credentials = '';
    this.parameters = new Map();
  }
  connectedCallback() {
    // this.style.display = 'none';
    this.methods = ['get', 'put', 'post', 'delete', 'head', 'urlencoded-post'];
    this.model = this.parentNode;

    // ### initialize properties with defaults
    // if (!this.hasAttribute('id')) throw new Error('id is required');
    if (!this.hasAttribute('id')) console.warn('id is required');
    this.id = this.getAttribute('id');

    /** if present should be a existing instance id */
    this.instance = this.hasAttribute('instance') ? this.getAttribute('instance') : null;

    /** if present will determine XPath where to insert a response into when mode is 'replace' */
    this.into = this.hasAttribute('into') ? this.getAttribute('into') : null;

    /** http method */
    this.method = this.hasAttribute('method') ? this.getAttribute('method') : 'get';

    /** relevance processing - one of 'remove, keep or empty' */
    this.nonrelevant = this.hasAttribute('nonrelevant') ? this.getAttribute('nonrelevant') : 'remove';

    /** replace might be 'all', 'instance' or 'none' */
    this.replace = this.hasAttribute('replace') ? this.getAttribute('replace') : 'all';
    this.serialization = this.hasAttribute('serialization') ? this.getAttribute('serialization') : 'xml';
    this.mediatype = this.hasAttribute('mediatype') ? this.getAttribute('mediatype') : 'application/xml';
    this.responseMediatype = this.hasAttribute('responsemediatype') ? this.getAttribute('responsemediatype') : this.mediatype;
    this.url = this.hasAttribute('url') ? this.getAttribute('url') : null;
    this.targetref = this.hasAttribute('targetref') ? this.getAttribute('targetref') : null;
    this.validate = this.getAttribute('validate') ? this.getAttribute('validate') : 'true';
    this.credentials = this.hasAttribute('credentials') ? this.getAttribute('credentials') : 'same-origin';
    if (!['same-origin', 'include', 'omit'].includes(this.credentials)) {
      console.error(`fx-submission: the value of credentials is not valid. Expected 'same-origin', 'include' or 'omit' but got '${this.credentials}'`, this);
    }
    this.shadowRoot.innerHTML = this.renderHTML();
  }

  // eslint-disable-next-line class-methods-use-this
  renderHTML() {
    return `
      <slot></slot>
    `;
  }
  async submit() {
    await Fore.dispatch(this, 'submit', {
      submission: this
    });
    await this._submit();
  }
  async _submit() {
    console.info(`%csubmitting #${this.id}`, 'background:yellow; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
    this.evalInContext();
    const model = this.getModel();
    model.recalculate();
    if (this.validate === 'true' && this.method !== 'get') {
      const valid = model.revalidate();
      if (!valid) {
        console.log('validation failed. Submission stopped');
        this.getOwnerForm().classList.add('submit-validation-failed');
        // ### allow alerts to pop up
        // this.dispatch('submit-error', {});
        Fore.dispatch(this, 'submit-error', {
          status: 0,
          message: 'validation failed'
        });
        this.getModel().parentNode.refresh(true);
        return;
      }
    }
    await this._serializeAndSend();
  }
  _getProperty(attrName) {
    if (this.parameters.has(attrName)) {
      return this.parameters.get(attrName);
    }
    return this.getAttribute(attrName);
  }

  /**
   * sends the data after evaluating
   *
   * @private
   */
  async _serializeAndSend() {
    const url = this._getProperty('url');
    const resolvedUrl = this.evaluateAttributeTemplateExpression(url, this);
    // console.log('resolvedUrl', resolvedUrl);
    const instance = this.getInstance();
    if (!instance) {
      Fore.dispatch(this, 'warn', {
        message: `instance not found ${instance.getAttribute('id')}`
      });
    }
    const instType = instance.getAttribute('type');
    // console.log('instance type', instance.type);

    let serialized;
    if (this.serialization === 'none') {
      serialized = undefined;
    } else {
      // const relevant = this.selectRelevant(instance.type);
      const relevant = Relevance.selectRelevant(this, instType);
      serialized = this._serialize(instType, relevant);
    }

    // let serialized = serializer.serializeToString(relevant);
    if (this.method.toLowerCase() === 'get') {
      /*
             todo: serialize the bound instance element names as get parameters and using their text values
             as param values. leave out empty params and create querystring from the result.Elements may
             have exactly level deep or are otherwise ignored.
             <data>
                <id>1234</id>
                <name>john</name>
                <zip></zip>
                <!-- ignored as no direct text value -->
                <phone>
                    <mobile></mobile>
                <phone>
              </data>
              results in: ?id=1234&name=john to be appended to this.url on fetch
      */

      serialized = undefined;
    }
    // console.log('data being send', serialized);
    // console.log('submitting data',serialized);

    // if (resolvedUrl === '#echo') {
    if (resolvedUrl.startsWith('#echo')) {
      const data = this._parse(serialized, instance);
      this._handleResponse(data);
      // this.dispatch('submit-done', {});
      console.log('### <<<<< submit-done >>>>>');
      Fore.dispatch(this, 'submit-done', {});
      this.parameters.clear();
      return;
    }
    if (resolvedUrl.startsWith('localStore:')) {
      if (this.method === 'get' || this.method === 'consume') {
        // let data = this._parse(serialized, instance);
        this.replace = 'instance';
        const key = resolvedUrl.substring(resolvedUrl.indexOf(':') + 1);
        const serialized = localStorage.getItem(key);
        if (!serialized) {
          Fore.dispatch(this, 'submit-error', {
            status: 400,
            message: `Error reading key ${key} from localstorage`
          });
          this.parameters.clear();
          return;
        }
        const data = this._parse(serialized, instance);
        this._handleResponse(data);
        if (this.method === 'consume') {
          localStorage.removeItem(key);
        }
        console.log('### <<<<< submit-done >>>>>');
        Fore.dispatch(this, 'submit-done', {});
      }
      if (this.method === 'post') {
        // let data = this._parse(serialized, instance);
        const key = resolvedUrl.substring(resolvedUrl.indexOf(':') + 1);
        localStorage.setItem(key, serialized);
        this._handleResponse(instance.instanceData);
        console.log('### <<<<< submit-done >>>>>');
        Fore.dispatch(this, 'submit-done', {});
      }
      if (this.method === 'delete') {
        const key = resolvedUrl.substring(resolvedUrl.indexOf(':') + 1);
        localStorage.removeItem(key);
        const newInst = new DOMParser().parseFromString('<data></data>', 'application/xml');
        this.replace = 'instance';
        this._handleResponse(newInst);
        console.log('### <<<<< submit-done >>>>>');
        Fore.dispatch(this, 'submit-done', {});
      }
      return;
    }

    // ### setting headers
    const headers = this._getHeaders();
    if (!this.methods.includes(this.method.toLowerCase())) {
      // this.dispatch('error', { message: `Unknown method ${this.method}` });
      Fore.dispatch(this, 'error', {
        message: `Unknown method ${this.method}`
      });
      return;
    }
    try {
      const response = await fetch(resolvedUrl, {
        method: this.method,
        credentials: this.credentials,
        mode: 'cors',
        headers,
        body: serialized
      });
      if (!response.ok || response.status > 400) {
        // this.dispatch('submit-error', { message: `Error while submitting ${this.id}` });
        console.info(`%csubmit-error #${this.id}`, 'background:red; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
        Fore.dispatch(this, 'submit-error', {
          status: response.status,
          message: `Error during submit ${this.id}`
        });
        return;
      }
      const contentType = response.headers.get('content-type').toLowerCase();
      if (contentType.startsWith('text/')) {
        const text = await response.text();
        this._handleResponse(text, resolvedUrl, contentType);
      } else if (contentType.startsWith('application/json')) {
        const json = await response.json();
        this._handleResponse(json, resolvedUrl, contentType);
      } else if (contentType.startsWith('application/xml')) {
        const text = await response.text();
        const xml = new DOMParser().parseFromString(text, 'application/xml');
        this._handleResponse(xml, resolvedUrl, contentType);
      } else {
        const blob = await response.blob();
        this._handleResponse(blob, resolvedUrl, contentType);
      }

      // this.dispatch('submit-done', {});
      // console.log(`### <<<<< ${this.id} submit-done >>>>>`);
      Fore.dispatch(this, 'submit-done', {});
      /*
      console.info(
          `%csubmit-done #${this.id}`,
          'background:green; color:white; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;',
      );
      */
    } catch (error) {
      Fore.dispatch(this, 'submit-error', {
        status: 500,
        error: error.message
      });
    } finally {
      this.parameters.clear();
      const download = document.querySelector('[download]');
      if (download) {
        document.body.removeChild(download);
      }
    }
  }
  _parse(serialized, instance) {
    let data = null;
    if (serialized && instance.getAttribute('type') === 'xml') {
      data = new DOMParser().parseFromString(serialized, 'application/xml');
    }
    if (serialized && instance.getAttribute('type') === 'json') {
      data = JSON.parse(serialized);
    }
    if (serialized && instance.getAttribute('type') === 'text') {
      data = serialized;
    }
    return data;
  }
  _serialize(instanceType, relevantNodes) {
    if (this.serialization === 'application/x-www-form-urlencoded') {
      // this.method = 'post';
      const params = new URLSearchParams();
      // console.log('nodes to serialize', relevantNodes);
      Array.from(relevantNodes.children).forEach(child => {
        params.append(child.nodeName, child.textContent);
      });
      return params;
    }
    if (instanceType === 'xml') {
      const serializer = new XMLSerializer();
      return serializer.serializeToString(relevantNodes);
    }
    if (instanceType === 'json') {
      // console.warn('JSON serialization is not yet supported')
      return JSON.stringify(relevantNodes);
    }
    if (instanceType === 'text') {
      return relevantNodes;
    }
    throw new Error('unknown instance type ', instanceType);
  }
  _getHeaders() {
    const headers = new Headers();

    // ### set content-type header according to type of instance
    const instance = this.getInstance();
    const contentType = Fore.getContentType(instance, this.serialization);
    headers.append('Content-Type', contentType);
    // ### needed to overwrite browsers' setting of 'Accept' header
    if (headers.has('Accept')) {
      headers.delete('Accept');
    }
    // headers.append('Accept', 'application/xml');

    // ### add header defined by fx-header elements
    const headerElems = this.querySelectorAll('fx-header');
    Array.from(headerElems).forEach(header => {
      const {
        name
      } = header;
      const val = header.getValue();
      headers.append(name, val);
    });
    return headers;
  }
  _getUrlExpr() {
    return this.storedTemplateExpressions.find(stored => stored.node.nodeName === 'url');
  }
  _getTargetInstance() {
    let targetInstance;
    if (this.instance) {
      targetInstance = this.model.getInstance(this.instance);
    } else {
      targetInstance = this.model.getInstance('default');
    }
    if (!targetInstance) {
      throw new Error(`target instance not found: ${targetInstance}`);
    }
    return targetInstance;
  }

  /**
   * handles replacement of instance data from response data.
   *
   * Please note that data might be
   * @param data
   * @private
   */
  _handleResponse(data, resolvedUrl, contentType) {
    // console.log('_handleResponse ', data);

    const targetInstance = this._getTargetInstance();

    /*
        if(this.replace === 'merge'){
            if(targetInstance.type !== 'xml') {
                Fore.dispatch(this, "warn", {'message': 'merging of instances only work for type xml'});
            }
            if (targetInstance && targetInstance.type === 'xml') {
                targetInstance.partialInstance = data;
                // const resultDoc = new DOMParser(`${data.nodeName}`, 'application/xml');
                // console.log('resultDoc', resultDoc)
                const merged = Fore.combine(targetInstance.instanceData.firstElementChild, data.firstElementChild, this,null);
                console.log('merged', merged);
                 targetInstance.instanceData = merged;
                console.log('merging partial instance',targetInstance.partialInstance)
                this.model.updateModel();
                this.getOwnerForm().refresh(true);
            }
        }
    */

    if (this.replace === 'instance') {
      if (targetInstance) {
        if (this.targetref) {
          const [theTarget] = evaluateXPath(this.targetref, targetInstance.instanceData.firstElementChild, this);
          console.log('theTarget', theTarget);
          if (this.responseMediatype === 'application/xml' || this.responseMediatype === 'text/html') {
            const clone = data.firstElementChild;
            const parent = theTarget.parentNode;
            parent.replaceChild(clone, theTarget);
            console.log('finally ', parent);
          }
          if (this.responseMediatype.startsWith('text/')) {
            theTarget.textContent = data;
          }
          if (this.responseMediatype === 'application/json') {
            console.warn('targetref is not supported for application/json responses');
          }
        } else if (this.into) {
          const [theTarget] = evaluateXPath(this.into, targetInstance.instanceData.firstElementChild, this);
          console.log('theTarget', theTarget);
          if (data.nodeType === Node.DOCUMENT_NODE) {
            theTarget.appendChild(data.firstElementChild);
          } else {
            theTarget.innerHTML = data;
          }
        } else {
          const instanceData = data;
          targetInstance.instanceData = instanceData;
          // console.log('### replaced instance ', this.getModel().instances);
          // console.log('### replaced instance ', targetInstance.instanceData);
        }

        // Skip any refreshes if the model is not yet inited
        if (this.model.inited) {
          this.model.updateModel(); // force update
          this.getOwnerForm().refresh(true);
        }
      } else {
        throw new Error(`target instance not found: ${targetInstance}`);
      }
    }
    if (this.replace === 'download') {
      const target = this._getProperty('target');
      const downloadLink = document.createElement('a');
      downloadLink.setAttribute('download', target);
      downloadLink.setAttribute('href', `data:${contentType},${data}`);
      document.body.appendChild(downloadLink);
      downloadLink.click();
    }
    if (this.replace === 'all') {
      const target = this._getProperty('target');
      if (target && target === '_blank') {
        const win = window.open('', '_blank');
        win.document.write(`<pre>${data}</pre>`);
        win.document.close();
      } else {
        document.open();
        document.write(data);
        document.close();
        window.location.href = resolvedUrl;
      }
      // document.getElementsByTagName('html')[0].innerHTML = data;
    }

    if (this.replace === 'target') {
      // const target = this.getAttribute('target');
      const target = this._getProperty('target');
      const targetNode = document.querySelector(target);
      if (targetNode) {
        if (contentType.startsWith('text/html')) {
          targetNode.innerHTML = data;
        }
        if (this.responseMediatype.startsWith('image/svg')) {
          const parser = new DOMParser();
          parser.parseFromString(data, 'image/svg+xml');
          const objectURL = URL.createObjectURL(data);
          targetNode.src = objectURL;
        }
      } else {
        Fore.dispatch(this, 'submit-error', {
          message: `targetNode for selector ${target} not found`
        });
      }
    }
    if (this.replace === 'redirect') {
      window.location.href = data;
    }
  }

  /*
  _handleError() {
    // this.dispatch('submit-error', {});
    Fore.dispatch(this, 'submit-error', {});
    /!*
                    console.log('ERRRORRRRR');
                    this.dispatchEvent(
                        new CustomEvent('submit-error', {
                            composed: true,
                            bubbles: true,
                            detail: {},
                        }),
                    );
            *!/
  }
  */

  /*
    mergeNodes(node1, node2) {
        // Overwrite attributes in node1 with values from node2
        for (const { name, value } of node2.attributes) {
            node1.setAttribute(name, value);
        }
         const childNodes1 = Array.from(node1.childNodes);
        const childNodes2 = Array.from(node2.childNodes);
         // Append all child nodes from node2 to node1
        childNodes2.forEach(child2 => {
            if (child2.nodeType === 1) {
                // If it's an element node, check if a matching element exists in node1
                const matchingElement = childNodes1.find(
                    child1 => child1.nodeType === 1 && child1.tagName === child2.tagName
                );
                if (matchingElement) {
                    this.mergeNodes(matchingElement, child2); // Recursively merge matching elements
                } else {
                    const clonedNode = child2.cloneNode(true);
                    node1.appendChild(clonedNode);
                }
            } else {
                // For text nodes, simply append them to node1
                const clonedNode = child2.cloneNode(true);
                node1.appendChild(clonedNode);
            }
        });
    }
  */
}

if (!customElements.get('fx-submission')) {
  customElements.define('fx-submission', FxSubmission);
}

class FxHeader extends ForeElementMixin {
  constructor() {
    super();
    this.style.display = 'none';
    this.attachShadow({
      mode: 'open'
    });
    this.shadowRoot.innerHTML = '';
    if (!this.hasAttribute('name')) {
      throw new Error('required attribute "name" missing');
    }
    this.name = this.getAttribute('name');
  }
  connectedCallback() {
    this.shadowRoot.innerHTML = '';
  }
}
if (!customElements.get('fx-header')) {
  customElements.define('fx-header', FxHeader);
}

// We are getting sequences here (evaluateXPath is returning all items, as an array)
// So wrap them into something so FontoXPath also understands they are sequences, always.
const typedValueFactory = createTypedValueFactory('item()*');
class FxVariable extends ForeElementMixin {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.name = '';
    this.valueQuery = '';
    this.value = null;
    this.precedingVariables = [];
  }
  connectedCallback() {
    this.name = this.getAttribute('name');
    this.valueQuery = this.getAttribute('value');
  }
  refresh() {
    const inscope = getInScopeContext(this, this.valueQuery);
    const values = evaluateXPath(this.valueQuery, inscope, this, this.precedingVariables);
    this.value = typedValueFactory(values, domFacade);
  }

  /**
   * @param {Map<string, FxVariable>} inScopeVariables
   */
  setInScopeVariables(inScopeVariables) {
    if (inScopeVariables.has(this.name)) {
      console.error(`The variable ${this.name} is declared more than once`);
      Fore.dispatch(this, 'xforms-binding-error', {});
      return;
    }
    inScopeVariables.set(this.name, this);
    // Clone the preceding variables to make sure we are not going to get access to variables we
    // should not get access to
    this.inScopeVariables = new Map(inScopeVariables);
  }
}
if (!customElements.get('fx-var')) {
  customElements.define('fx-var', FxVariable);
}

class UIElement extends ForeElementMixin {
  constructor() {
    super();
  }
  connectedCallback() {
    super.connectedCallback();
    this.ondemand = this.hasAttribute('on-demand') ? true : false;
    this.wasOnDemandInitially = this.ondemand;
    if (this.ondemand) {
      this.addEventListener('show-control', () => {
        this.removeAttribute('on-demand');
      });
      this.addTrashIcon();
    }
  }
  activate() {
    console.log('UIElement.activate() called');
    this.removeAttribute('on-demand');
    this.style.display = '';
    if (this.isBound()) {
      this.refresh(true);
    }
    Fore.dispatch(this, 'show-group', {});
  }
  attributeChangedCallback(name, _oldValue, newValue) {
    if (name === 'on-demand') {
      this.ondemand = newValue !== null;
      if (!newValue && !this.wasOnDemandInitially) {
        this.removeTrashIcon();
      } else {
        this.wasOnDemandInitially = true;
        this.addTrashIcon();
      }
    }
  }
  static get observedAttributes() {
    return ['on-demand'];
  }
  addTrashIcon() {
    // Only show icon if explicitly marked by control-menu

    if (!this.closest('[show-icon]')) return;

    // const wrapper = this.shadowRoot.querySelector('.wrapper');
    // if (!wrapper || wrapper.querySelector('.trash')) return;
    const trash = this.querySelector('.trash');
    if (trash) return;
    const icon = document.createElement('span');
    // icon.innerHTML = '&#128465;'; // trash icon
    icon.innerHTML = `
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
       stroke="currentColor" stroke-width="2" stroke-linecap="round"
       stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
    <path d="M17.94 17.94C16.13 19.12 14.13 20 12 20C7 20 2.73 15.88 1 12C1.6 10.66 2.43 9.47 3.46 8.48M10.58 10.58C10.21 11.01 10 11.5 10 12C10 13.11 10.89 14 12 14C12.5 14 12.99 13.79 13.42 13.42M6.53 6.53C7.87 5.54 9.39 5 12 5C17 5 21.27 9.12 23 12C22.4 13.34 21.57 14.53 20.54 15.52M1 1L23 23"/>
  </svg>
`;
    icon.classList.add('trash');
    icon.setAttribute('title', 'Hide');
    // icon.setAttribute('part', 'trash');
    icon.style.cursor = 'pointer';
    icon.style.marginLeft = '0.5em';
    icon.addEventListener('click', e => {
      e.stopPropagation();
      this.setAttribute('on-demand', 'true');
      this.style.display = 'none';
      document.dispatchEvent(new CustomEvent('update-control-menu'));
      Fore.dispatch(this, 'hide-control', {});
    });
    this.appendChild(icon);
  }
  removeTrashIcon() {
    debugger;
    const icon = this.querySelector('.trash');
    if (icon) icon.remove();
  }
}
if (!customElements.get('ui-element')) {
  customElements.define('ui-element', UIElement);
}

function isDifferent(oldNodeValue, oldControlValue, newControlValue) {
  if (oldNodeValue === null) {
    return false;
  }
  /*
  if the oldControlValue is null we know the widget is used for the first time and is not considered
  a value change.
  */
  if (oldControlValue === null) return false;
  if (newControlValue && oldControlValue && newControlValue.nodeType && oldControlValue.nodeType) {
    return newControlValue.outerHTML !== oldControlValue.outerHTML;
  }
  if (oldControlValue === newControlValue) {
    return false;
  }
  return true;
}

/**
 * `AbstractControl` -
 * is a general base class for control elements.
 *
 */
class AbstractControl extends UIElement {
  constructor() {
    super();
    this.value = null;
    this.display = this.style.display;
    this.required = false;
    this.readonly = false;
    this.widget = null;
    this.visited = false;
    this.force = false;
    this.ondemand = false;
    // this.attachShadow({ mode: 'open' });
  }

  // eslint-disable-next-line class-methods-use-this
  getWidget() {
    throw new Error('You have to implement the method getWidget!');
  }

  /**
   * (re)apply all modelItem state properties to this control. model -> UI
   */
  async refresh(force) {
    if (force) this.force = true;

    // Save the old value of this control. this may be the stringified version, contrast to the node in `nodeset`
    const oldValue = this.value;

    // if (this.ondemand && !this.value) return;
    // console.log('### AbstractControl.refresh on : ', this);

    // if(this.repeated) return
    if (this.isNotBound()) return;

    // await this.updateComplete;
    // await this.getWidget();

    this.evalInContext();
    this.oldVal = this.nodeset ? this.nodeset : null;
    // console.log('oldVal',this.oldVal);

    // todo this if should be removed - see above
    if (this.isBound()) {
      // this.control = this.querySelector('#control');

      if (!this.nodeset) {
        const create = this.closest('[create]');
        if (create) {
          // ### check if parent element exists
          let attrName;
          let parentPath;
          let parentNode;
          if (this.ref.includes('/')) {
            parentPath = this.ref.substring(0, this.ref.indexOf('/'));
            const inscope = getInScopeContext(this.parentNode, this.ref);
            parentNode = evaluateXPathToFirstNode(parentPath, inscope, this);
            if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {
              if (this.ref.includes('@')) {
                attrName = this.ref.substring(this.ref.indexOf('/') + 2);
                parentNode.setAttribute(attrName, '');
              } else {
                Fore.dispatch(this, 'warn', {
                  message: '"create" is not implemented for elements'
                });
              }
            }
          } else {
            const inscope = getInScopeContext(this, this.ref);
            if (this.ref.includes('@')) {
              attrName = this.ref.substring(this.ref.indexOf('@') + 1);
              inscope.setAttribute(attrName, '');
            } else {
              Fore.dispatch(this, 'warn', {
                message: '"create" is not implemented for elements'
              });
              // inscope = getInScopeContext(this.parentNode, this.ref);
            }
          }
        } else {
          // ### this actually makes the control nonrelevant
          // todo: we should call a template function here to allow detachment of event-listeners and resetting eventual state
          // this.style.display = 'none';
          this.setAttribute('nonrelevant', '');
        }
        return;
      }
      this.modelItem = this.getModelItem();
      // console.log('refresh modelItem', this.modelItem);

      if (this.modelItem instanceof ModelItem) {
        // console.log('### XfAbstractControl.refresh modelItem : ', this.modelItem);

        if (this.hasAttribute('as') && this.getAttribute('as') === 'node') {
          // console.log('as', this.nodeset);
          // this.modelItem.value = this.nodeset;
          this.modelItem.node = this.nodeset;
          this.value = this.modelItem.node;
        } else {
          this.value = this.modelItem.value;
        }
        // console.log('newVal',this.value);

        // console.log('value of widget',this.value);

        /*
         * todo: find out on which foreign modelitems we might be dependant on when no binds are used.
         *
         * e.g. filter expr on 'ref' 'instance('countries')//country[@continent = instance('default')/continent]'
         *
         * the country node is dependant on instance('default')/continent here (foreign node).
         *
         * possible approach:
         * - pipe ref expression through DependencyNotifyingDomFacade to get referred nodes.
         * - lookup modelItems of referred nodes
         * - add ourselves to boundControls of foreign modelItem -> this control will then get refreshed when the foreign modelItem is changed.
         */

        // const touched = FxBind.getReferencesForRef(this.ref,Array.from(this.nodeset));
        // console.log('touched',touched);

        /*
        this is another case that highlights the fact that an init() function might make sense in general.
         */
        if (!this.modelItem.boundControls.includes(this)) {
          this.modelItem.boundControls.push(this);
        }

        // console.log('>>>>>>>> abstract refresh ', this.control);
        // this.control[this.valueProp] = this.value;
        await this.updateWidgetValue();
        this.handleModelItemProperties();

        // if(!this.closest('fx-fore').ready) return; // state change event do not fire during init phase (initial refresh)
        if (this.getOwnerForm().initialRun) {
          Fore.dispatch(this, 'init', {});
        }
        if (!this.getOwnerForm().ready) return; // state change event do not fire during init phase (initial refresh)
        // if oldVal is null we haven't received a concrete value yet

        if (!(this.localName === 'fx-control' || this.localName === 'fx-upload')) return;
        if (isDifferent(this.oldVal, oldValue, this.value)) {
          this.getModel();
          Fore.dispatch(this, 'value-changed', {
            path: this.modelItem.path,
            value: this.modelItem.value,
            oldvalue: oldValue,
            instanceId: this.modelItem.instanceId,
            foreId: this.getOwnerForm().id
          });
        }
      }
    }
  }
  refreshFromModelItem(modelItem) {}

  /**
   *
   * @returns {Promise<void>}
   */
  // eslint-disable-next-line class-methods-use-this
  async updateWidgetValue() {
    throw new Error('You have to implement the method updateWidgetValue!');
  }
  handleModelItemProperties() {
    // console.log('handleModelItemProperties',this.modelItem);
    this.handleRequired();
    this.handleReadonly();
    if (this.getOwnerForm().ready) {
      this.handleValid();
    }
    this.handleRelevant();
    // Relevance.handleRelevance(this);
    // todo: handleType()
  }

  _getForm() {
    return this.getModel().parentNode;
  }
  _dispatchEvent(event) {
    if (this.getOwnerForm().ready) {
      Fore.dispatch(this, event, {});
    }
  }

  // eslint-disable-next-line class-methods-use-this
  handleRequired() {
    // console.log('mip required', this.modelItem.required);
    this.widget = this.getWidget();
    const wasRequired = this.isRequired();
    if (!this.modelItem.required) {
      this.widget.removeAttribute('required');
      this.removeAttribute('required');
      if (wasRequired !== this.modelItem.required) {
        this._dispatchEvent('optional');
      }
      return;
    }

    // ### modelItem is required
    if (this.visited || this.force) {
      if (this.modelItem.value === '') {
        this.classList.add('isEmpty');
        this._toggleValid(false);
      } else {
        this.classList.remove('isEmpty');
        this._toggleValid(true);
      }
    }
    this.widget.setAttribute('required', '');
    this.setAttribute('required', '');
    if (wasRequired !== this.modelItem.required) {
      this._dispatchEvent('required');
    }

    /*
    if (this.isRequired() !== this.modelItem.required) {
      this._updateRequired();
    }
    */
  }

  _updateRequired() {
    if (this.modelItem.required) {
      // if (this.getOwnerForm().ready){
      if (this.visited || this.force) {
        // if (this.visited ) {
        //   if (this.widget.value === '') {
        if (this.modelItem.value === '') {
          this.classList.add('isEmpty');
          this._toggleValid(false);
        } else {
          this.classList.remove('isEmpty');
          this._toggleValid(true);
        }
      }
      this.widget.setAttribute('required', '');
      this.setAttribute('required', '');
      this._dispatchEvent('required');
    } else {
      this.widget.removeAttribute('required');
      this.removeAttribute('required');
      this._dispatchEvent('optional');
    }
  }
  _toggleValid(valid) {
    if (valid) {
      this.removeAttribute('invalid');
      this.setAttribute('valid', '');
    } else {
      this.removeAttribute('valid');
      this.setAttribute('invalid', '');
    }
  }
  handleReadonly() {
    // console.log('mip readonly', this.modelItem.isReadonly);
    if (this.isReadonly() !== this.modelItem.readonly) {
      if (this.modelItem.readonly) {
        this.widget.setAttribute('readonly', '');
        this.setAttribute('readonly', '');
        this._dispatchEvent('readonly');
      }
      if (!this.modelItem.readonly) {
        this.widget.removeAttribute('readonly');
        this.removeAttribute('readonly');
        this._dispatchEvent('readwrite');
      }
    }
  }

  // todo - review alert handling altogether. There could be potentially multiple ones in model
  handleValid() {
    // console.log('mip valid', this.modelItem.required);

    // console.log('late modelItem', mi);
    if (this.isValid() !== this.modelItem.constraint) {
      if (this.modelItem.constraint) {
        // if (alert) alert.style.display = 'none';
        this._dispatchEvent('valid');
        this.setAttribute('valid', '');
        this.removeAttribute('invalid');
      } else {
        this.setAttribute('invalid', '');
        this.removeAttribute('valid');
        // ### constraint is invalid - handle alerts
        /*
        if (alert) {
          alert.style.display = 'block';
        }
        */
        if (this.modelItem.alerts.length !== 0) {
          const controlAlert = this.querySelector('fx-alert');
          if (!controlAlert) {
            const {
              alerts
            } = this.modelItem;
            // console.log('alerts from bind: ', alerts);
            alerts.forEach(modelAlert => {
              const newAlert = document.createElement('fx-alert');
              // const newAlert = document.createElement('span');
              newAlert.innerHTML = modelAlert;
              this.appendChild(newAlert);
              // newAlert.style.display = 'block';
            });
          }
        }

        // this.dispatchEvent(new CustomEvent('invalid', {}));
        this._dispatchEvent('invalid');
      }
    }
  }
  handleRelevant() {
    // console.log('mip valid', this.modelItem.enabled);
    const item = this.modelItem.node;
    this.removeAttribute('relevant');
    this.removeAttribute('nonrelevant');
    if (Array.isArray(item) && item.length === 0) {
      this._dispatchEvent('nonrelevant');
      this.setAttribute('nonrelevant', '');
      // this.style.display = 'none';
      return;
    }
    if (this.isEnabled() !== this.modelItem.relevant) {
      if (this.modelItem.relevant) {
        this._dispatchEvent('relevant');
        // this._fadeIn(this, this.display);
        this.setAttribute('relevant', '');
        // this.style.display = this.display;
      } else {
        this._dispatchEvent('nonrelevant');
        // this._fadeOut(this);
        this.setAttribute('nonrelevant', '');
        // this.style.display = 'none';
      }
    }
  }

  isRequired() {
    return this.hasAttribute('required');
  }
  isValid() {
    return !this.hasAttribute('invalid');
  }
  isReadonly() {
    // const widget = this.querySelector('#widget');
    return this.hasAttribute('readonly');
  }
  isEnabled() {
    return !this.hasAttribute('nonrelevant');
  }

  // eslint-disable-next-line class-methods-use-this
  _fadeOut(el) {
    el.style.opacity = 1;
    (function fade() {
      // eslint-disable-next-line no-cond-assign
      if ((el.style.opacity -= 0.1) < 0) {
        el.style.display = 'none';
      } else {
        requestAnimationFrame(fade);
      }
    })();
  }

  // eslint-disable-next-line class-methods-use-this
  _fadeIn(el, display) {
    el.style.opacity = 0;
    el.style.display = display || 'block';
    (function fade() {
      let val = parseFloat(el.style.opacity);
      // eslint-disable-next-line no-cond-assign
      if (!((val += 0.1) > 1)) {
        el.style.opacity = val;
        requestAnimationFrame(fade);
      }
    })();
  }
}
if (!customElements.get('fx-abstract-control')) {
  window.customElements.define('fx-abstract-control', AbstractControl);
}

class FxAlert extends AbstractControl {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    const style = `
      :host {
        height: auto;
        font-size: 0.8em;
        font-weight: 400;
        color: red;
      }
    `;
    const html = `
      <slot></slot>
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${html}
    `;
  }
  getWidget() {
    return this;
  }
  async updateWidgetValue() {
    this.innerHTML = this.value;
  }
}
if (!customElements.get('fx-alert')) {
  customElements.define('fx-alert', FxAlert);
}

function leadingDebounce(caller, func, timeout = 300) {
  let timer;
  return (...args) => {
    if (!timer) {
      func.apply(caller, args);
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      timer = undefined;
      return null;
    }, timeout);
  };
}
function debounce(caller, func, timeout = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(caller, args);
    }, timeout);
  };
}

const WIDGETCLASS = 'widget';

/**
 * `fx-control`
 * a generic wrapper for controls
 *
 *
 *
 * @customElement
 * @demo demo/index.html
 */

/*
function debounce( func, timeout = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, timeout);
  };
}
*/
class FxControl extends AbstractControl {
  constructor() {
    super();
    this.inited = false;
    this.nodeset = null;
    this.attachShadow({
      mode: 'open'
    });
  }
  static get properties() {
    return {
      ...AbstractControl.properties,
      credentials: {
        type: String
      },
      initial: {
        type: Boolean
      },
      src: {
        type: String
      }
    };
  }
  _getValueOfWidget() {
    if (this.valueProp === 'selectedOptions') {
      // We have multiple! Just return that as space-separated for now
      return [...this.widget.selectedOptions].map(option => option.value).join(' ');
    }
    return this.widget[this.valueProp];
  }
  connectedCallback() {
    this.initial = this.hasAttribute('initial') ? this.getAttribute('initial') : null;
    this.src = this.hasAttribute('src') ? this.getAttribute('src') : null;
    this.loaded = false;
    this.initialNode = null;
    this.debounceDelay = this.hasAttribute('debounce') ? this.getAttribute('debounce') : null;
    this.updateEvent = this.hasAttribute('update-event') ? this.getAttribute('update-event') : 'blur';
    this.label = this.hasAttribute('label') ? this.getAttribute('label') : null;
    const style = `
      :host {
        display: flex;
        align-items: center;
        gap: 0.4em;
        position: relative;
      }
      .trash {
        position: absolute;
        right:0;
        top:0;
        cursor: pointer;
        color: #888;
        font-size: 0.65rem;
        align-self: center;
      }
      .trash:hover {
        color: red;
      }
      `;
    this.credentials = this.hasAttribute('credentials') ? this.getAttribute('credentials') : 'same-origin';
    if (!['same-origin', 'include', 'omit'].includes(this.credentials)) {
      console.error(`fx-submission: the value of credentials is not valid. Expected 'same-origin', 'include' or 'omit' but got '${this.credentials}'`, this);
    }
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${this.renderHTML(this.ref)}
        `;
    this.widget = this.getWidget();
    this.addEventListener('mousedown', e => {
      // ### prevent mousedown events on all control content that is not the widget or within the widget
      if (!Fore.isWidget(e.target) && !e.target?.classList.contains('fx-hint')) {
        e.preventDefault();
        // e.stopImmediatePropagation();
      }

      this.widget.focus();
    });
    const defaultValueProp = this.widget.hasAttribute('multiple') ? 'selectedOptions' : 'value';
    this.valueProp = this.hasAttribute('value-prop') ? this.getAttribute('value-prop') : defaultValueProp;

    // console.log('widget ', this.widget);
    let listenOn = this.widget; // default: usually listening on widget

    if (this.hasAttribute('listen-on')) {
      const q = this.getAttribute('listen-on');
      const target = this.querySelector(q);
      if (target) {
        listenOn = target;
      }
    }
    this.addEventListener('keyup', () => {
      FxModel.dataChanged = true;
    });

    // ### convenience marker event
    if (this.updateEvent === 'enter') {
      this.widget.addEventListener('keyup', event => {
        if (event.keyCode === 13) {
          // console.info('handling Event:', event.type, listenOn);
          // Cancel the default action, if needed
          event.preventDefault();
          this.setValue(this._getValueOfWidget());
        }
      });
      this.updateEvent = 'blur'; // needs to be registered too
    }

    if (this.debounceDelay) {
      listenOn.addEventListener(this.updateEvent, debounce(this, () => {
        // console.log('eventlistener ', this.updateEvent);
        // console.info('handling Event:', event.type, listenOn);
        this.setValue(this._getValueOfWidget());
      }, this.debounceDelay));
    } else {
      listenOn.addEventListener(this.updateEvent, event => {
        this.setValue(this._getValueOfWidget());
      });
      listenOn.addEventListener('blur', event => {
        this.setValue(this._getValueOfWidget());
      }, {
        once: true
      });
    }
    this.addEventListener('return', e => {
      const newNodes = e.detail.nodeset;
      e.stopPropagation();
      this._replaceNode(newNodes);
    });
    this.widget.addEventListener('focus', () => {
      /*
            if (!this.classList.contains('visited')) {
                this.classList.add('visited');
            }
      */
    });
    this.template = this.querySelector('template');
    this.boundInitialized = false;
    this.static = !!this.widget.hasAttribute('static');
    super.connectedCallback();
  }

  /**
   * activates a control that uses 'on-demand' attribute
   */
  activate() {
    console.log('fx-control.activate() called');
    this.removeAttribute('on-demand');
    this.style.display = '';
    this.refresh(true);
    Fore.dispatch(this, 'show-control', {});
    // Focus the widget after the control becomes visible
    requestAnimationFrame(() => {
      this.getWidget()?.focus();
    });
  }
  _debounce(func, timeout = 300) {
    let timer;
    return (...args) => {
      const context = this;
      clearTimeout(timer);
      timer = setTimeout(() => {
        func.apply(context, args);
      }, timeout);
    };
  }

  /**
   * updates the model with a new value by executing it's `<fx-setvalue>` action.
   *
   * In case the `as='node'` is given the bound node is replaced with the widgets' value with is
   * expected to be a node again.
   *
   * @param val the new value to be set
   */
  setValue(val) {
    const modelitem = this.getModelItem();
    if (this.getAttribute('class')) {
      this.classList.add('visited');
    } else {
      this.setAttribute('class', 'visited');
    }
    if (modelitem?.readonly) {
      console.warn('attempt to change readonly node', modelitem);
      return; // do nothing when modelItem is readonly
    }

    if (this.getAttribute('as') === 'node') {
      const replace = this.shadowRoot.getElementById('replace');
      const widgetValue = this.getWidget()[this.valueProp];
      replace.replace(this.nodeset, widgetValue);
      if (modelitem && widgetValue && widgetValue !== modelitem.value) {
        modelitem.value = widgetValue;
        FxModel.dataChanged = true;
        replace.actionPerformed();
      }
      return;
    }
    const setval = this.shadowRoot.getElementById('setvalue');
    setval.setValue(modelitem, val);
    if (this.modelItem instanceof ModelItem && !this.modelItem?.boundControls.includes(this)) {
      this.modelItem.boundControls.push(this);
    }
    setval.actionPerformed(false);
    // this.visited = true;
  }

  _replaceNode(node) {
    // Note: clone the node while replacing to prevent the instances to leak through
    if (node.nodeType === Node.ATTRIBUTE_NODE) {
      this.modelItem.node.nodeValue = node.nodeValue;
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      this.modelItem.node.replaceWith(node.cloneNode(true));
    } else if (node.nodeType === Node.TEXT_NODE) {
      this.modelItem.node.nodeValue = node.textContent;
    } else {
      Fore.dispatch(this, 'warn', {
        message: 'trying to replace a node that is neither an Attribute, Elemment or Text node'
      });
    }
    // this.getOwnerForm().refresh();
  }

  renderHTML(ref) {
    this.hasAttribute('on-demand');
    this.closest('[show-icon]');
    return `
            ${this.label ? `${this.label}` : ''}
              <slot></slot>
            ${this.hasAttribute('as') && this.getAttribute('as') === 'node' ? '<fx-replace id="replace" ref=".">' : `<fx-setvalue id="setvalue" ref="${ref}"></fx-setvalue>`}

        `;
  }

  /**
   * The widget is the actual control being used in the UI e.g. a native input control or any
   * other component that presents a control that can be interacted with.
   *
   * This function returns the widget by querying the children of this control for an element
   * with `class="widget"`. If that cannot be found it searches for an native `input` of any type.
   * If either cannot be found a `<input type="text">` is created.
   *
   * @returns {HTMLElement|*}
   */
  getWidget() {
    if (this.widget) return this.widget;
    let widget = this.querySelector(`.${WIDGETCLASS}`);
    if (!widget) {
      widget = this.querySelector('input');
      if (widget && !widget.classList.contains('widget')) {
        widget.classList.add('widget');
      }
    }
    if (!widget) {
      const input = document.createElement('input');
      input.classList.add(WIDGETCLASS);
      input.setAttribute('type', 'text');
      this.appendChild(input);
      return input;
    }
    return widget;
  }

  /**
   * updates the widget from the modelItem value. During refresh the a control
   * evaluates it's binding expression to determine the bound node. The bound node corresponds
   * to a modelItem which acts a the state object of a node. The modelItem determines the value
   * and the state of the node and set the `value` property of this class.
   *
   * @returns {Promise<void>}
   */
  async updateWidgetValue() {
    // this._getValueFromHtmlDom() = this.value;
    if (this.value) {
      // Fire and forget this: the value is set right away anyway
      this.setAttribute('has-value', '');
      Fore.dispatch(this, 'show-control');
    } else {
      this.removeAttribute('has-value');
    }
    let {
      widget
    } = this;
    if (!widget) {
      widget = this;
    }
    // ### value is bound to checkbox
    if (this.valueProp === 'checked') {
      if (this.value === 'true') {
        widget.checked = true;
      } else {
        widget.checked = false;
      }
      return;
    }

    // ### value is bound to radio
    if (this.widget.type === 'radio') {
      const matches = this.querySelector(`input[value=${this.value}]`);
      if (matches) {
        matches.checked = true;
      }
      return;
    }
    if (this.valueProp === 'selectedOptions') {
      const valueSet = new Set(this.value.split(' '));
      for (const option of [...this.widget.querySelectorAll('option')]) {
        if (valueSet.has(option.value)) {
          option.selected = true;
        } else {
          option.selected = false;
        }
      }
      return;
    }
    if (this.hasAttribute('as')) {
      const as = this.getAttribute('as');

      // ### when there's an `as=text` attribute serialize nodeset to prettified string
      if (as === 'text') {
        const serializer = new XMLSerializer();
        const pretty = Fore.prettifyXml(serializer.serializeToString(this.nodeset));
        widget.value = pretty;
      }
      if (as === 'node' && this.nodeset !== widget.value) {
        // const oldVal = this.nodeset.innerHTML;
        const oldVal = this.nodeset;
        if (widget.value) {
          if (oldVal !== this.widget.value) {
            // console.log('changed');
            widget.value = this.nodeset.cloneNode(true);
            return;
          }
        }
        widget.value = this.nodeset.cloneNode(true);
        // todo: should be more like below but that can cause infinite loop when controll trigger update event due to calling a setter for property
        // widget[this.valueProp] = this.nodeset.cloneNode(true);
        // console.log('passed value to widget', widget.value);
      }

      return;
    }

    // ### when there's a src Fore is used as widget and will be loaded from external file
    if (this.src && !this.loaded && this.modelItem.relevant) {
      // ### evaluate initial data if necessary

      if (this.initial) {
        this.initialNode = evaluateXPathToFirstNode(this.initial, this.nodeset, this);
        // console.log('initialNodes', this.initialNode);
      }

      // ### load the markup from src
      await this._loadForeFromSrc();
      this.loaded = true;

      // ### replace default instance of embedded Fore with initial nodes
      // const innerInstance = this.querySelector('fx-instance');
      // console.log('innerInstance',innerInstance);
      return;
    }
    if (widget.value !== this.value) {
      widget.value = this.value;
    }
  }

  /**
   * loads an external Fore from an HTML file given by `src` attribute and embed it as child of this control.
   *
   * Will look for the `<fx-fore>` element within the returned HTML file and return that element.
   *
   * If that cannot be found an error is dispatched.
   *
   * todo: dispatch link error
   * @private
   */
  async _loadForeFromSrc() {
    console.info(`%cControl ref="${this.ref}" is loading ${this.src}`, 'background:#64b5f6; color:white; padding:0.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
    try {
      const response = await fetch(this.src, {
        method: 'GET',
        credentials: this.credentials,
        mode: 'cors',
        headers: {
          'Content-Type': 'text/html'
        }
      });
      const responseContentType = response.headers.get('content-type').toLowerCase();
      // console.log('********** responseContentType *********', responseContentType);
      let data;
      if (responseContentType.startsWith('text/html')) {
        data = await response.text().then(result =>
        // console.log('xml ********', result);
        new DOMParser().parseFromString(result, 'text/html'));
      } else {
        data = 'done';
      }
      // const theFore = fxEvaluateXPathToFirstNode('//fx-fore', data.firstElementChild);
      const theFore = data.querySelector('fx-fore');
      const imported = document.importNode(theFore, true);
      imported.classList.add('widget'); // is the new widget
      imported.addEventListener('model-construct-done', e => {
        const defaultInst = imported.querySelector('fx-instance');
        if (this.initial) {
          const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');
          // Note: Clone the input to prevent the inner fore from editing the outer node
          // Also update the `initialNode` to make sure we have an up-to-date version
          this.initialNode = evaluateXPathToFirstNode(this.initial, this.nodeset, this);
          doc.firstElementChild.appendChild(this.initialNode.cloneNode(true));
          defaultInst.instanceData = doc;
        }
        imported.model = imported.querySelector('fx-model');
        imported.model.updateModel();
        imported.refresh(true);
      }, {
        once: true
      });
      const dummy = this.querySelector('input');
      /*
            todo: the mechanism to import constructed stylesheets as in fore-component is still missing here.
            There no way yet to specify CSS for a embedded fx-fore in shadowDOM.
             */
      if (this.hasAttribute('shadow')) {
        dummy.parentNode.removeChild(dummy);
        this.shadowRoot.appendChild(imported);
      } else if (!this.loaded) {
        dummy.replaceWith(imported);
      }
      if (!theFore) {
        Fore.dispatch('error', {
          detail: {
            message: `Fore element not found in '${this.src}'. Maybe wrapped within 'template' element?`
          }
        });
      }
      Fore.dispatch('loaded', {
        detail: {
          fore: theFore
        }
      });
    } catch (error) {
      // console.log('error', error);
      Fore.dispatch(this, 'error', {
        origin: this,
        message: `control couldn't be loaded from src '${this.src}'`,
        level: 'Error'
      });
    }
  }
  getTemplate() {
    return this.querySelector('template');
  }
  async refresh(force) {
    // console.log('fx-control refresh', this);
    super.refresh(force);
    // console.log('refresh template', this.template);
    // const {widget} = this;

    // ### if we find a ref on control we have a 'select' control of some kind
    const widget = this.getWidget();
    this._handleBoundWidget(widget);
    this._handleDataAttributeBinding();
    Fore.refreshChildren(this, force);
  }

  /**
   * handle non-Fore elements like 'select' and 'datalist' which have a 'data-ref' attribute
   * @private
   */
  _handleDataAttributeBinding() {
    const dataRefd = this.querySelector('[data-ref]');
    // Handle nested fx-controls
    if (dataRefd && dataRefd.closest('fx-control') === this) {
      this.boundList = dataRefd;
      dataRefd.getAttribute('data-ref');
      this._handleBoundWidget(dataRefd);
    }
  }

  /**
   * If the widget itself has a `ref` it binds to another nodeset to provide some
   * dynamic items to be created from a template usually. Examples are dynamic select option lists
   * or a set of checkboxes.
   *
   * @param widget the widget to handle
   * @private
   */
  _handleBoundWidget(widget) {
    if (this.boundInitialized && this.static) return;
    const ref = widget.hasAttribute('ref') ? widget.getAttribute('ref') : widget.getAttribute('data-ref');
    // if (widget && widget.hasAttribute('ref')) {
    if (widget && ref) {
      // ### eval nodeset for list control
      const inscope = getInScopeContext(this, ref);
      // const nodeset = evaluateXPathToNodes(ref, inscope, this);
      const nodeset = evaluateXPath(ref, inscope, this);

      // ### clear items
      const {
        children
      } = widget;
      Array.from(children).forEach(child => {
        if (child.nodeName.toLowerCase() !== 'template') {
          child.parentNode.removeChild(child);
        }
      });

      // ### bail out when nodeset is array and empty
      if (Array.isArray(nodeset) && nodeset.length === 0) return;

      // ### build the items
      const {
        template
      } = this;
      if (template) {
        // ### handle 'selection'  open and insert an empty option in that case
        if (this.widget.nodeName === 'SELECT' && this.widget.hasAttribute('selection') && this.widget.getAttribute('selection') === 'open') {
          const firstTemplateChild = this.template.firstElementChild;
          // todo: create the element which is used in the template  instead of 'option'
          const option = document.createElement('option');
          this.widget.insertBefore(option, firstTemplateChild);
        }
        if (nodeset.length !== 0) {
          // console.log('nodeset', nodeset);
          const fragment = document.createDocumentFragment();
          // console.time('offscreen');
          Array.from(nodeset).forEach(node => {
            // console.log('#### node', node);
            // ### initialize new entry
            const newEntry = this.createEntry();
            fragment.appendChild(newEntry);
            // ### set value
            this.updateEntry(newEntry, node);
          });
          this.template.parentNode.appendChild(fragment);
          // console.timeEnd('offscreen');
        } else {
          const newEntry = this.createEntry();
          this.template.parentNode.appendChild(newEntry);
          this.updateEntry(newEntry, nodeset);
        }
        this.boundInitialized = true;
      }
      if (this.valueProp === 'selectedOptions') {
        const valueSet = new Set(this.value.split(' '));
        const options = this.getWidget().querySelectorAll('option');
        for (const option of [...options]) {
          if (valueSet.has(option.value)) {
            option.selected = true;
          } else {
            option.selected = false;
          }
        }
      }
    }
  }
  updateEntry(newEntry, node) {
    // ### >>> todo: needs rework this code is heavily assuming a select control with 'value' attribute - not generic at all yet.

    const valueAttribute = newEntry.getAttribute('value');
    if (!valueAttribute) {
      // Fore.dispatch(this,'warn',{message:'no value attribute specified for template entry.'});
      return;
    }
    const valueExpr = valueAttribute;
    const cutted = valueExpr.substring(1, valueExpr.length - 1);
    const evaluated = evaluateXPathToString(cutted, node, newEntry);
    newEntry.setAttribute('value', evaluated);
    if (this.value === evaluated) {
      newEntry.setAttribute('selected', 'selected');
    }
    if (newEntry.hasAttribute('title')) {
      let titleExpr = newEntry.getAttribute('title');
      titleExpr = titleExpr.substring(1, titleExpr.length - 1);
      const evaluated = evaluateXPathToString(titleExpr, node, newEntry);
      newEntry.setAttribute('title', evaluated);
    }
    // ### set label
    const optionLabel = newEntry.textContent.trim();
    this.evalLabel(optionLabel, node, newEntry);
    //  ### <<< needs rework
  }

  evalLabel(optionLabel, node, newEntry) {
    const labelExpr = optionLabel.substring(1, optionLabel.length - 1);
    if (!labelExpr) return;
    const label = evaluateXPathToString(labelExpr, node, this);
    newEntry.textContent = label;
  }
  createEntry() {
    return this.template.content.firstElementChild.cloneNode(true);
    // const content = this.template.content.firstElementChild.cloneNode(true);
    // return content;
    // const newEntry = document.importNode(content, true);
    // this.template.parentNode.appendChild(newEntry);
    // return newEntry;
  }

  // eslint-disable-next-line class-methods-use-this
  _getValueAttribute(element) {
    let result;
    Array.from(element.attributes).forEach(attribute => {
      const attrVal = attribute.value;
      if (attrVal.indexOf('{') !== -1) {
        // console.log('avt found ', attribute);
        result = attribute;
      }
    });
    return result;
  }
}
if (!customElements.get('fx-control')) {
  window.customElements.define('fx-control', FxControl);
}

/**
 * `fx-container` -
 * is a general class for container elements.
 *
 */
class FxContainer extends UIElement {
  static get properties() {
    return {
      ...super.properties
      /*
      src: {
        type: String,
      },
      */
    };
  }

  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.src = this.hasAttribute('src') ? this.getAttribute('src') : null;
    const style = `
        :host {
            display: block;
        }
    `;
    const html = `
      <slot></slot>
    `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
    `;
    if (this.ref !== '') {
      this.getOwnerForm().registerLazyElement(this);
    }

    /*
    this.addEventListener('mousedown', e => {
       if(e.target === this){
        e.preventDefault();
        // e.stopImmediatePropagation();
      }
    } );
    */
  }

  /**
   * (re)apply all state properties to this control.
   */
  async refresh(force) {
    if (!force && this.hasAttribute('refresh-on-view')) return;
    // console.log('### FxContainer.refresh on : ', this);

    // if loading from 'src' needs to be done do it now
    /*
    if(this.src){
      await Fore.loadForeFromSrc(this,this.src,'fx-group')
          .then(foreElement =>{
            this.getOwnerForm().registerLazyElement(foreElement);
            foreElement.refresh();
          })
    }
    */
    if (this.isBound()) {
      this.evalInContext();
      this.modelItem = this.getModelItem();
      if (this.modelItem && !this.modelItem.boundControls.includes(this)) {
        this.modelItem.boundControls.push(this);
      }
      this.handleModelItemProperties();
    }

    // state change event do not fire during init phase (initial refresh)
    // if (this._getForm().ready) {
    //   this.handleModelItemProperties();
    // }
    // Fore.refreshChildren(this, force);
  }

  /**
   * relevance is processed for container controls only
   */
  handleModelItemProperties() {
    this.handleRelevant();
  }
  _getForm() {
    return this.getModel().parentNode;
  }
  handleRelevant() {
    // console.log('mip valid', this.modelItem.enabled);
    if (!this.modelItem) {
      // console.log('container is not relevant');
      this.removeAttribute('relevant', '');
      this.setAttribute('nonrelevant', '');
      this.dispatchEvent(new CustomEvent('disabled', {}));
      return;
    }
    if (this.isEnabled() !== this.modelItem.enabled) {
      if (this.modelItem.relevant) {
        // this.style.display = 'block';
        this.removeAttribute('nonrelevant', '');
        this.setAttribute('relevant', '');
        this.dispatchEvent(new CustomEvent('enabled', {}));
      } else {
        this.removeAttribute('relevant', '');
        this.setAttribute('nonrelevant', '');
        this.dispatchEvent(new CustomEvent('disabled', {}));
      }
    }
  }
  isReadonly() {
    if (this.hasAttribute('readonly')) {
      return true;
    }
    return false;
  }
  isEnabled() {
    if (this.style.display === 'none') {
      return false;
    }
    return true;
  }
}
if (!customElements.get('fx-container')) {
  window.customElements.define('fx-container', FxContainer);
}

/**
 * `fx-group`
 * a container allowing to switch between fx-case elements
 *
 *
 *  * todo: implement
 * @customElement
 */
class FxGroup extends FxContainer {
  static get properties() {
    return {
      ...super.properties,
      collapse: {
        type: Boolean,
        reflect: true
      }
    };
  }
  /*
            init(model){
                super.init(model);
                console.log(this, this.modelItem);
                 // this.initializeChildren(this);
            }
        */

  constructor() {
    super();
    this.collapse = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute('role', 'group');
  }
  render() {
    return `
      <slot></slot>
    `;
  }

  /**
   * overwrites Abstract Control.
   *
   * Groups only reacts to 'relevant' property.
   */
  handleModelItemProperties() {
    this.handleRelevant();
  }
  initializeChildren(node) {
    const children = Array.from(node.children);
    // console.log('_initializeChildren ', children);

    children.forEach(child => {
      // console.log('child ', child);

      if (Fore.isUiElement(child.nodeName)) {
        child.init(this.model);
      } else if (child.children.length !== 0) {
        const grantChildren = Array.from(child.children);
        grantChildren.forEach(grantChild => {
          this.initializeChildren(grantChild);
        });
      }
    });
    /*
                if(Fore.isUiElement(node.nodeName)){
                    const childElements = children.filter( action => Fore.isUiElement(action.nodeName));
                    console.log('children ', childElements);
                    console.group('init children');
                    if(childElements.length > 0){
                        childElements.forEach( child => {
                            console.log('action ', child);
                            child.init(this.model);
                        });
                    }
                }else if(node){
                    this._initializeChildren(node);
                }
        */

    console.groupEnd();
  }
  async refresh(force) {
    super.refresh(force);
    // Make the maybe filtered refresh an unconditional forced refresh: This fx-group changes the
    // context item
    Fore.refreshChildren(this, !!force);
  }

  // todo: this code should go
  /**
   * activates a control that uses 'on-demand' attribute
   */
  activate() {
    console.log('fx-group.activate() called');
    this.removeAttribute('on-demand');
    this.style.display = '';
    if (this.isBound()) {
      this.refresh(true);
    }
    Fore.dispatch(this, 'show-group', {});
  }
}
if (!customElements.get('fx-group')) {
  window.customElements.define('fx-group', FxGroup);
}

/**
 * @deprecated - can easily be substituted with template expression and usual <span>.
 */
class FxHint extends AbstractControl {
  static get styles() {
    return `
      :host {
        display: block;
        height: auto;
        font-size: 0.8em;
        font-weight: 400;
        font-style: italic;
      }
    `;
  }
  static get properties() {
    return {
      ...super.properties
    };
  }
  render() {
    return `
      <slot></slot>
    `;
  }

  /*
  isRequired() {
    return false;
  }
   isReadonly () {
    return true;
  }
  */

  /*
  handleRequired () {}
   handleReadonly () {
    // super.handleReadonly();
  }
  */
}

if (!customElements.get('fx-hint')) {
  customElements.define('fx-hint', FxHint);
}

// import {markdown} from '../drawdown.js';

/**
 * todo: review placing of value. should probably work with value attribute and not allow slotted content.
 */
class FxOutput extends AbstractControl {
  /*
  static get properties() {
    return {
      ...super.properties,
      valueAttr: {
        type: String,
      },
    };
  }
  */
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.valueAttr = this.hasAttribute('value') ? this.getAttribute('value') : null;
    // Outputs are always readonly!
    this.readonly = true;
  }
  connectedCallback() {
    const style = `
          :host {
            display: inline-block;
            max-width:100%;
          }
          #widget {
            display: inline-block;
          }
          .label{
            display: inline-block;
          }
          #value{
            max-width:100%;
          }
        `;
    const outputHtml = `
            <slot name="label"></slot>
            
            <span id="value">
                <slot name="default"></slot>
            </span>
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${outputHtml}
        `;
    // this.widget = this.shadowRoot.querySelector('#widget');
    // this.widget = this.getWidget();
    // console.log('widget ', this.widget);
    this.mediatype = this.hasAttribute('mediatype') ? this.getAttribute('mediatype') : null;

    /*
    this.addEventListener('slotchange', e => {
      console.log('slotchange ', e);
    });
    */
  }

  async refresh() {
    // Resolve the ref first. The ref will set the `nodeset` which is important for the 'context'
    if (this.ref) {
      await super.refresh();
    }

    // ### 2. Eval the value
    if (this.valueAttr) {
      this.value = this.getValue();
      await this.updateWidgetValue();
    }
  }
  getValue() {
    // return 'foobar';
    try {
      const inscopeContext = getInScopeContext(this, this.valueAttr);
      if (this.hasAttribute('html')) {
        return evaluateXPath(this.valueAttr, inscopeContext, this)[0];
      }
      return evaluateXPathToStrings(this.valueAttr, inscopeContext, this)[0];
    } catch (error) {
      console.error(error);
      Fore.dispatch(this, 'error', {
        message: error
      });
    }
    return null;
  }
  getWidget() {
    const valueWrapper = this.shadowRoot.getElementById('value');
    return valueWrapper;
  }
  handleReadonly() {
    // An output is always read-only
    this.setAttribute('readonly', 'readonly');
  }
  async updateWidgetValue() {
    // console.log('updateWidgetValue');
    const valueWrapper = this.shadowRoot.getElementById('value');
    valueWrapper.innerHTML = '';

    // if (this.mediatype === 'markdown') {
    //   const md = markdown(this.nodeset);
    //   this.innerHtml = md;
    // }

    if (this.mediatype === 'html') {
      if (this.modelItem.node) {
        this.shadowRoot.querySelector('#default');
        const {
          node
        } = this.modelItem;
        if (node.nodeType) {
          valueWrapper.append(node);
          // this.appendChild(node);
          return;
        }

        // ### try to parse as string
        const tmpDoc = new DOMParser().parseFromString(node, 'text/html');
        const theNode = tmpDoc.body.childNodes;
        // console.log('actual node', theNode)
        Array.from(theNode).forEach(n => {
          valueWrapper.append(n);
        });
        // valueWrapper.append(theNode);

        // valueWrapper.innerHTML=node;
        /*
        if (node.nodeType) {
          this.appendChild(node);
          return;
        }
        Object.entries(node).map(obj => {
          // valueWrapper.appendChild(obj[1]);
          this.appendChild(obj[1]);
        });
        */
        /*
        Object.entries(node).map(obj => {
          // valueWrapper.appendChild(obj[1]);
          this.appendChild(obj[1]);
        });
        */

        return;
      }

      // this.innerHTML = this.value.outerHTML;
      // valueWrapper.innerHTML = this.value.outerHTML;

      // this.shadowRoot.appendChild(this.value);
      return;
    }
    if (this.mediatype === 'image') {
      const img = document.createElement('img');
      img.setAttribute('src', this.value);
      // Reset the output before adding the image
      this.innerHTML = '';
      valueWrapper.appendChild(img);
      return;
    }
    valueWrapper.innerHTML = this.value;
  }
  isReadonly() {
    return true;
  }
}
if (!customElements.get('fx-output')) {
  customElements.define('fx-output', FxOutput);
}

/**
 * `fx-repeat`
 * an xformish form for eXist-db
 *
 * @customElement
 * @demo demo/index.html
 *
 * @extends {ForeElementMixin}
 */
class FxRepeatitem extends withDraggability(ForeElementMixin) {
  static get properties() {
    return {
      ...super.properties,
      inited: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.inited = false;
    this.addEventListener('click', this._dispatchIndexChange);
    // this.addEventListener('focusin', this._handleFocus);
    this.addEventListener('focusin', this._dispatchIndexChange);
    this.attachShadow({
      mode: 'open',
      delegatesFocus: true
    });
    this.dropTarget = null;
  }
  connectedCallback() {
    super.connectedCallback();
    this.display = this.style.display;
    const html = `
           <slot></slot>
        `;
    this.shadowRoot.innerHTML = `
            ${html}
        `;
    this.getOwnerForm().registerLazyElement(this);
    this.ref = `${this.parentNode.ref}`;
    this.tabindex = 0;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener('click', this._dispatchIndexChange);
    this.removeEventListener('focusin', this._handleFocus);
  }
  init() {
    // console.log('repeatitem init model ', this.nodeset);
    // this._initializeChildren(this);
    this.inited = true;
  }

  /*
      getModelItem() {
      super.getModelItem();
      // console.log('modelItem in repeatitem ', this.getModelItem()[this.index]);
      return this.getModelItem()[this.index];
      }
    */

  _dispatchIndexChange() {
    /**
     * @type {import('./fx-repeat.js').FxRepeat}
     */
    const repeat = this.parentNode;
    if (repeat.index === this.index) {
      // The index did not really change if it did not change :wink:
      return;
    }
    this.dispatchEvent(new CustomEvent('item-changed', {
      composed: false,
      bubbles: true,
      detail: {
        item: this,
        index: this.index
      }
    }));
  }
  refresh(force) {
    this.modelItem = this.getModelItem();
    // ### register ourselves as boundControl
    if (!this.modelItem.boundControls.includes(this)) {
      this.modelItem.boundControls.push(this);
      if (this.modelItem && !this.modelItem.relevant) {
        this.removeAttribute('relevant');
        this.setAttribute('nonrelevant', '');
      } else {
        this.removeAttribute('nonrelevant');
        this.setAttribute('relevant', '');
      }
    }
    // Always recurse for these refreshes, especially when forced
    Fore.refreshChildren(this, force);
  }
}
if (!customElements.get('fx-repeatitem')) {
  window.customElements.define('fx-repeatitem', FxRepeatitem);
}

// import {DependencyNotifyingDomFacade} from '../DependencyNotifyingDomFacade';

/**
 * `fx-repeat`
 *
 * Repeats its template for each node in its' bound nodeset.
 *
 * Template is a standard HTML `<template>` element. Once instanciated the template
 * is moved to the shadowDOM of the repeat for safe re-use.
 *
 *
 *
 * @customElement
 * @demo demo/todo.html
 *
 * todo: it should be seriously be considered to extend FxContainer instead but needs refactoring first.
 * @extends {ForeElementMixin}
 */
class FxRepeat extends withDraggability(UIElement) {
  static get properties() {
    return {
      ...super.properties,
      index: {
        type: Number
      },
      template: {
        type: Object
      },
      focusOnCreate: {
        type: String
      },
      initDone: {
        type: Boolean
      },
      repeatIndex: {
        type: Number
      },
      nodeset: {
        type: Array
      }
    };
  }
  constructor() {
    super();
    this.ref = '';
    this.dataTemplate = [];
    this.isDraggable = null;
    this.dropTarget = null;
    this.focusOnCreate = '';
    this.initDone = false;
    this.repeatIndex = 1;
    this.nodeset = [];
    this.inited = false;
    this.index = 1;
    this.repeatSize = 0;
    this.attachShadow({
      mode: 'open',
      delegatesFocus: true
    });
  }
  get repeatSize() {
    return this.querySelectorAll(':scope > fx-repeatitem').length;
  }
  set repeatSize(size) {
    this.size = size;
  }
  setIndex(index) {
    // console.log('new repeat index ', index);
    this.index = index;
    const rItems = this.querySelectorAll(':scope > fx-repeatitem');
    this.applyIndex(rItems[this.index - 1]);
    this.getOwnerForm().refresh({
      reason: 'index-function',
      elementLocalnamesWithChanges: []
    });
  }
  applyIndex(repeatItem) {
    this._removeIndexMarker();
    if (repeatItem) {
      repeatItem.setAttribute('repeat-index', '');
    }
  }
  get index() {
    return parseInt(this.getAttribute('index'), 10);
  }
  set index(idx) {
    this.setAttribute('index', idx);
  }
  _getRef() {
    return this.getAttribute('ref');
  }
  connectedCallback() {
    super.connectedCallback();
    // console.log('connectedCallback',this);
    // this.display = window.getComputedStyle(this, null).getPropertyValue("display");
    this.ref = this.getAttribute('ref');
    this.dependencies.addXPath(this.ref);
    // this.ref = this._getRef();
    // console.log('### fx-repeat connected ', this.id);
    this.addEventListener('item-changed', e => {
      const {
        item
      } = e.detail;
      const idx = Array.from(this.children).indexOf(item);
      // Warning: index is one-based
      this.setIndex(idx + 1);
    });
    // todo: review - this is just used by append action - event consolidation ?
    document.addEventListener('index-changed', e => {
      e.stopPropagation();
      if (!e.target === this) return;
      // const { item } = e.detail;
      // const idx = Array.from(this.children).indexOf(item);
      const {
        index
      } = e.detail;
      this.index = parseInt(index, 10);
      this.applyIndex(this.children[index - 1]);
    });
    /*
        document.addEventListener('insert', e => {
          const nodes = e.detail.insertedNodes;
          this.index = e.detail.position;
          console.log('insert catched', nodes, this.index);
        });
    */

    // if (this.getOwnerForm().lazyRefresh) {
    this.mutationObserver = new MutationObserver(mutations => {
      // console.log('mutations', mutations);

      if (mutations[0].type === 'childList') {
        const added = mutations[0].addedNodes[0];
        if (added) {
          const instance = XPathUtil.resolveInstance(this, this.ref);
          const path = XPathUtil.getPath(added, instance);
          // console.log('path mutated', path);
          // this.dispatch('path-mutated',{'path':path,'nodeset':this.nodeset,'index': this.index});
          // this.index = index;
          // const prev = mutations[0].previousSibling.previousElementSibling;
          // const index = prev.index();
          // this.applyIndex(this.index -1);

          Fore.dispatch(this, 'path-mutated', {
            path,
            index: this.index
          });
        }
      }
    });
    // }
    this.getOwnerForm().registerLazyElement(this);
    const style = `
      :host{
      }
       .fade-out-bottom {
          -webkit-animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
          animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
      }
      .fade-out-bottom {
          -webkit-animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
          animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
      }
   `;
    const html = `
          <slot name="header"></slot>
          <slot></slot>
          <slot name="footer"></slot>
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;

    // this.init();
  }

  _createNewRepeatItem() {
    const newItem = document.createElement('fx-repeatitem');
    if (this.isDraggable) {
      newItem.setAttribute('draggable', 'true');
      newItem.setAttribute('tabindex', 0);
    }
    const clone = this._clone();
    newItem.appendChild(clone);
    return newItem;
  }
  init() {
    // ### there must be a single 'template' child
    // console.log('##### repeat init ', this.id);
    // if(!this.inited) this.init();
    // does not use this.evalInContext as it is expecting a nodeset instead of single node
    this._evalNodeset();
    // console.log('##### ',this.id, this.nodeset);

    this._initTemplate();
    this._initRepeatItems();
    this.setAttribute('index', this.index);
    this.inited = true;
  }

  /**
   * repeat has no own modelItems
   * @private
   */
  _evalNodeset() {
    // const inscope = this.getInScopeContext();
    const inscope = getInScopeContext(this.getAttributeNode('ref') || this, this.ref);
    // console.log('##### inscope ', inscope);
    // console.log('##### ref ', this.ref);
    // now we got a nodeset and attach MutationObserver to it

    if (this.mutationObserver && inscope.nodeName) {
      this.mutationObserver.observe(inscope, {
        childList: true,
        subtree: true
      });
    }

    /*
              this.touchedPaths = new Set();
              const instance = XPathUtil.resolveInstance(this, this.ref);
              const depTrackDomfacade = new DependencyNotifyingDomFacade((node) => {
                  this.touchedPaths.add(XPathUtil.getPath(node, instance));
              });
              const rawNodeset = evaluateXPath(this.ref, inscope, this, {}, {}, depTrackDomfacade );
        */
    const rawNodeset = evaluateXPath(this.ref, inscope, this);

    // console.log('Touched!', this.ref, [...this.touchedPaths].join(', '));
    if (rawNodeset.length === 1 && Array.isArray(rawNodeset[0])) {
      // This XPath likely returned an XPath array. Just collapse to that array
      this.nodeset = rawNodeset[0];
      return;
    }
    this.nodeset = rawNodeset;
  }
  async refresh(force) {
    // console.group('fx-repeat.refresh on', this.id);

    if (!this.inited) this.init();
    // console.time('repeat-refresh', this);
    this._evalNodeset();

    // ### register ourselves as boundControl
    /*
            const modelItem = this.getModelItem();
            if (!modelItem.boundControls.includes(this)) {
              modelItem.boundControls.push(this);
            }
        */
    // console.log('repeat refresh nodeset ', this.nodeset);
    // console.log('repeatCount', this.repeatCount);

    const repeatItems = this.querySelectorAll(':scope > fx-repeatitem');
    const repeatItemCount = repeatItems.length;
    let nodeCount = 1;
    if (Array.isArray(this.nodeset)) {
      nodeCount = this.nodeset.length;
    }

    // const contextSize = this.nodeset.length;
    const contextSize = nodeCount;
    // todo: review - cant the context really never be smaller than the repeat count?
    // todo: this code can be deprecated probably but check first
    if (contextSize < repeatItemCount) {
      for (let position = repeatItemCount; position > contextSize; position -= 1) {
        // remove repeatitem
        const itemToRemove = repeatItems[position - 1];
        itemToRemove.parentNode.removeChild(itemToRemove);
        this.getOwnerForm().unRegisterLazyElement(itemToRemove);
        // this._fadeOut(itemToRemove);
        // Fore.fadeOutElement(itemToRemove)
      }
    }

    if (contextSize > repeatItemCount) {
      for (let position = repeatItemCount + 1; position <= contextSize; position += 1) {
        // add new repeatitem

        const newItem = this._createNewRepeatItem();
        this.appendChild(newItem);
        this._initVariables(newItem);
        newItem.nodeset = this.nodeset[position - 1];
        newItem.index = position;
        if (this.getOwnerForm().createNodes) {
          this.getOwnerForm().initData(newItem);
        }

        // Tell the owner form we might have new template expressions here
        this.getOwnerForm().scanForNewTemplateExpressionsNextRefresh();
      }
    }

    // ### update nodeset of repeatitems
    for (let position = 0; position < repeatItemCount; position += 1) {
      const item = repeatItems[position];
      this.getOwnerForm().registerLazyElement(item);
      if (item.nodeset !== this.nodeset[position]) {
        item.nodeset = this.nodeset[position];
      }
    }

    // Fore.refreshChildren(clone,true);
    const fore = this.getOwnerForm();
    if (!fore.lazyRefresh || force) {
      // Turn the possibly conditional force refresh into a forced one: we changed our children
      Fore.refreshChildren(this, force);
    }
    // this.style.display = 'block';
    // this.style.display = this.display;
    this.setIndex(this.index);
    // console.timeEnd('repeat-refresh');

    // this.replaceWith(clone);

    // this.repeatCount = contextSize;
    // console.log('repeatCount', this.repeatCount);
  }

  // eslint-disable-next-line class-methods-use-this
  _fadeOut(el) {
    el.style.opacity = 1;
    (function fade() {
      // eslint-disable-next-line no-cond-assign
      if ((el.style.opacity -= 0.1) < 0) {
        el.style.display = 'none';
      } else {
        requestAnimationFrame(fade);
      }
    })();
  }

  // eslint-disable-next-line class-methods-use-this
  _fadeIn(el) {
    if (!el) return;
    el.style.opacity = 0;
    el.style.display = this.display;
    (function fade() {
      // setTimeout(() => {
      let val = parseFloat(el.style.opacity);
      // eslint-disable-next-line no-cond-assign
      if (!((val += 0.1) > 1)) {
        el.style.opacity = val;
        requestAnimationFrame(fade);
      }
      // }, 40);
    })();
  }

  _initTemplate() {
    this.template = this.querySelector('template');
    // console.log('### init template for repeat ', this.id, this.template);
    // todo: this.dropTarget not needed?
    this.dropTarget = this.template.getAttribute('drop-target');
    this.isDraggable = this.template.hasAttribute('draggable') ? this.template.getAttribute('draggable') : null;
    if (this.template === null) {
      // todo: catch this on form element
      this.dispatchEvent(new CustomEvent('no-template-error', {
        composed: true,
        bubbles: true,
        detail: {
          message: `no template found for repeat:${this.id}`
        }
      }));
    }
    this.shadowRoot.appendChild(this.template);
  }
  _initRepeatItems() {
    this.nodeset.forEach((item, index) => {
      const repeatItem = this._createNewRepeatItem();
      repeatItem.nodeset = this.nodeset[index];
      repeatItem.index = index + 1; // 1-based index

      this.appendChild(repeatItem);
      if (this.getOwnerForm().createNodes) {
        this.getOwnerForm().initData(repeatItem);
        const repeatItemClone = repeatItem.nodeset.cloneNode(true);
        this.clearTextValues(repeatItemClone);

        // this.createdNodeset = repeatItem.nodeset.cloneNode(true);
        this.createdNodeset = repeatItemClone;
        // console.log('createdNodeset', this.createdNodeset)
      }

      if (repeatItem.index === 1) {
        this.applyIndex(repeatItem);
      }
      // console.log('*********repeat item created', repeatItem.nodeset)
      Fore.dispatch(this, 'item-created', {
        nodeset: repeatItem.nodeset,
        pos: index + 1
      });
      this._initVariables(repeatItem);
    });
  }
  clearTextValues(node) {
    if (!node) return;

    // Clear text node content
    if (node.nodeType === Node.TEXT_NODE) {
      node.nodeValue = '';
    }

    // Clear all attribute values
    if (node.nodeType === Node.ELEMENT_NODE) {
      for (const attr of Array.from(node.attributes)) {
        attr.value = ''; // Clear attribute value
      }
    }

    // Recursively clear child nodes
    for (const child of node.childNodes) {
      this.clearTextValues(child);
    }
  }
  _initVariables(newRepeatItem) {
    const inScopeVariables = new Map(this.inScopeVariables);
    newRepeatItem.setInScopeVariables(inScopeVariables);
    (function registerVariables(node) {
      for (const child of node.children) {
        if ('setInScopeVariables' in child) {
          child.setInScopeVariables(inScopeVariables);
        }
        registerVariables(child);
      }
    })(newRepeatItem);
  }
  _clone() {
    // const content = this.template.content.cloneNode(true);
    this.template = this.shadowRoot.querySelector('template');
    const content = this.template.content.cloneNode(true);
    return document.importNode(content, true);
  }
  _removeIndexMarker() {
    Array.from(this.children).forEach(item => {
      item.removeAttribute('repeat-index');
    });
  }
  setInScopeVariables(inScopeVariables) {
    // Repeats are interesting: the variables should be scoped per repeat item, they should not be
    // able to see the variables in adjacent repeat items!
    this.inScopeVariables = new Map(inScopeVariables);
  }
}
if (!customElements.get('fx-repeat')) {
  window.customElements.define('fx-repeat', FxRepeat);
}

/**
 * `fx-switch`
 * a container allowing to switch between fx-case elements
 *
 * @customElement
 */
class FxSwitch extends FxContainer {
  /*
      constructor() {
        super();
        // this.attachShadow({ mode: 'open' });
      }
    */

  constructor() {
    super();
    this.formerCase = {};
    this.selectedCase = null;
    this.cases = null;
    this.visitedResetted = false;
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    const style = `
       :host ::slotted(fx-case.selected-case){
        display: block;
    }
    `;
    const html = `
       <slot></slot>
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${html}
    `;
    this.cases = [];
    this.formerCase = null;
    this.selectedCase = null;
  }
  async refresh(force) {
    super.refresh(force);
    // console.log('refresh on switch ');
    if (this.cases.length === 0) {
      this.cases = Array.from(this.querySelectorAll(':scope > fx-case'));
    }
    if (this.isBound()) {
      this._handleBoundSwitch();
    }
    if (!this.selectedCase) {
      this.selectedCase = this.cases[0]; // first is always default
      this.toggle(this.selectedCase);
    }
    Fore.refreshChildren(this.selectedCase, force);
  }
  _dispatchEvents() {
    if (this.selectedCase === this.formerCase) return;
    if (this.formerCase && this.formerCase !== this.selectedCase) {
      Fore.dispatch(this.formerCase, 'deselect', {});
    }
    if (this.selectedCase.classList.contains('selected-case')) {
      Fore.dispatch(this.selectedCase, 'select', {});
    }
  }
  _resetVisited() {
    if (this.visitedResetted) return;
    const visited = this.selectedCase.querySelectorAll('.visited');
    Array.from(visited).forEach(v => {
      v.classList.remove('visited');
    });
    this.visitedResetted = true;
  }

  /**
   * handles switches being bound. If modelItem value matches the 'name' attribute that case will be toggled.
   * @private
   */
  _handleBoundSwitch() {
    Array.from(this.cases).forEach(caseElem => {
      const name = caseElem.getAttribute('name');
      if (name === this.modelItem?.value) {
        this.toggle(caseElem);
      }
    });
  }

  /**
   * Replace an old case with a new case element.
   *
   * @param {import('./fx-case.js').FxCase} oldCase
   * @param {import('./fx-case.js').FxCase} newCase
   */
  async replaceCase(oldCase, newCase) {
    this.cases.splice(this.cases.indexOf(oldCase), 1, newCase);
    if (oldCase === this.selectedCase) {
      this.selectedCase = newCase;
      this.formerCase = newCase;
      newCase.classList.add('selected-case');
      newCase.classList.remove('deselected-case');
      newCase.inert = false;
      // Tell the owner form we might have new template expressions here
      this.getOwnerForm().scanForNewTemplateExpressionsNextRefresh();
    } else {
      newCase.classList.add('deselected-case');
      newCase.classList.remove('selected-case');
      newCase.inert = true;
    }
  }

  /**
   * Activates a fx-case element by switching CSS classes.
   * Dispatches 'select' and 'deselect' events as appropriate.
   *
   * @param {import('./fx-case.js').FxCase} caseElement the fx-case element to activate
   */
  toggle(caseElement) {
    this.selectedCase = caseElement;
    Array.from(this.cases).forEach(c => {
      if (c === this.selectedCase) {
        c.classList.remove('deselected-case');
        c.classList.add('selected-case');
        c.inert = false;
      } else {
        c.classList.remove('selected-case');
        c.classList.add('deselected-case');
        c.inert = true;
        this._resetVisited();
      }
    });
    if (this.selectedCase !== caseElement) {
      this.selectedCase = caseElement;
    }
    this._dispatchEvents();
    this.formerCase = this.selectedCase;

    // Tell the owner form we might have new template expressions here
    this.getOwnerForm().scanForNewTemplateExpressionsNextRefresh();
    this.getOwnerForm().getModel().updateModel();
  }
}
if (!customElements.get('fx-switch')) {
  window.customElements.define('fx-switch', FxSwitch);
}

class FxTrigger extends AbstractControl {
  connectedCallback() {
    this.attachShadow({
      mode: 'open'
    });
    this.ref = this.hasAttribute('ref') ? this.getAttribute('ref') : null;
    this.debounceDelay = this.hasAttribute('debounce') ? this.getAttribute('debounce') : null;
    const style = `
          :host {
            cursor:pointer;
          }
        `;
    this.shadowRoot.innerHTML = `
                <style>
                    ${style}
                </style>
                ${this.renderHTML()}
        `;
    const slot = this.shadowRoot.querySelector('slot');
    slot.addEventListener('slotchange', () => {
      const elements = slot.assignedElements({
        flatten: true
      });
      if (!elements[0].getAttribute('tabindex')) {
        elements[0].setAttribute('tabindex', '0');
      }
      if (elements[0].nodeName !== 'BUTTON') {
        elements[0].setAttribute('role', 'button');
      }
      const element = elements[0];
      this.addEventListener('mousedown', e => {
        console.log('target', e.target.nodeName);
        e.target.focus();
      });
      if (this.debounceDelay) {
        this.addEventListener('click', leadingDebounce(this, e => {
          this.performActions(e);
        }, this.debounceDelay));
      } else {
        element.addEventListener('click', e => this.performActions(e));
      }
      this.widget = element;
      // # terrible hack but browser behaves strange - seems to fire a 'click' for a button when it receives a
      // # 'Space' or 'Enter' key
      if (element.nodeName !== 'BUTTON') {
        element.addEventListener('keypress', e => {
          if (e.code === 'Space' || e.code === 'Enter') {
            this.performActions(e);
          }
        });
      }
    });
  }

  // eslint-disable-next-line class-methods-use-this
  renderHTML() {
    return `
            <slot></slot>
    `;
  }
  getWidget() {
    return this.widget;
  }
  async updateWidgetValue() {
    // console.log('trigger update', this);
    return null;
  }
  handleReadonly() {
    super.handleReadonly();
    // ### add disabled attribute in case we're readonly. This is special behavior of fx-trigger
    if (this.widget.hasAttribute('readonly')) {
      this.widget.setAttribute('disabled', 'disabled');
    } else {
      this.widget.removeAttribute('disabled');
    }
  }
  async performActions(e) {
    // todo: support readonly for trigger not executing the action
    const repeatedItem = this.closest('fx-repeatitem');
    if (repeatedItem) {
      // console.log('repeated click');
      repeatedItem.click();
    }

    // Update all child variables, but only once
    this.querySelectorAll('fx-var').forEach(variableElement => variableElement.refresh());
    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.children[i];
      if (typeof child.execute === 'function') {
        if (e) {
          // We are handling the event. Stop it from going further
          e.preventDefault();
          e.stopPropagation();
          if (e.type && child.event && e.type !== child.event) return;
        }
        // eslint-disable-next-line no-await-in-loop
        await child.execute(e);
        // child.execute(e);
      }
    }
  }

  async refresh() {
    super.refresh();
  }
}
if (!customElements.get('fx-trigger')) {
  customElements.define('fx-trigger', FxTrigger);
}

// import { foreElementMixin } from '../ForeElementMixin';

/**
 * `fx-case`
 * a container allowing to switch between fx-case elements
 *
 *  * todo: implement
 * @customElement
 */
class FxCase extends FxContainer {
  static get properties() {
    return {
      ...super.properties,
      label: {
        type: String
      },
      name: {
        type: String
      },
      selected: {
        type: String
      },
      selector: {
        type: String
      },
      src: {
        type: String
      }
    };
  }
  connectedCallback() {
    if (this.hasAttribute('label')) {
      this.label = this.getAttribute('label');
    }
    if (this.hasAttribute('name')) {
      this.name = this.getAttribute('name');
    }
    if (this.hasAttribute('selected')) {
      this.selected = this.getAttribute('selected');
    }
    this.selector = this.hasAttribute('selector') ? this.getAttribute('selector') : 'fx-case';
    if (this.hasAttribute('src')) {
      this.src = this.getAttribute('src');
    }
    const style = `
            :host {
                visibility: none;
            }
        `;
    const html = `
           ${this.label ? `<span>${this.label}</span>` : ''}
           <slot></slot>
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;
    this.addEventListener('select', async () => {
      const ownerForm = this.getOwnerForm();
      if (this.src) {
        // We will replace the node. So this node will be detached after these async function
        // calls. Save all important state first.
        const {
          parentNode
        } = this;
        const replacement = await this._loadFromSrc();
        if (!replacement) {
          Fore.dispatch(this, 'error', {
            detail: {
              message: `HTML page couldn't be loaded`
            }
          });
          return;
        }
        await parentNode.replaceCase(this, replacement);
      }
      const model = ownerForm.getModel();
      model.updateModel();
      ownerForm.refresh(true);
    });
  }

  /**
   * loads a Fore from an URL given by `src`.
   *
   * Will extract the `fx-fore` element from that target file and use and replace current `fx-fore` element with the loaded one.
   * @private
   */
  async _loadFromSrc() {
    // console.log('########## loading Fore from ', this.src, '##########');
    return Fore.loadForeFromSrc(this, this.src, this.selector);
  }
}
if (!customElements.get('fx-case')) {
  window.customElements.define('fx-case', FxCase);
}

/**
 * lists out all live instances in html 'details' and 'summary' elements.
 */
class FxInspector extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    const style = `
          :host {
            position:absolute;
            display: block;
            width:var(--inspector-handle-width);
            background:var(--inspector-bg);
            top:0;
            right:0;
            bottom:0;
            height: 100%;
            background: var(--inspector-bg);
            color: white;
            /*max-height: 33%;*/
            overflow: scroll;
            transition:width 0.3s ease;
            z-index:100;
          }
          :host([open]){
            width: 30%;
          }
          details{
            margin:1rem;
          }
          .main{
            padding-left:var(--inspector-handle-width);
            color:var(--inspector-color);
            overflow:scroll;
            height:100%;
          }
          pre{
            background:var(--inspector-pre-bg);
            color:var(--inspector-color);
            overflow:scroll;
            padding:0.2rem;
          }
          .handle{
            display:block;
            height:100%;
            width:var(--inspector-handle-width);
            background:var(--inspector-handle-bg);
            opacity:0.7;
            position:absolute;
            left:0;
            color:white;
            cursor:pointer;
          }
          .handle:hover{
            opacity:1;
          }
          .handle::before{
            content: 'Data Inspector';
            white-space: nowrap;
            transform: rotate(-90deg);
            display: inline-block;
            position: absolute;
            left: -85px;
            width: 200px;
            top: 40px;
          }
          summary{
            cursor:pointer;
          }
        `;
    const fore = this.closest('fx-fore');

    // fore.addEventListener('ready', (e) => {
    this.render(style);
    // });
    fore.addEventListener('refresh-done', () => {
      this.update();
    });
  }
  update() {
    // console.log('update');
    try {
      const pre = this.shadowRoot.querySelectorAll('pre');
      // console.log('pre', pre);
      const fore = this.closest('fx-fore');
      Array.from(pre).forEach(element => {
        const inst = fore.getModel().getInstance(element.getAttribute('id'));
        if (inst.getAttribute('type') === 'xml') {
          element.innerText = this.serializeDOM(inst.instanceData);
        }
        if (inst.getAttribute('type') === 'json') {
          element.innerText = JSON.stringify(inst.instanceData, undefined, 2);
        }
      });
    } catch (e) {
      console.warn('caught problem in inspector', e.message);
    }
  }
  render(style) {
    const fore = this.closest('fx-fore');
    const instances = Array.from(fore.querySelectorAll('fx-instance'));
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            <div class="main">
            <slot></slot>
            <span class="handle"></span>
                ${instances.map(instance => `
                  <details>
                      <summary>${instance.id}</summary>
                      <pre id="${instance.id}"></pre>
                  </details>
                `)}
            </div>
        `;
    const handle = this.shadowRoot.querySelector('.handle');
    handle.addEventListener('click', e => {
      // console.log('toggling');
      if (this.hasAttribute('open')) {
        this.removeAttribute('open');
      } else {
        this.setAttribute('open', 'open');
      }
    });
  }
  serializeDOM(data) {
    if (!data) {
      console.warn('no data to serialize');
      return;
    }
    // console.log('serializeDOM', data);
    const ser = new XMLSerializer().serializeToString(data);
    return prettifyXml(ser);
  }
}
if (!customElements.get('fx-inspector')) {
  customElements.define('fx-inspector', FxInspector);
}

class FxDialog extends HTMLElement {
  static get properties() {
    return {
      id: String
    };
  }
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    const style = `
          :host {
            display:none;
            height: 100vh;
            width:100vw;
            position:fixed;
            left:0;
            top:0;
            right:0;
            bottom:0;
            transition:opacity 0.4s linear;
          }

        `;
    this.shadowRoot.innerHTML = this.render(style);
    this.id = this.getAttribute('id');

    // const dialog = document.getElementById(this.id);

    const closeBtn = this.querySelector('.close-dialog');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        this.classList.remove('show');
      });
    }
    this.setAttribute('role', 'dialog');
    this.setAttribute('aria-modal', 'false');

    /*
    this.addEventListener('transitionend', () => {
      console.log('transitionend');
      // this.style.display = 'none';
    });
    */

    this.focus();
  }
  render(styles) {
    return `
      <style>
          ${styles}
      </style>
      <slot></slot>
    `;
  }
  showModal() {
    window.addEventListener('keyup', e => {
      if (e.key === 'Escape') {
        this.hide();
      }
    }, {
      once: true
    });
    this.classList.add('show');
  }
  async close() {
    await Fore.fadeOutElement(this, 400);
    this.classList.remove('show');
  }
}
if (!customElements.get('fx-dialog')) {
  customElements.define('fx-dialog', FxDialog);
}

/**
 * FxItems provides a templated list over its bound nodes. It is not standalone but expects to be used
 * within an fx-control element.
 *
 *
 *
 * @demo demo/selects3.html
 */
class FxItems extends FxControl {
  static get properties() {
    return {
      ...super.properties,
      valueAttr: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.valueAttr = this.hasAttribute('value') ? this.getAttribute('value') : null;
  }
  connectedCallback() {
    super.connectedCallback();
    // Some other library is stealing focus when clicking on the label of a checkbox list.
    // The browser should handle this, but we need to manually focus the checkbox if the label is pressed
    // TODO: find a better solution
    this.addEventListener('mousedown', e => {
      // const items = this.querySelectorAll('[value]');

      if (!Fore.isWidget(e.target)) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      if (e.target.nodeName === 'LABEL') {
        const target = resolveId(e.target.getAttribute('for'), this);
        target.focus();
      }
    });

    // Some other library is stealing focus when clicking on the label of a checkbox list.
    // The browser should handle this, but we need to manually focus the checkbox if the label is pressed
    // TODO: find a better solution
    this.addEventListener('mousedown', e => {
      this.querySelectorAll('[value]');
      if (e.target.nodeName === 'LABEL') {
        const target = resolveId(e.target.getAttribute('for'), this);
        target.focus();
      }
    });
    this.addEventListener('click', e => {
      e.preventDefault;
      e.stopPropagation();
      const items = this.querySelectorAll('[value]');
      let target;
      if (e.target.nodeName === 'LABEL') {
        target = resolveId(e.target.getAttribute('for'), this);
        target.checked = !target.checked;
      }
      let val = '';
      Array.from(items).forEach(item => {
        if (item.checked) {
          val += ` ${item.getAttribute('value')}`;
        }
      });
      this.setAttribute('value', val.trim());

      // ### check for parent control
      const parentBind = XPathUtil.getClosest('[ref]', this.parentNode);
      if (!parentBind) return;
      const modelitem = parentBind.getModelItem();
      const setval = this.shadowRoot.getElementById('setvalue');
      setval.setValue(modelitem, val.trim());
      setval.actionPerformed();
    });
  }
  getWidget() {
    return this;
  }
  async updateWidgetValue() {
    // console.log('setting items value');

    const parentBind = XPathUtil.getClosest('[ref]', this.parentNode);
    if (parentBind) {
      this.value = parentBind.value;
    }
    this.setAttribute('value', this.value);
  }

  /**
   * Updates an entry by setting the label and the value.
   *
   * Will connect label and control with `for` attribute with generated id.
   *
   * attention: limitations here: assumes that there's an `label` element plus an element with an `value`
   * attribute which it will update.
   *
   *
   *
   * @param newEntry
   * @param node
   */
  updateEntry(newEntry, node) {
    // console.log('fx-items updateEntry', this.value);

    // ### create unique id to connect label and input
    const id = Fore.createUUID();

    // ### handle 'label'
    const label = newEntry.querySelector('label');
    const lblExpr = Fore.getExpression(label.textContent);

    // ### xml / JSON
    if (node.nodeType) {
      const lblEvaluated = evaluateXPathToString(lblExpr, node, this);
      label.textContent = lblEvaluated;
    } else {
      const labelExpr = Fore.getExpression(lblExpr);
      label.textContent = node[labelExpr];
    }
    label.setAttribute('for', id);

    // ### handle the 'value'
    // getting element which has 'value' attr
    const input = newEntry.querySelector('[value]');
    // getting expr
    const expr = input.value;
    // const cutted = expr.substring(1, expr.length - 1);
    const cutted = Fore.getExpression(expr);
    let evaluated;
    if (node.nodeType) {
      evaluated = evaluateXPathToString(cutted, node, newEntry);
    } else {
      evaluated = node[cutted];
    }

    // adding space around value to allow matching of 'words'
    const spaced = ` ${evaluated} `;
    const valAttr = ` ${this.getAttribute('value')} `;
    input.value = evaluated;
    input.setAttribute('id', id);
    if (valAttr.indexOf(spaced) !== -1) {
      input.checked = true;
    }
  }
}
if (!customElements.get('fx-items')) {
  customElements.define('fx-items', FxItems);
}

class FxDroptarget extends withDraggability(ForeElementMixin) {}
if (!customElements.get('fx-droptarget')) {
  window.customElements.define('fx-droptarget', FxDroptarget);
}

class FxLogItem extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.eventName = '';
    this.shortName = '';
    this.shortInfo = '';
    this.shortPath = '';
    this.xpath = '';
  }
  connectedCallback() {
    const style = `
      :host {
        height: auto;
        font-size: 0.8em;
        font-weight: 400;

      }

      a,a:link,a:visited{
        color:black;
      }
      a{
        position:relative;
      }
      a[alt]:hover::after {
        content:attr(alt);
        position:absolute; 
        left:0;
        top:1em;
        border.thin solid;
        padding:0.5em;
        background:white;
        z-index:1;
        min-width:5em;
        border:thin solid;
        white-space:nowrap;
        overflow-wrap:break-word;
      }

     .info{
        padding:0 0.5em;
        margin:0.1rem 0;
        background:white;
        position:relative;
        border:1px solid #ddd;
        border-radius:1em;       
        box-shadow: 1px 1px 5px 0px rgba(79, 136, 183, 0.8);
      }
      :host(.action) .info{
        border-radius:0;
        border-color:steelblue;
      }

      .info label{
        grid-area:left;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .info a{
        grid-area:right;
        justify-self:end;
      }
      .info:hover{
        outline:3px solid lightblue;       
        transition:height 0.4s;
      }

       summary{
        padding:1em;
        display:flex;
        flex-wrap:wrap;
        padding:0.5em 0;
        cursor:pointer;
        gap:0.25em;
      }
/*
      .log-name{
        font-size:1.2em;
      }
      .log-name, .short-info{
        width:10em;
      }
*/
      .event-name{
        width:12em;
        text-align:right;
        }
      .short-info{
        flex:3;
        overflow:hidden;
        white-space:nowrap;
        text-overflow:ellipsis;
      }
    `;
    this.eventName = this.getAttribute('event-name');
    this.shortName = this.getAttribute('short-name');
    this.shortInfo = this.hasAttribute('short-info') ? this.getAttribute('short-info') : '';
    this.xpath = this.getAttribute('xpath');
    const cut = this.xpath.substring(this.xpath.indexOf('/fx-fore'), this.xpath.length);
    const xpathCut = `/${cut}`;
    const shortPath = xpathCut.replaceAll('fx-', '');
    const html = `
       <details class="info send">
              <summary>
                <span class="log-name"><a href="#" title="${shortPath}" data-path="${this.xpath}">${this.shortName}</a></span>
                <span class="short-info">${this.shortInfo}</span>
                <span class="event-name">${this.eventName}</span>                    
              </summary>
            <slot></slot>
        </details>
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${html}
    `;
  }
}
if (!customElements.get('fx-log-item')) {
  customElements.define('fx-log-item', FxLogItem);
}

class FxLogSettings extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.listenTo = [];
    this.listeners = [];
  }
  connectedCallback() {
    const style = `
      :host {
        display:block;
        position:relative;
        width:100%;
        border:thin solid #efefef;
        font-family: Verdana, Sans;

        margin:0;
        border:thin solid #ddd;
      }
      .boxes{
        column-width:14rem;
        overflow:auto;
        margin-bottom:5em;
        padding:1em;
      }
      .boxes > span{
        display:inline-block;
        width:14rem;
      }
      
      .buttons{
        position:absolute;
        top:0;
        right:0;
      }
      .buttons button{
        padding:0;
      }
      button{
        float:right;
      }
      button{
        border:none;
        background:transparent;
        width:2.25rem;
        height:2.25rem;
        cursor:pointer;
      }
      button#reset{
        padding:0;
        height:1rem;
      }
      header{
        padding:0.5rem;
        margin:0;
        border-bottom:2px solid #ddd;
      }
      #settings{
        padding:1em;
      }
      
    `;
    if (localStorage.getItem('fx-log-settings')) {
      this.listenTo = JSON.parse(localStorage.getItem('fx-log-settings'));
    } else {
      // this._defaultSettings();
      this.listenTo = FxLogSettings.defaultSettings();
    }
    const html = `
        <section id="settings">
            <header>log settings <button id="reset">reset</button></header>
            <div class="boxes"></div>
        </section>
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${html}
    `;
    const fore = window.document.querySelector('fx-fore');
    if (!fore) {
      console.error('fx-fore element not found in this page.');
    }
    const boxes = this.shadowRoot.querySelector('.boxes');

    /*
        build the list of checkboxes for the filtering settings
         */
    this.listenTo.forEach(item => {
      const wrapper = document.createElement('span');
      boxes.append(wrapper);
      const lbl = document.createElement('label');
      lbl.setAttribute('title', item.description);
      lbl.setAttribute('for', item.name);
      lbl.innerText = item.name;
      const cbx = document.createElement('input');
      cbx.setAttribute('type', 'checkbox');
      cbx.setAttribute('name', item.name);
      cbx.setAttribute('id', item.name);
      if (item.show) {
        cbx.setAttribute('checked', '');
      }
      wrapper.append(cbx);
      wrapper.append(lbl);
      cbx.addEventListener('click', e => {
        // console.log('filter box ticked', e);
        if (!e.target.checked) {
          // remove event listener
          const fore = document.querySelector('fx-fore');
          fore.removeEventListener(item.name, this._log);
          // e.preventDefault();
          // e.stopPropagation();
        }

        const t = this.listenTo.find(evt => evt.name === item.name);
        e.target.checked ? t.show = true : t.show = false;
        // console.log('filter', this.listenTo);
        localStorage.setItem('fx-log-settings', JSON.stringify(this.listenTo));
      });
      // boxes.appendChild(lbl);
    });

    // buttons
    const reset = this.shadowRoot.querySelector('#reset');
    reset.addEventListener('click', e => {
      // this._defaultSettings();
      localStorage.removeItem('fx-log-settings');
      window.location.reload();
    });
  }
  static defaultSettings() {
    return [{
      name: 'action-performed',
      show: false,
      description: 'fires after an action has been performed'
    }, {
      name: 'click',
      show: false,
      description: ''
    }, {
      name: 'deleted',
      show: false,
      description: 'fires after a delete action has been executed'
    }, {
      name: 'deselect',
      show: false,
      description: 'fires when fx-case is deselected'
    }, {
      name: 'dialog-hidden',
      show: false,
      description: 'fires after fx-dialog has been hidden'
    }, {
      name: 'dialog-shown',
      show: false,
      description: 'fired when a dialog has been shown'
    }, {
      name: 'error',
      show: false,
      description: 'fires after an error occurred'
    }, {
      name: 'execute-action',
      show: true,
      description: 'fires when an action executes'
    }, {
      name: 'init',
      show: false,
      description: 'fires when a control initializes'
    }, {
      name: 'index-changed',
      show: false,
      description: 'fires when the repeat index changes'
    }, {
      name: 'insert',
      show: false,
      description: 'fires when an fx-insert is executed'
    }, {
      name: 'instance-loaded',
      show: false,
      description: 'fires after an fx-instance has been loaded'
    }, {
      name: 'invalid',
      show: false,
      description: 'fires after a control became invalid'
    }, {
      name: 'item-changed',
      show: false,
      description: 'fires when a repeat item was changed'
    }, {
      name: 'item-created',
      show: false,
      description: 'fires when a repeat item was created'
    }, {
      name: 'loaded',
      show: false,
      description: 'fires after a fx-load has loaded'
    }, {
      name: 'model-construct',
      show: false,
      description: 'fires when a model gets constructed'
    }, {
      name: 'model-construct-done',
      show: false,
      description: 'fires after model initialization'
    }, {
      name: 'nonrelevant',
      show: false,
      description: 'fires after an fx-control became nonrelevant'
    }, {
      name: 'optional',
      show: false,
      description: 'fires after an fx-control became optional'
    }, {
      name: 'outermost-action-end',
      show: false,
      description: 'fires when an outermost action block is finished'
    }, {
      name: 'outermost-action-start',
      show: false,
      description: 'fires when an outermost action block is started'
    }, {
      name: 'path-mutated',
      show: false,
      description: 'fires when a path in a repeat has been mutated'
    }, {
      name: 'readonly',
      show: false,
      description: 'fires after an fx-control became readonly'
    }, {
      name: 'readwrite',
      show: false,
      description: 'fires after an fx-control became readwrite'
    }, {
      name: 'ready',
      show: false,
      description: 'fires after a fx-fore page has been completely initialized'
    }, {
      name: 'rebuild-done',
      show: false,
      description: 'fires after a rebuild has taken place'
    }, {
      name: 'recalculate-done',
      show: false,
      description: 'fires after a recalculate has taken place'
    }, {
      name: 'refresh-done',
      show: false,
      description: 'fires after a refresh has been done'
    }, {
      name: 'relevant',
      show: false,
      description: 'fires after a fx-control has become relevant'
    }, {
      name: 'reload',
      show: false,
      description: 'fires when a fx-reload action executes'
    }, {
      name: 'required',
      show: false,
      description: 'fires after an fx-control has become required'
    }, {
      name: 'return',
      show: false,
      description: 'fires after a fx-return returned'
    }, {
      name: 'select',
      show: false,
      description: 'fires when an fx-case has been selected'
    }, {
      name: 'submit',
      show: false,
      description: 'fires before a submission takes place'
    }, {
      name: 'submit-done',
      show: false,
      description: 'fires after a submission has successfully been executed'
    }, {
      name: 'submit-error',
      show: false,
      description: 'fires when a submission returned an error'
    }, {
      name: 'valid',
      show: false,
      description: 'fires after a fx-control has become valid'
    }, {
      name: 'value-changed',
      show: false,
      description: 'fires after a fx-control has changed its value'
    }];
  }
  _log(e, log) {
    const elementName = e.target.nodeName;
    if (elementName === 'FX-ACTION-LOG') return;
    // e.preventDefault();
    // e.stopPropagation();

    const row = document.createElement('div');
    row.classList.add('log-row');
    const logRow = this._logDetails(e);
    if (e.detail && Object.keys(e.detail).length === 0 && Object.getPrototypeOf(e.detail) === Object.prototype) {
      row.classList.add('no-detail');
    }
    row.innerHTML = logRow;
    if (this.outermost) {
      /*
            outermost-action-start and outermost-action-end are use as marker events only to start/end a list.
            They don't have aditional information to log.
             */
      if (e.type === 'outermost-action-start') return; // we don't want this event to actualy log something
      if (!this.outermostAppender) {
        this.outermostAppender = document.createElement('ul');
        log.append(this.outermostAppender);
      }
      const li = document.createElement('li');
      // li.innerHTML = logRow;
      li.append(row);
      this.outermostAppender.append(li);
    } else {
      log.append(row);
    }
    if (this.parentPath && elementName !== 'FX-ACTION') {
      row.classList.add('nested');
    }
    const targetElement = e.target;
    row.addEventListener('click', ev => {
      // console.log('clicked inspect item', targetElement);
      // console.log('clicked inspect item', ev.target.getAttribute('xpath'));

      this._highlight(targetElement);
    });
    const logRowTarget = row.querySelector('.event-target');
    if (!logRowTarget) return;
    logRowTarget.addEventListener('click', e => {
      const alreadyLogged = document.querySelectorAll('.fx-action-log-debug');
      alreadyLogged.forEach(logged => {
        logged.classList.remove('fx-action-log-debug');
      });
      targetElement.dispatchEvent(new CustomEvent('log-action', {
        composed: false,
        bubbles: true,
        cancelable: true,
        detail: {
          target: targetElement
        }
      }));
      targetElement.classList.add('fx-action-log-debug');
      targetElement.setAttribute('data-name', targetElement.nodeName);
      this._highlight(targetElement);
    });
    // log.append(logElements);
  }

  /**
   * logs all configured events.
   * Special treatment is given to action-execute event to log out all actions that
   * are triggered.
   *
   * @param e the event to log
   * @returns {string}
   * @private
   */
  _logDetails(e) {
    const eventType = e.type;
    // console.log('>>>> event type', type)
    const path = XPathUtil.getPath(e.target);
    const cut = path.substring(path.indexOf('/fx-fore'), path.length);
    const xpath = `/${cut}`;
    const short = cut.replaceAll('fx-', '');
    if (this.parentPath && !xpath.startsWith(this.parentPath)) {
      this.parentPath = null;
    }
    switch (eventType) {
      case 'deleted':
        const {
          deletedNodes
        } = e.detail;
        const s = new XMLSerializer();
        let serialized = '';
        deletedNodes.forEach(node => {
          serialized += s.serializeToString(node);
        });
        return `
                <fx-log-item event-name="${eventType}"
                             xpath="${xpath}"
                             short-info="${e.detail.ref}"
                             short-name="${e.target.nodeName.toLowerCase()}">
                    <section class="details">
                        <header>Details</header>
                        <section>
                            <span class="key">Deleted Nodes</span>
                            <textarea class="value" rows="5">${serialized.trim()}</textarea>
                        </section>
                    </section>
                </fx-log-item>
                `;
      case 'outermost-action-start':
        return 'start';
      case 'outermost-action-end':
        return '';
      case 'execute-action':
        // ##### here actions will be handled
        const actionElement = e.detail.action;
        return this._renderAction(actionElement, xpath, short, e);
      default:
        return `
                <fx-log-item event-name="${eventType}"
                             xpath="${xpath}"
                             short-name="${e.target.nodeName.toLowerCase()}">
                             
                    <section class="details">
                      ${this._listEventDetails(e)}
                    </section>
                </fx-log-item>
            `;
    }

    // }
  }

  _renderAction(actionElement, xpath, short, e) {
    actionElement.nodeName.split('-')[1];
    switch (actionElement.nodeName) {
      case 'FX-ACTION':
        this.parentPath = xpath;
        return `
                <fx-log-item event-name="${e.detail.event}"
                             xpath="${xpath}"
                             short-name="ACTION" class="action">
                    <section class="details">
                      <header>Attributes</header>
                      <section>
                      ${Array.from(actionElement.attributes).map(item => `
                        <span class="key">${item.nodeName}</span>
                        <span class="value">${item.nodeValue}</span>
                      `).join('')}                 
                      </section>
                    </section>
                </fx-log-item>  
            `;
      // break;
      case 'FX-MESSAGE':
        const message = e.detail.action.messageTextContent;
        return `
                    <fx-log-item event-name="${e.detail.event}"
                                 xpath="${xpath}"
                                 short-name="MESSAGE"
                                 short-info="${message}" class="action">
                        <section class="details">
                            <span>${message}</span>
                        </section>
                    </fx-log-item>
                `;
      // break;
      case 'FX-SEND':
        const submission = document.querySelector(`#${e.detail.action.getAttribute('submission')}`);
        return `
                <fx-log-item short-name="SEND"
                             short-info="${submission.id}"
                             event-name="${e.detail.event}"
                             xpath="${xpath}" class="action">
                        <section class="details">
                          <header>Submission</header>
                          <section class="attributes">
                          ${Array.from(submission.attributes).map(item => `
                            <span class="key">${item.nodeName}</span>
                            <span class="value">${item.nodeValue}</span>
                          `).join('')}                 
                          </section>  
                        </section>
               </fx-log-item>
                `;
      // break;
      case 'FX-SETVALUE':
        const instPath = XPathUtil.getPath(e.target.nodeset);
        const listensOn = e.target.nodeName === 'FX-CONTROL' ? e.target.updateEvent : e.detail.event;
        return `
                <fx-log-item short-name="SETVALUE"
                             short-info="${instPath}"
                             event-name="${listensOn}"
                             xpath="${xpath}" class="action">
                      <section class="details">
                          <span class="key">value</span>
                          <span class="value">${e.detail.value}</span>
                      </section>
                </fx-log-item>
                `;
      // break;
      default:
        return `
                    <fx-log-item event-name="${e.detail.event}" 
                                short-name="${e.target.nodeName}"
                                xpath="${xpath}"
                                class="action">
                          <section class="details">
                          </section>
                    </fx-log-item>
                    `;
    }
  }
  _listEventDetails(e) {
    if (e.detail && Object.keys(e.detail).length === 0 && Object.getPrototypeOf(e.detail) === Object.prototype) {
      return '';
    }
    return `${Object.keys(e.detail).map(item => `<span>${item}</span>`)}`;
  }
  _listAttributes(e) {
    // console.log('_listAttributes', e)
    return '';
    // return `${e.detail.model.id}`;
    /*
            if(e.detail &&
                Object.keys(e.detail).length === 0 &&
                Object.getPrototypeOf(e.detail) === Object.prototype){
              return ``;
            }else{
              return `${e.detail.map((item) => `<span>${item}</span>`)}`;
            }
        */
  }

  _highlight(element) {
    const defaultBG = element.style.backgroundColor;
    const defaultTransition = element.style.transition;
    element.style.transition = 'background 1s';
    element.style.backgroundColor = '#FFA500';
    setTimeout(() => {
      element.style.backgroundColor = defaultBG;
      setTimeout(() => {
        element.style.transition = defaultTransition;
      }, 400);
    }, 400);
    window.document.dispatchEvent(new CustomEvent('log-active-element', {
      detail: {
        target: element
      }
    }));
  }
}
if (!customElements.get('fx-log-settings')) {
  customElements.define('fx-log-settings', FxLogSettings);
}

class FxActionLog extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.listenTo = [];
    this.listeners = [];
  }
  connectedCallback() {
    const style = `
      :host {
        display:block;
        position:relative;
        width:100%;
        border:thin solid #efefef;
        background:transparent;
        font-family: Verdana, Sans;
        margin:0;
        padding:0.25rem;
      }
      a,a:link,a:visited{
        color:black;
      }
      a{
        position:relative;
      }
      a[alt]:hover::after {
        content:attr(alt);
        position:absolute; 
        left:0;
        bottom:-0.5em;
        border:thin solid;
        padding:0.5em;
        background:white;
        z-index:1;
        min-width:5em;
        border:thin solid;
        max-width:90%;
      }
     .details{
        padding:0.25em 0;
      }

      .key{
        width:20%;
        display:inline-block;
        min-width:5rem;
        border-bottom:1px solid #ddd;
        background:#efefef;
        vertical-align:top;
      }
      .value{
        display:inline-block;
        width:60%;
        
      }
      
      .buttons{
        position:absolute;
        top:0;
        right:0;
      }
      .buttons button{
        padding:0;
      }
      button{
        float:right;
      }
      button{
        border:none;
        background:transparent;
        width:2.25rem;
        height:2.25rem;
        cursor:pointer;
      }
      button#reset{
        padding:0;
        height:1rem;
      }
     .info{
        padding:0 0.5em;
        margin:0.1rem 0;
        background:white;
        position:relative;
        display:grid;
        grid-template-areas: "left right"
                    "bottom .";
        grid-template-columns: 75% 25%;
      }
      .info a{
        grid-area:right;
        justify-self:end;
      }
      .details > section{
        display:flex;
        flex-wrap:wrap;
        padding:0.5em 0;
      }
      fx-log-item{
      }
      header{
        padding:0.5rem;
        margin:0;
        border-bottom:2px solid #ddd;
      }
      
      .info:hover{
        outline:3px solid lightblue;       
        transition:height 0.4s;
      }

      ol{
        background: #efefef;
        padding: 0.5em 0 0 2em;
        border-left:3px solid red;
      }
     
      .event-name{
        display:inline-block;
      }
      #log{
        margin-bottom:10em;
        margin-right:2em;
      }
      .log-row{
        margin:0;
        padding:0;
        position:relative;
        font-size:0.8em;
        border-left:4px solid transparent;
        padding-left:5px;
        width:calc(100% - 2em);
        margin-bottom:0.25em;
      }
      .log-row summary{
        display:flex;
        flex-wrap:wrap;
        padding:0.5em 0;
        cursor:pointer;
      }
      .log-row summary > span {
        width:calc(90% div 3);
      }

      .log-name{
        position:relative;
      }
      .short-info{
        flex:3;
        overflow:hidden;
        white-space:nowrap;
        text-overflow:ellipsis;
      }
      .log-row.no-detail summary{
        position:relative;
      }
      .log-row.no-detail summary{
        list-style:none;
        padding-left:1rem;
      }
      .log-row.no-detail summary::-webkit-details-marker {
        display: none;
      }
      .log-row.nested{
        margin-left:1em;
      }
      .nested .event-name{
        display:none;
      }
      
      .setvalue .value{
        background:lightyellow;
      }
       summary{
        padding:1em;
        border-bottom:2px solid #ddd;
      }
      .outer-details{
        height:100%;
        overflow:auto;
        margin-top:2rem;
        background:rgba(250, 250, 250, 0.9);
      }
      
      .outer-details > header{
        position:absolute;
        top:-1px;
        width:calc(100% - 2rem);
        border-bottom:2px solid #ddd;
        font-size:1rem;
        height:1rem;
     }
      .outer-details > summary{
        font-size:1em;
      }
      ul{
        list-style:none;
        padding:0;
        margin:0.1em 0;
        border-left:3px solid steelblue;
        padding:0.1em 0;
      }
      ul .log-row{
        padding-left:3px;
        width:calc(100% - 1em);
      }
    `;
    if (localStorage.getItem('fx-action-log-filters')) {
      this.listenTo = JSON.parse(localStorage.getItem('fx-action-log-filters'));
    } else {
      this.listenTo = FxLogSettings.defaultSettings();
    }
    if (localStorage.getItem('fx-log-settings')) {
      this.listenTo = JSON.parse(localStorage.getItem('fx-log-settings'));
    } else {
      this.listenTo = FxLogSettings.defaultSettings();
    }
    const html = `
      <section open class="outer-details">
        <header>Log 
            <span class="buttons">
                <button id="del"" title="empty log - Ctrl+d">
                    <svg viewBox="0 0 24 24" style="width:24px;height:24px;" preserveAspectRatio="xMidYMid meet" focusable="true"><g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"></path></g></svg></a>
                </button>
            </span>
        </header>
        <div id="log"></div>
      </section>
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${html}
    `;
    const fore = window.document.querySelector('fx-fore');
    if (!fore) {
      console.error('fx-fore element not found in this page.');
    }
    const log = this.shadowRoot.querySelector('#log');
    // fore.classList.add('action-log');

    this.listenTo.forEach(eventName => {
      if (eventName.show) {
        document.addEventListener(eventName.name, e => {
          this._log(e, log);
        });
      }
    });

    // const boxes = this.shadowRoot.querySelector('.boxes');

    /*
        build the list of checkboxes for the filtering settings
         */
    /*
                this.listenTo.forEach(item => {
                    const wrapper = document.createElement('span');
                    boxes.append(wrapper);
                     const lbl = document.createElement('label');
                    lbl.setAttribute('title', item.description);
                    lbl.setAttribute('for', item.name);
                    lbl.innerText = item.name;
                     const cbx = document.createElement('input');
                    cbx.setAttribute('type', 'checkbox');
                    cbx.setAttribute('name', item.name);
                    cbx.setAttribute('id', item.name);
                    if (item.show) {
                        cbx.setAttribute('checked', '');
                    }
                    wrapper.append(cbx);
                    wrapper.append(lbl);
                     cbx.addEventListener('click', e => {
                        console.log('filter box ticked', e);
                        if (!e.target.checked) {
                            // remove event listener
                            const fore = document.querySelector('fx-fore');
                            fore.removeEventListener(item.name, this._log);
                            // e.preventDefault();
                            // e.stopPropagation();
                        }
                        const t = this.listenTo.find(evt => evt.name === item.name);
                        e.target.checked ? t.show = true : t.show = false;
                        // console.log('filter', this.listenTo);
                        localStorage.setItem('fx-action-log-filters', JSON.stringify(this.listenTo));
                    })
                    // boxes.appendChild(lbl);
                });
        */

    document.addEventListener('outermost-action-start', e => {
      this.outermost = true;
    }, {
      capture: true
    });
    document.addEventListener('outermost-action-end', e => {
      this.outermost = false;
      this.outermostAppender = null;
    }, {
      capture: true
    });

    // buttons
    const del = this.shadowRoot.querySelector('#del');
    del.addEventListener('click', e => {
      this.shadowRoot.querySelector('#log').innerHTML = '';
    });
    document.addEventListener('keydown', event => {
      if (event.ctrlKey && event.key === 'd') {
        this.shadowRoot.querySelector('#log').innerHTML = '';
      }
    });
  }
  _defaultSettings() {
    this.listenTo = [{
      name: 'action-performed',
      show: false,
      description: 'fires after an action has been performed'
    }, {
      name: 'click',
      show: false,
      description: ''
    }, {
      name: 'deleted',
      show: false,
      description: 'fires after a delete action has been executed'
    }, {
      name: 'deselect',
      show: false,
      description: 'fires when fx-case is deselected'
    }, {
      name: 'dialog-hidden',
      show: false,
      description: 'fires after fx-dialog has been hidden'
    }, {
      name: 'dialog-shown',
      show: false,
      description: 'fired when a dialog has been shown'
    }, {
      name: 'error',
      show: false,
      description: 'fires after an error occurred'
    }, {
      name: 'execute-action',
      show: true,
      description: 'fires when an action executes'
    }, {
      name: 'init',
      show: false,
      description: 'fires when a control initializes'
    }, {
      name: 'index-changed',
      show: false,
      description: 'fires when the repeat index changes'
    }, {
      name: 'insert',
      show: false,
      description: 'fires when an fx-insert is executed'
    }, {
      name: 'instance-loaded',
      show: false,
      description: 'fires after an fx-instance has been loaded'
    }, {
      name: 'invalid',
      show: false,
      description: 'fires after a control became invalid'
    }, {
      name: 'item-changed',
      show: false,
      description: 'fires when a repeat item was changed'
    }, {
      name: 'item-created',
      show: false,
      description: 'fires when a repeat item was created'
    }, {
      name: 'loaded',
      show: false,
      description: 'fires after a fx-load has loaded'
    }, {
      name: 'model-construct',
      show: false,
      description: 'fires when a model gets constructed'
    }, {
      name: 'model-construct-done',
      show: false,
      description: 'fires after model initialization'
    }, {
      name: 'nonrelevant',
      show: false,
      description: 'fires after an fx-control became nonrelevant'
    }, {
      name: 'optional',
      show: false,
      description: 'fires after an fx-control became optional'
    }, {
      name: 'outermost-action-end',
      show: false,
      description: 'fires when an outermost action block is finished'
    }, {
      name: 'outermost-action-start',
      show: false,
      description: 'fires when an outermost action block is started'
    }, {
      name: 'path-mutated',
      show: false,
      description: 'fires when a path in a repeat has been mutated'
    }, {
      name: 'readonly',
      show: false,
      description: 'fires after an fx-control became readonly'
    }, {
      name: 'readwrite',
      show: false,
      description: 'fires after an fx-control became readwrite'
    }, {
      name: 'ready',
      show: false,
      description: 'fires after a fx-fore page has been completely initialized'
    }, {
      name: 'rebuild-done',
      show: false,
      description: 'fires after a rebuild has taken place'
    }, {
      name: 'recalculate-done',
      show: false,
      description: 'fires after a recalculate has taken place'
    }, {
      name: 'refresh-done',
      show: false,
      description: 'fires after a refresh has been done'
    }, {
      name: 'relevant',
      show: false,
      description: 'fires after a fx-control has become relevant'
    }, {
      name: 'reload',
      show: false,
      description: 'fires when a fx-reload action executes'
    }, {
      name: 'required',
      show: false,
      description: 'fires after an fx-control has become required'
    }, {
      name: 'return',
      show: false,
      description: 'fired by embedded Fore controls to return their bound value'
    }, {
      name: 'select',
      show: false,
      description: 'fires when an fx-case has been selected'
    }, {
      name: 'submit',
      show: false,
      description: 'fires before a submission takes place'
    }, {
      name: 'submit-done',
      show: false,
      description: 'fires after a submission has successfully been executed'
    }, {
      name: 'submit-error',
      show: false,
      description: 'fires when a submission returned an error'
    }, {
      name: 'valid',
      show: false,
      description: 'fires after a fx-control has become valid'
    }, {
      name: 'value-changed',
      show: false,
      description: 'fires after a fx-control has changed its value'
    }];
  }
  _log(e, log) {
    const elementName = e.target.nodeName;
    if (elementName === 'FX-ACTION-LOG') return;
    // e.preventDefault();
    // e.stopPropagation();

    const row = document.createElement('div');
    row.classList.add('log-row');
    const logRow = this._logDetails(e);
    if (e.detail && Object.keys(e.detail).length === 0 && Object.getPrototypeOf(e.detail) === Object.prototype) {
      row.classList.add('no-detail');
    }
    row.innerHTML = logRow;
    if (this.outermost) {
      /*
            outermost-action-start and outermost-action-end are use as marker events only to start/end a list.
            They don't have aditional information to log.
             */
      if (e.type === 'outermost-action-start') return; // we don't want this event to actualy log something
      if (!this.outermostAppender) {
        this.outermostAppender = document.createElement('ul');
        log.append(this.outermostAppender);
      }
      const li = document.createElement('li');
      // li.innerHTML = logRow;
      li.append(row);
      this.outermostAppender.append(li);
    } else {
      log.append(row);
    }
    if (this.parentPath && elementName !== 'FX-ACTION') {
      row.classList.add('nested');
    }
    const targetElement = e.target;
    row.addEventListener('click', ev => {
      // console.log('clicked inspect item', targetElement);
      // console.log('clicked inspect item', ev.target.getAttribute('xpath'));

      this._highlight(targetElement);
    });
    const logRowTarget = row.querySelector('.event-target');
    if (!logRowTarget) return;
    logRowTarget.addEventListener('click', e => {
      const alreadyLogged = document.querySelectorAll('.fx-action-log-debug');
      alreadyLogged.forEach(logged => {
        logged.classList.remove('fx-action-log-debug');
      });
      targetElement.dispatchEvent(new CustomEvent('log-action', {
        composed: false,
        bubbles: true,
        cancelable: true,
        detail: {
          target: targetElement
        }
      }));
      targetElement.classList.add('fx-action-log-debug');
      targetElement.setAttribute('data-name', targetElement.nodeName);
      this._highlight(targetElement);
    });
    // log.append(logElements);
  }

  /**
   * logs all configured events.
   * Special treatment is given to action-execute event to log out all actions that
   * are triggered.
   *
   * @param e the event to log
   * @returns {string}
   * @private
   */
  _logDetails(e) {
    const eventType = e.type;
    const path = XPathUtil.getDocPath(e.target);
    // console.log('>>>> _logDetails', path);
    const cut = path.substring(path.indexOf('/fx-fore'), path.length);
    const xpath = `/${cut}`;
    const short = cut.replaceAll('fx-', '');
    if (this.parentPath && !xpath.startsWith(this.parentPath)) {
      this.parentPath = null;
    }
    switch (eventType) {
      case 'deleted':
        const {
          deletedNodes
        } = e.detail;
        const s = new XMLSerializer();
        let serialized = '';
        deletedNodes.forEach(node => {
          serialized += s.serializeToString(node);
        });
        return `
                <fx-log-item event-name="${eventType}"
                             xpath="${xpath}"
                             short-info="${e.detail.ref}"
                             short-name="${e.target.nodeName.toLowerCase()}">
                    <section class="details">
                        <header>Details</header>
                        <section>
                            <span class="key">Deleted Nodes</span>
                            <textarea class="value" rows="5">${serialized.trim()}</textarea>
                        </section>
                    </section>
                </fx-log-item>
                `;
      case 'outermost-action-start':
        return 'start';
      case 'outermost-action-end':
        return '';
      case 'execute-action':
        // ##### here actions will be handled
        const actionElement = e.detail.action;
        return this._renderAction(actionElement, xpath, short, e);
      default:
        return `
                <fx-log-item event-name="${eventType}"
                             xpath="${xpath}"
                             short-name="${e.target.nodeName.toLowerCase()}">
                             
                    <section class="details">
                      ${this._listEventDetails(e)}
                    </section>
                </fx-log-item>
            `;
    }

    // }
  }

  _renderAction(actionElement, xpath, short, e) {
    actionElement.nodeName.split('-')[1];
    let eventName;
    switch (actionElement.nodeName) {
      case 'FX-ACTION':
        this.parentPath = xpath;
        eventName = e.target.currentEvent ? e.target.currentEvent.type : e.detail.event ? e.detail.event : '';
        return `
                <fx-log-item event-name="${eventName}"
                             xpath="${xpath}"
                             short-name="ACTION"
                              data-path="${e.detail.path}" 
                              class="action">
                    <section class="details">
                      <header>Attributes</header>
                      <section>
                      ${Array.from(actionElement.attributes).map(item => `
                        <span class="key">${item.nodeName}</span>
                        <span class="value">${item.nodeValue}</span>
                      `).join('')}                 
                      </section>
                    </section>
                </fx-log-item>  
            `;
      // break;
      case 'FX-MESSAGE':
        const message = e.detail.action.messageTextContent;
        return `
                    <fx-log-item event-name="${e.detail.event}"
                                 xpath="${xpath}"
                                 short-name="MESSAGE"
                                 short-info="${message}" class="action">
                        <section class="details">
                            <span>${message}</span>
                        </section>
                    </fx-log-item>
                `;
      // break;
      case 'FX-SEND':
        const submission = document.querySelector(`#${e.detail.action.getAttribute('submission')}`);
        const event = e.detail.event ? e.detail.event : '';
        return `
                <fx-log-item short-name="SEND"
                             short-info="${submission.getAttribute('id')}"
                             event-name="${event}"
                             xpath="${xpath}" class="action"
                             data-path="${e.detail.path}" >
                        <section class="details">
                          <header>Submission</header>
                          <section class="attributes">
                          ${Array.from(submission.attributes).map(item => `
                            <span class="key">${item.nodeName}</span>
                            <span class="value">${item.nodeValue}</span>
                          `).join('')}                 
                          </section>  
                        </section>
               </fx-log-item>
                `;
      // break;
      case 'FX-SETVALUE':
        const instPath = XPathUtil.getPath(e.target.nodeset);
        const listensOn = e.target.nodeName === 'FX-CONTROL' ? e.target.updateEvent : e.detail.event ? e.detail.event : '';
        return `
                <fx-log-item short-name="SETVALUE"
                             short-info="${instPath}"
                             event-name="${listensOn}"
                             xpath="${xpath}"
                             data-path="${e.detail.path}" class="action">
                      <section class="details">
                          <span class="key">value</span>
                          <span class="value">${e.detail.value}</span>
                      </section>
                </fx-log-item>
                `;
      // break;
      default:
        eventName = e.target.currentEvent ? e.target.currentEvent.type : e.detail.event ? e.detail.event : '';
        return `
                    <fx-log-item event-name="${eventName}" 
                                short-name="${e.target.nodeName}"
                                xpath="${xpath}"
                                data-path="${e.detail.path}" 
                                class="action">
                          <section class="details">
                          </section>
                    </fx-log-item>
                    `;
    }
  }
  _listEventDetails(e) {
    if (e.detail && Object.keys(e.detail).length === 0 && Object.getPrototypeOf(e.detail) === Object.prototype) {
      return '';
    }
    return `${Object.keys(e.detail).map(item => `<span>${item}</span>`)}`;
  }
  _listAttributes(e) {
    // console.log('_listAttributes', e)
    return '';
    // return `${e.detail.model.id}`;
    /*
            if(e.detail &&
                Object.keys(e.detail).length === 0 &&
                Object.getPrototypeOf(e.detail) === Object.prototype){
              return ``;
            }else{
              return `${e.detail.map((item) => `<span>${item}</span>`)}`;
            }
        */
  }

  _highlight(element) {
    const defaultBG = element.style.backgroundColor;
    const defaultTransition = element.style.transition;
    element.style.transition = 'background 1s';
    element.style.backgroundColor = '#FFA500';
    setTimeout(() => {
      element.style.backgroundColor = defaultBG;
      setTimeout(() => {
        element.style.transition = defaultTransition;
      }, 400);
    }, 400);
    window.document.dispatchEvent(new CustomEvent('log-active-element', {
      detail: {
        target: element
      }
    }));
  }
}
if (!customElements.get('fx-action-log')) {
  customElements.define('fx-action-log', FxActionLog);
}

function addClass(element, strClass) {
  element.classList.add(strClass);
}
function removeClass(element, strClass) {
  element.classList.remove(strClass);
}

// Checks whether the text node is not empty or contains only the EOL
function isEmptyTextNode(node) {
  if (typeof node !== 'object') {
    throw new Error(`isEmptyTextNode: Expected argument node of type object, ${typeof node} given.`);
  }
  return /^\s*$/.test(node.textContent);
}

// Checks whether the node or its children contains only text information
function containsOnlyText(node, checkChildren) {
  if (typeof node !== 'object') {
    throw new Error(`containsOnlyText: Expected argument node of type object, ${typeof node} given.`);
  }
  checkChildren = checkChildren || false;
  let result = false;
  let nodeTmp = null;

  // does the node contain only text nodes?
  if (checkChildren) {
    for (let i = 0, len = node.childNodes.length; i < len; i += 1) {
      nodeTmp = node.childNodes[i];
      result = nodeTmp.nodeType === Node.TEXT_NODE || nodeTmp.nodeType === Node.COMMENT_NODE || nodeTmp.nodeType === Node.CDATA_SECTION_NODE;
      if (!result) {
        break;
      }
    }
  } else {
    // check the node type if it doesn't have any children
    result = node.nodeType === Node.TEXT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.CDATA_SECTION_NODE;
  }
  return result;
}

// Create element wrapper -- allows to set attributes using the config object.
function newElement(elem, attrs) {
  const el = document.createElement(elem);
  attrs = attrs || {};
  for (const attr of Object.keys(attrs)) {
    el.setAttribute(attr, attrs[attr]);
  }
  return el;
}

// Helper function for options view
function drawOptionRow(optionCode, optionText) {
  const row = newElement('span', {
    class: 'adi-opt'
  });
  row.innerHTML = `<label><input type="checkbox" data-opt="${optionCode}">${optionText}</label>`;
  return row;
}

// Renders the options panel
function drawOptions() {
  const ui = newElement('div', {
    id: 'adi-opts-view',
    class: 'adi-hidden'
  });
  const head1 = newElement('span', {
    class: 'adi-opt-heading'
  });
  const head2 = newElement('span', {
    class: 'adi-opt-heading'
  });
  const close = newElement('span', {
    class: 'adi-opt-close'
  });
  head1.textContent = 'General options';
  head2.textContent = 'Observed nodes';
  ui.appendChild(head1);
  ui.appendChild(drawOptionRow('saving', 'Enable saving of settings'));
  ui.appendChild(drawOptionRow('makeVisible', 'Scroll to the active element in DOM View'));
  ui.appendChild(drawOptionRow('omitEmptyText', 'Hide empty text nodes'));
  ui.appendChild(drawOptionRow('foldText', 'Fold the text nodes'));
  ui.appendChild(drawOptionRow('transparent', 'Enable transparent background'));
  ui.appendChild(head2);
  ui.appendChild(drawOptionRow('nodeTypes-3', 'Text node'));
  ui.appendChild(drawOptionRow('nodeTypes-8', 'Comment node'));
  // ui.appendChild(drawOptionRow('nodeTypes-1', 'Element node'));
  // ui.appendChild(drawOptionRow('nodeTypes-9', 'Document node'));
  ui.appendChild(close);
  return ui;
}

// Stops event propagation and also prevents the default behavior.
function pauseEvent(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
  e.cancelBubble = true;
  e.returnValue = false;
  return false;
}
// Helper function for attributes view
function drawAttrRow(attrName, attrValue) {
  const row = newElement('span', {
    class: 'adi-attr'
  });
  switch (attrName.toLowerCase()) {
    case 'defaultaction':
      row.innerHTML = `<label>${attrName}: <select data-attr="${attrName}" value="${attrValue}"><option>perform</option><option>cancel</option></label>`;
      break;
    case 'delay':
      row.innerHTML = `<label>${attrName}: <input type="number" data-attr="${attrName}" value="${attrValue}" readonly="readonly"></label>`;
      break;
    default:
      row.innerHTML = `<label>${attrName}: <input type="text" data-attr="${attrName}" value="${attrValue}" readonly="readonly"></label>`;
  }
  return row;
}

function isAttributeShown(name, sourceNode) {
  if (name === 'style') return false;
  return true;
  // return name === 'id' || name === 'ref' || name === 'event';
}

class ADI {
  constructor(rootElement, instance) {
    this.sourceNodeByInspectorNodeLookup = new Map();
    this.uiView = null;
    this.menuView = null;
    this.domView = null;
    this.attrView = null;
    this.optsView = null;
    /**
     * The current active element. Note this is the element in the DOM view
     */
    this.activeElement = null;
    this.vertResizing = false;
    this.horizResizing = false;
    this.pathScrolling = null;
    this.elemLookup = false;
    this.styleBackup = '';
    this.xPos = 0;
    this.delegatedEvents = [];
    this.options = {
      align: 'right',
      // NOTE: left is not supported in this version
      split: 50,
      minSplit: 30,
      visible: true,
      saving: false,
      transparent: true,
      omitEmptyText: true,
      makeVisible: true,
      foldText: true,
      nodeTypes: [Node.ELEMENT_NODE, Node.TEXT_NODE, Node.COMMENT_NODE, Node.DOCUMENT_NODE]
    };
    if (instance === '#document') {
      this.instanceId = '#document';
      this.document = window.document;
      this.isInstanceViewer = false;
    } else {
      this.instanceId = instance.id;
      if (!instance || instance.localName !== 'fx-instance') {
        console.error('No instance found!');
      }
      this.document = instance.getInstanceData();
      this.isInstanceViewer = true;
      this.options.foldText = false;
    }
    this.drawUI(rootElement);
    this.registerEvents();

    // We're updating here, but we're doing that again later, when the UI is read (the 'ready' event fires)
    this.drawDOM(this.document, this.domView.querySelector('.adi-tree-view'), true);
    document.addEventListener('execute-action', e => this.processExecuteAction);
  }

  // Returns selected element or null
  getSelected() {
    if (!this.activeElement) {
      return null;
    }
    let elem = document;
    elem = this.sourceNodeByInspectorNodeLookup.get(this.activeElement);
    /*
        document.dispatchEvent(
            new CustomEvent('path-touched', {
                composed: true,
                bubbles: true,
                detail: {path: elem.modelItem.path},
            }),
        );
    */

    return elem;
  }

  // Loads user defined options stored in HTML5 storage (if available)
  loadOptions() {
    let userOptions = {};
    userOptions = JSON.parse(window.localStorage.getItem('ADI.options')) || {};

    // merge with defaults
    for (const opt of Object.keys(userOptions)) {
      this.options[opt] = userOptions[opt];
    }
  }

  // Saves user defined options into the HTML5 storage (if available)
  saveOptions() {
    if (this.options.saving) {
      window.localStorage.setItem('ADI.options', JSON.stringify(this.options));
    }
  }

  // Checks if a node has some child nodes and if at least on of them is of a supported type
  hasRequiredNodes(node) {
    if (typeof node !== 'object') {
      throw new Error(`hasRequiredNodes: Expected argument node of type object, ${typeof node} given.`);
    }
    if (node.hasChildNodes()) {
      for (let i = 0, len = node.childNodes.length; i < len; i += 1) {
        const child = node.childNodes[i];
        if (this.options.nodeTypes.includes(child.nodeType)) {
          return true;
        }
      }
    }
    return false;
  }

  // Creates a starting markup for a new DOM tree view node
  newTreeNode(sourceNode) {
    if (typeof sourceNode !== 'object') {
      throw new Error(`newTreeNode: Expected argument node of type object, ${typeof sourceNode} given.`);
    }
    const withChildren = this.hasRequiredNodes(sourceNode);
    let omit = false;
    let adiNode = sourceNode.nodeName.startsWith('FX-') ? `adi-node ${sourceNode.nodeName.toLowerCase()}` : '';
    if (sourceNode.nodeName.startsWith('FX-')) {
      adiNode = `adi-node ${sourceNode.nodeName.toLowerCase()}`;
      adiNode += Fore.isActionElement(sourceNode.nodeName) ? ' action' : '';
    }
    const elem = newElement('li', {
      class: adiNode
    });

    // do not show ADI DOM nodes in the DOM view
    if (sourceNode === this.uiView) {
      return null;
    }

    // generate UI for elements with children
    if (withChildren) {
      elem.appendChild(newElement('span', {
        class: 'adi-trigger'
      }));
    }

    // we can omit empty text nodes if allowed in options
    if (this.options.omitEmptyText && sourceNode.nodeType === Node.TEXT_NODE) {
      omit = isEmptyTextNode(sourceNode);
    }
    if (!omit) {
      const tagStart = newElement('span');
      this.sourceNodeByInspectorNodeLookup.set(tagStart, sourceNode);
      this.sourceNodeByInspectorNodeLookup.set(sourceNode, tagStart);
      let tagEnd = null;
      if (containsOnlyText(sourceNode)) {
        if (sourceNode.nodeType === Node.COMMENT_NODE) {
          addClass(tagStart, 'adi-comment-node');
          if (typeof tagStart.innerText === 'string') {
            tagStart.innerText = `<!-- ${sourceNode.textContent} -->`;
          }
        } else {
          addClass(tagStart, 'adi-text-node');
          tagStart.textContent = sourceNode.textContent;
        }
      } else {
        addClass(tagStart, 'adi-normal-node');
        if (sourceNode.nodeType !== Node.DOCUMENT_NODE) {
          // tagStart.textContent = '<' + node.nodeName.toLowerCase() + '>';

          /*
                    let attrString = `<${sourceNode.nodeName.toLowerCase()} `;
                    if(sourceNode.attributes){
                        Array.from(sourceNode.attributes).forEach(attr => {
                            attrString += `${attr.nodeName}="${attr.nodeValue}" `;
                        });
                        console.log('ATTRSTRING',attrString);
                    }
                    if (sourceNode.nodeName === 'FX-BIND') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} ref="${sourceNode.getAttribute('ref')}">`;
                    } else if (sourceNode.nodeName === 'FX-INSERT') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} ref="${sourceNode.getAttribute('ref')}">`;
                    } else if (sourceNode.nodeName === 'FX-INSTANCE') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} id="${sourceNode.id}">`;
                    } else if (sourceNode.nodeName === 'FX-CONTROL') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} ref="${sourceNode.getAttribute('ref')}">`;
                    } else if (sourceNode.nodeName === 'FX-SEND') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} submission="${sourceNode.getAttribute('submission')}">`;
                    } else if (sourceNode.nodeName === 'FX-SETVALUE') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} ref="${sourceNode.getAttribute('ref')}">`;
                    } else if (sourceNode.nodeName === 'FX-SUBMISSION') {
                        tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()} id="${sourceNode.getAttribute('id')}">`;
                    } else {
          */
          const attrString = Array.from(sourceNode.attributes).filter(attr => this.isInstanceViewer ? true : isAttributeShown(attr.name)).map(attr => `${attr.name}="${attr.value}"`).join(' ');
          tagStart.textContent = `<${sourceNode.nodeName.toLowerCase()}${attrString ? ` ${attrString}` : ''}>`;
          // }

          if (withChildren) {
            tagEnd = newElement('span');
            addClass(tagEnd, 'adi-end-node');
            tagEnd.textContent = `</${sourceNode.nodeName.toLowerCase()}>`;
          }
        } else {
          tagStart.textContent = sourceNode.nodeName.toLowerCase();
        }
      }
      elem.appendChild(tagStart);
      /*
                      const icon = document.createElement('span');
                      icon.textContent = 'x';
                      icon.classList.add(('icon'))
                      const icon2 = document.createElement('span');
                      icon2.textContent = '<-';
                      icon2.classList.add(('icon'))
                      elem.appendChild(icon);
                      elem.appendChild(icon2);
      */
      if (sourceNode.nodeName.startsWith('FX-')) {
        tagStart.classList.add('fore-node');
        tagStart.classList.add(sourceNode.nodeName.toLowerCase());
      }
      if (tagEnd) {
        elem.appendChild(tagEnd);
        if (sourceNode.nodeName.startsWith('FX-')) {
          tagEnd.classList.add('fore-node');
        }
      }
      return elem;
    }
    return null;
  }

  // Renders the DOM Tree view
  drawDOM(root, elem, isRoot) {
    if (typeof root !== 'object') {
      throw new Error(`drawDOM: Expected argument root of type object, ${typeof root} given.`);
    }
    let newNode = null;
    let isOpen = true;
    const adiNode = elem.nodeName.startsWith('FX-') ? `adi-node ${node.nodeName.toLowerCase()}` : '';
    if (isRoot && this.options.nodeTypes.indexOf(root.nodeType) !== -1) {
      elem.innerHTML = '';
      newNode = this.newTreeNode(root);
      if (this.hasRequiredNodes(root)) {
        newNode.appendChild(newElement('ul', {
          'data-open': true,
          class: adiNode
        }));
        addClass(newNode.querySelector('.adi-trigger'), 'opened');
      }
      elem.appendChild(newNode);
      elem = elem.querySelector('ul');
    }

    // recursive DOM traversal
    for (let i = 0, len = root.childNodes.length; i < len; i += 1) {
      const node = root.childNodes[i];
      const withChildren = this.hasRequiredNodes(node);
      if (this.options.nodeTypes.indexOf(node.nodeType) !== -1) {
        newNode = this.newTreeNode(node);
        if (newNode) {
          if (withChildren) {
            if (this.options.foldText) {
              isOpen = !containsOnlyText(node, true);
            } else {
              isOpen = true;
            }
            if (node.nodeName === 'HEAD') isOpen = false;
            if (node.nodeName === 'SELECT') isOpen = false;
            if (node.nodeName === 'FX-INSTANCE') isOpen = false;
            /*
                        if(this.options.closedElements.includes(node.nodeName.toLowerCase())){
                            isOpen = false;
                        }
            */

            if (node.nodeType === Node.DOCUMENT_NODE) {
              newNode.appendChild(newElement('ul', {
                'data-open': isOpen,
                class: adiNode
              }));
            } else {
              newNode.insertBefore(newElement('ul', {
                'data-open': isOpen,
                class: adiNode
              }), newNode.lastChild);
            }
            addClass(newNode.querySelector('.adi-trigger'), isOpen ? 'opened' : 'closed');
          }
          elem.appendChild(newNode);
          if (this.getSelected() === node) {
            const span = newNode.querySelector('span.adi-normal-node');
            span?.classList?.add('adi-active-node');
            this.activeElement = span;
            newNode.scrollIntoView({
              block: 'nearest',
              behavior: 'instant'
            });
          }
          if (withChildren) {
            this.drawDOM(node, newNode.querySelector('ul'), false);
          }
        }
      }
    }
  }

  // Show/hide the options view
  toggleOptions() {
    if (this.optsView.className.indexOf('adi-hidden') !== -1) {
      removeClass(this.optsView, 'adi-hidden');
    } else {
      addClass(this.optsView, 'adi-hidden');
      this.attrView.querySelector('.adi-content').innerHTML = '';
      this.refreshUI();
      this.drawDOM(document, this.domView.querySelector('.adi-tree-view'), true);
      if (this.options.saving) {
        this.saveOptions();
      } else {
        window.localStorage.removeItem('ADI.options');
      }
    }
  }

  // Renders the UI
  drawUI(rootElement) {
    this.uiView = newElement('div', {
      id: 'adi-wrapper',
      class: this.options.transparent ? 'transparent' : ''
    });
    this.domView = newElement('div', {
      id: 'adi-dom-view'
    });
    const domViewContent = newElement('div', {
      class: 'adi-content',
      id: 'detailsView'
    });
    // this.attrView.appendChild(newElement('fx-fore', {src: './lab/inspector-view.html'}));

    // const horizSplit = newElement('div', {id: 'adi-horiz-split'});
    const domTree = newElement('ul', {
      class: 'adi-tree-view'
    });
    const domPathWrap = newElement('div', {
      class: 'adi-path-wrap'
    });
    const domPathScrollLeft = newElement('span', {
      class: 'adi-path-left'
    });
    const domPathScrollRight = newElement('span', {
      class: 'adi-path-right'
    });
    this.menuView = newElement('div', {
      id: 'adi-panel'
    });
    const naviButtons = newElement('div', {
      class: 'adi-menu-wrap'
    });
    const naviConfig = newElement('a', {
      class: 'adi-menu-config',
      title: 'Settings'
    });
    const naviLookup = newElement('a', {
      class: 'adi-menu-lookup',
      title: 'Lookup tool'
    });

    // this.horizSplit = horizSplit;

    this.optsView = drawOptions();

    // put UI together
    domViewContent.appendChild(domTree);
    this.domView.appendChild(this.menuView);
    this.domView.appendChild(domViewContent);
    domPathWrap.appendChild(domPathScrollLeft);
    domPathWrap.appendChild(domPathScrollRight);
    naviButtons.appendChild(naviLookup);
    naviButtons.appendChild(naviConfig);
    this.menuView.appendChild(domPathWrap);
    this.menuView.appendChild(naviButtons);
    // this.uiView.appendChild(this.menuView);
    this.uiView.appendChild(this.optsView);
    this.uiView.appendChild(this.domView);
    if (!this.isInstanceViewer) {
      this.attrView = newElement('div', {
        id: 'adi-attr-view'
      });
      const attrViewContent = newElement('div', {
        class: 'adi-content'
      });
      this.attrView.appendChild(attrViewContent);
      this.uiView.appendChild(this.attrView);
    }

    // this.uiView.appendChild(horizSplit);
    // wrapper.appendChild(naviWrap);

    // cache UI object and append to the DOM

    rootElement.appendChild(this.uiView);
    // document.querySelector('#inspector').appendChild(wrapper);

    this.refreshUI(true);
  }

  // Refreshes the global UI
  refreshUI(refreshOpts) {
    if (this.uiView === null) {
      return;
    }

    // load options if requested (e.g. before the first UI refresh)
    if (refreshOpts) {
      this.loadOptions();
    }

    // Options view refresh
    if (refreshOpts) {
      this.optsView.querySelector('[data-opt="transparent"]').checked = this.options.transparent;
      this.optsView.querySelector('[data-opt="saving"]').checked = this.options.saving;
      this.optsView.querySelector('[data-opt="omitEmptyText"]').checked = this.options.omitEmptyText;
      this.optsView.querySelector('[data-opt="makeVisible"]').checked = this.options.makeVisible;
      this.optsView.querySelector('[data-opt="foldText"]').checked = this.options.foldText;
      this.optsView.querySelector('[data-opt="nodeTypes-3"]').checked = this.options.nodeTypes.indexOf(3) !== -1;
      this.optsView.querySelector('[data-opt="nodeTypes-8"]').checked = this.options.nodeTypes.indexOf(8) !== -1;
      // this.optsView.querySelector('[data-opt="nodeTypes-1"]').checked = this.options.nodeTypes.indexOf(1) !== -1;
      // this.optsView.querySelector('[data-opt="nodeTypes-9"]').checked = this.options.nodeTypes.indexOf(9) !== -1;
    }

    // UI appearance refresh
    this.uiView.className = this.options.transparent ? 'transparent' : '';
    // this.uiView.style.display = this.options.visible ? 'grid' : 'none';
    // this.domView.style.height = `${this.options.split}%`;
    // this.attrView.style.height = `${100 - this.options.split}%`;
    this.domView.querySelector('.adi-content').style.height = `${this.domView.clientHeight}px`;
    if (!this.isInstanceViewer) {
      this.attrView.querySelector('.adi-content').style.height = `${this.attrView.clientHeight - this.menuView.clientHeight}px`;
    }
    addClass(this.uiView, this.options.align);
  }

  // UI visibility toggle handler
  toggleVisibilityUI() {
    if (this.uiView === null) {
      return;
    }
    this.uiView.style.display = this.options.visible ? 'none' : 'block';
    this.options.visible = !this.options.visible;
    this.saveOptions();
  }

  // Renders the attribute view
  drawAttrs(elem) {
    if (this.isInstanceViewer) {
      return;
    }
    const content = this.attrView.querySelector('.adi-content');
    // prepare attributes
    content.innerHTML = '';
    const header = document.createElement('header');
    header.innerText = 'Attributes';
    content.appendChild(header);

    // todo: hook element-def.json in here
    /*
        if (elem.nodeName.startsWith('FX-')) {
            console.log('got a fore element');
            const {properties} = elem.constructor;
            Object.keys(properties).forEach(propertyName => {
                 const property = properties[propertyName];
                if (!property || property.hidden) {
                    return;
                }
                const row = content.appendChild(newElement('span', {class: 'adi-attr'}));
                 switch (property.type) {
                    case 'referencedNode': {
                        row.innerHTML = `<label>${propertyName}: <button>${elem[propertyName]?.nodeName}</button></label>`;
                        const button = row.querySelector('button');
                        button.addEventListener(
                            'click', () => this.handleLookup({detail: {target: elem[propertyName]}})
                        );
                        break;
                    }
                    case Number: {
                        row.innerHTML = `<label>${propertyName}: <input type="number" data-attr="${propertyName}" value="${elem[propertyName]}"></label>`;
                        break;
                    }
                    case String: {
                        if (property.valueSpace) {
                            row.innerHTML = `<label>${propertyName}: <select data-attr="${propertyName}" value="${elem[propertyName]}">${property.valueSpace.map(value => `<option>${value}</option>`)}</label>`;
                            break;
                         }
                        row.innerHTML = `<label>${propertyName}: <input type="text" data-attr="${propertyName}" value="${elem[propertyName]}"></label>`;
                        break;
                    }
                    case Boolean: {
                        if (property.valueSpace) {
                            row.innerHTML = `<label>${propertyName}: <input type="checkbox" data-attr="${propertyName}" value="${elem[propertyName]}"></input></label>`;
                         }
                        break;
                    }
                    case Object: {
                        try {
                            row.innerHTML = `<label>${propertyName}: <code>${JSON.stringify(elem[propertyName])}</code></label>`;
                        } catch (err) {
                            row.innerHTML = `<label>${propertyName}: <code>Unserializable</code></label>`;
                        }
                        break;
                    }
                    case Map: {
                        try {
                            row.innerHTML = `<label>${propertyName}: <code>${JSON.stringify(elem[propertyName])}</code></label>`;
                        } catch (err) {
                            row.innerHTML = `<label>${propertyName}: <code>Unserializable</code></label>`;
                        }
                        break;
                    }
                    default: {
                        row.innerHTML = `<label>${propertyName}: Unknown type ${property.type}</label>`;
                    }
                }
            });
        } else {
    */
    [...elem.attributes].forEach(attr => {
      if (attr.name !== 'style') {
        content.appendChild(drawAttrRow(attr.name, attr.value));
      }
    });
    // }
  }

  // Handles attribute changes
  changeAttribute(e) {
    const target = e ? e.target : window.event.srcElement;
    const attr = target.getAttribute('data-attr');
    const val = target.value;
    const elem = this.getSelected();

    // remove attribute if the new value is empty
    if (val === '') {
      elem.removeAttribute(attr);
    } else {
      elem.setAttribute(attr, val);
    }
  }

  // Handles option changes
  changeOption(e) {
    const target = e ? e.target : window.event.srcElement;
    const data = target.getAttribute('data-opt');
    const val = target.checked;
    if (data.indexOf('nodeTypes') !== -1) {
      const type = parseInt(data.match(/\d+/)[0], 10);
      if (val) {
        this.options.nodeTypes.push(type);
      } else {
        this.options.nodeTypes.splice(this.options.nodeTypes.indexOf(type), 1);
      }
    } else {
      this.options[data] = val;
    }
  }

  // Key events processing
  processKey(e) {
    e = e || window.event;
    const code = e.keyCode || e.which;
    switch (code) {
      case 272:
        // ctrl + alt + d
        this.toggleVisibilityUI();
        break;
    }
  }

  // Vertical splitter resize handler
  verticalResize(e) {
    if (!this.vertResizing) {
      return;
    }
    e = e || window.event;
    document.documentElement.style.cursor = 'e-resize';
    const nWidth = this.options.width + this.xPos - e.clientX;
    if (nWidth >= this.options.minWidth) {
      this.options.width = nWidth;
      this.xPos = e.clientX;
      this.refreshUI();
      this.saveOptions();
    }
  }

  // Horizontal splitter resize handler
  horizontalResize(e) {
    if (!this.horizResizing) {
      return;
    }
    e = e || window.event;
    document.documentElement.style.cursor = 'n-resize';
    const nSplit = Math.floor(e.clientY / this.uiView.clientHeight * 100);
    if (nSplit >= this.options.minSplit && nSplit <= 100 - this.options.minSplit) {
      this.options.split = nSplit;
      this.refreshUI();
      this.saveOptions();
    }
  }
  processExecuteAction(e) {
    this.refreshUI();
  }

  // Handles active element selection
  handleActive(e) {
    let target = e ? e.detail?.target || e.target : window.event.srcElement;
    const active = this.domView.querySelector('.adi-active-node');
    if (active) {
      removeClass(active, 'adi-active-node');
    }

    // clicked on normal-node or end-node?
    if (!target || target.nodeType === Node.DOCUMENT_NODE) return;
    if (target && target.classList && target.classList.contains('adi-end-node')) {
      target = target.parentNode.querySelector('.adi-normal-node');
    }
    this.activeElement = target;
    addClass(target, 'adi-active-node');

    /*
        e.target.dispatchEvent(
            new CustomEvent('handle-active', {
                composed: true,
                bubbles: true,
                detail: {active: this.activeElement, selected: this.getSelected()},
            }),
        );
    */

    // make it visible (scroll)
    if (this.options.makeVisible) {
      const wrap = this.domView.querySelector('.adi-content');
      wrap.scrollIntoView({
        block: 'center',
        behavior: 'instant'
      });
    }
    const selected = this.getSelected();
    this.drawAttrs(selected);
    if (selected && typeof selected.getModelItem === 'function' && selected.getModelItem()?.node) {
      let selectedElement = selected.modelItem.node;
      if (selectedElement?.nodeType === Node.ATTRIBUTE_NODE) {
        selectedElement = selectedElement.ownerElement;
      }
      window.document.dispatchEvent(new CustomEvent('log-active-element', {
        detail: {
          target: selectedElement
        }
      }));
    }
    //	window.document.dispatchEvent(new CustomEvent('log-active-element', {detail: {target: selected}}));
  }

  // Highlights an element on page
  highlightElement(event) {
    // console.log('highlight',e);
    let sourceNode = event ? event.target : window.event.srcElement;
    if (sourceNode.classList.contains('adi-end-node')) {
      sourceNode = sourceNode.parentNode.querySelector('.adi-normal-node');
    }
    const inspectorNode = this.sourceNodeByInspectorNodeLookup.get(sourceNode);
    if (!inspectorNode || inspectorNode.ownerDocument !== window.document) {
      // Not in HTML: ignore
      return;
    }
    if (inspectorNode) {
      if (event.type === 'mouseover') {
        this.styleBackup = inspectorNode.getAttribute('style') || '';
        inspectorNode.setAttribute('style', `outline: 2px solid blue; ${this.styleBackup}`);
      } else if (this.styleBackup === '') {
        inspectorNode.removeAttribute('style');
      } else {
        inspectorNode.setAttribute('style', this.styleBackup);
      }
    }
  }

  // Handles element lookup on page
  handleLookup(e) {
    const target = e ? e.detail?.target || e.target : window.event.srcElement;
    if (!this.document.contains(target)) {
      // Targetted at somewhere else!!!
      return;
    }
    if (target.nodeType === Node.DOCUMENT_NODE) {
      // Targetted at the document node. Nothing to highlight
      return;
    }
    if (target.className.indexOf('adi-menu-lookup') !== -1) {
      // enable/disable interactive lookup
      if (this.elemLookup) {
        removeClass(target, 'adi-active');
        this.elemLookup = false;
        this.removeEvent(document.body, 'mouseover', this.handleLookup, true);
        this.removeEvent(document.body, 'mouseout', this.handleLookup, true);
        this.removeEvent(document.body, 'click', this.handleLookup, true);
        return;
      }
      addClass(target, 'adi-active');
      this.elemLookup = true;
      this.addEventDelegate(document.body, 'mouseover', this.handleLookup, false, '*', true, 'adi-wrapper');
      this.addEventDelegate(document.body, 'mouseout', this.handleLookup, false, '*', true, 'adi-wrapper');
      this.addEventDelegate(document.body, 'click', this.handleLookup, false, '*', true, 'adi-wrapper');
      return;
    }
    // handle lookup events
    if (e.type === 'mouseover') {
      this.styleBackup = target.getAttribute('style') || '';
      target.setAttribute('style', `outline: 1px dashed red; ${this.styleBackup}`);
      return;
    }
    if (e.type === 'mouseout') {
      target.setAttribute('style', this.styleBackup);
      return;
    }
    this.elemLookup = false;
    removeClass(this.menuView.querySelector('.adi-menu-lookup'), 'adi-active');
    target.setAttribute('style', this.styleBackup);
    this.removeEvent(document.body, 'mouseover', this.handleLookup, true);
    this.removeEvent(document.body, 'mouseout', this.handleLookup, true);
    this.removeEvent(document.body, 'click', this.handleLookup, true);
    pauseEvent(e);

    // find corresponding node in the DOM view
    const active = this.sourceNodeByInspectorNodeLookup.get(target);

    // activate it
    if (!active) return;
    if (active) {
      active.click();
    }

    // open the whole path in DOM view
    if (!active.parentNode) return;
    let node = active.parentNode;
    let tmp;
    if (node.querySelector('ul')) {
      node.querySelector('ul').setAttribute('data-open', 'true');
    }
    while (node !== this.domView.querySelector('.adi-content')) {
      if (node.className.indexOf('adi-node') !== -1) {
        tmp = node.querySelector('.adi-trigger');
        if (tmp) {
          removeClass(tmp, 'closed');
          addClass(tmp, 'opened');
        }
        node = node.parentNode; // ul node
        node.setAttribute('data-open', 'true');
      }
      node = node.parentNode;
    }

    // make it visible (scroll)
    if (this.options.makeVisible) {
      active.scrollIntoView({
        behavior: 'instant',
        block: 'nearest',
        inline: 'nearest'
      });
    }
    target.scrollIntoView({
      behavior: 'instant',
      block: 'nearest',
      inline: 'nearest'
    });
  }

  // Simple cross-browser event handler that enables simple event delegation.
  // Note that the selector must be a string and no nesting is supported.
  // Selector is expected to be in one of formats listed below and works for all children
  // in the particular element.
  // Store parameter enables storing the reference to custom event handler.
  // Exclude parameter will exclude the particular element and all of its children, this works
  // only for id selectors.
  // Selector formats: tag name ("div"), class name (".my-class"), id ("#my-id") and any ("*").

  addEventDelegate(elem, evt, fn, capture, selector, store, exclude) {
    // custom event handler is registered
    const handler = e => {
      // check if target corresponds to the selector
      const target = e ? e.target : window.event.srcElement;
      const sel = selector.substr(1);
      let delegate = false;
      if (exclude) {
        let node = target;
        while (node !== document) {
          if (node.id === exclude) {
            return;
          }
          node = node.parentNode;
        }
      }

      // should the event be delegated?
      if (selector.indexOf('#') === 0) {
        // ID
        delegate = target.id === sel;
      } else if (selector.indexOf('.') === 0) {
        // class
        delegate = target.className.indexOf(sel) !== -1;
      } else if (selector === '*') {
        // any
        delegate = true;
      } else {
        // tag name
        delegate = target.nodeName.toLowerCase() === selector;
      }

      // delegate the event handling
      if (delegate) {
        fn(e);
      }
    };
    // save the reference
    if (store) {
      this.delegatedEvents.push({
        handle: handler,
        elem,
        fn,
        evt
      });
    }
    elem.addEventListener(evt, handler, capture);
  }

  // Simple cross-browser event removing
  removeEvent(elem, evt, fn, wasDelegated) {
    if (typeof elem !== 'object') {
      throw new Error(`addEvent: Expected argument elem of type object, ${typeof elem} given.`);
    }

    // try to find stored delegated event
    let stored = null;
    if (wasDelegated) {
      for (let i = 0, len = this.delegatedEvents.length; i < len; i += 1) {
        stored = this.delegatedEvents[i];
        if (stored.elem === elem && stored.evt === evt && stored.fn === fn) {
          fn = stored.handle;
          this.delegatedEvents.splice(i, 1);
          break;
        }
      }
    }

    // elem.detachEvent(`on${evt}`, fn);
  }

  // Event registration
  registerEvents() {
    // events for splitters
    /*
                this.horizSplit.addEventListener(
                    'mousedown',
                    e => {
                        e = e || window.event;
                        pauseEvent(e);
                        this.horizResizing = true;
                    },
                    false,
                );
        */

    const redrawUi = () => {
      if (this.instanceId !== '#document') {
        const instance = window.document.querySelector(`#${this.instanceId}`);
        this.document = instance.getInstanceData();
      }
      this.drawDOM(this.document, this.domView.querySelector('.adi-tree-view'), true);
    };

    // Update UI when something with instances changed
    document.addEventListener('instance-loaded', redrawUi);
    // Update UI when some value changes
    document.addEventListener('value-changed', redrawUi);
    // Update UI when we're done loading and all repeats are done
    document.addEventListener('ready', redrawUi);
    document.addEventListener('mouseup', () => {
      document.documentElement.style.cursor = 'default';
      this.vertResizing = false;
      this.horizResizing = false;
    }, false);
    document.addEventListener('mousemove', event => this.verticalResize(event), false);
    document.addEventListener('mousemove', event => this.horizontalResize(event), false);
    // window resize
    window.addEventListener('resize', event => this.refreshUI(event), false);

    // keypress events
    document.addEventListener('keypress', event => this.processKey(event), false);

    // fore action events
    document.addEventListener('log-active-element', event => this.handleLookup(event), false);

    // Dom view folding handler
    const handleFolding = e => {
      const target = e ? e.target : window.event.srcElement;
      const ul = target.parentNode.querySelector('ul');
      if (ul.getAttribute('data-open') === 'true') {
        removeClass(target, 'opened');
        addClass(target, 'closed');
        ul.setAttribute('data-open', 'false');
      } else {
        removeClass(target, 'closed');
        addClass(target, 'opened');
        ul.setAttribute('data-open', 'true');
      }
    };

    // dom tree view folding
    this.addEventDelegate(this.domView, 'click', handleFolding, false, '.adi-trigger');

    // active element
    this.addEventDelegate(this.domView, 'click', event => this.handleActive(event), false, '.adi-normal-node');
    this.addEventDelegate(this.domView, 'click', event => this.handleActive(event), false, '.adi-end-node');

    // matching tag highlighting
    this.addEventDelegate(this.domView, 'mouseover', e => {
      const target = e ? e.target : window.event.srcElement;
      addClass(target.parentNode.querySelector('.adi-normal-node'), 'hover');
    }, false, '.adi-end-node');
    this.addEventDelegate(this.domView, 'mouseout', e => {
      const target = e ? e.target : window.event.srcElement;
      removeClass(target.parentNode.querySelector('.adi-normal-node'), 'hover');
    }, false, '.adi-end-node');

    // page element highlighting
    this.addEventDelegate(this.domView, 'mouseover', event => this.highlightElement(event), false, '.adi-end-node');
    this.addEventDelegate(this.domView, 'mouseover', event => this.highlightElement(event), false, '.adi-normal-node');
    this.addEventDelegate(this.domView, 'mouseout', event => this.highlightElement(event), false, '.adi-end-node');
    this.addEventDelegate(this.domView, 'mouseout', event => this.highlightElement(event), false, '.adi-normal-node');

    // element lookup
    this.menuView.querySelector('.adi-menu-lookup').addEventListener('click', event => this.handleLookup(event), false);
    document.addEventListener('handle-active', e => {
      if (e.detail.selected === this.getSelected()) {
        // We caused this. ignore
        return;
      }
      const {
        selected
      } = e.detail;
      const target = this.sourceNodeByInspectorNodeLookup.get(selected);
      // make it visible (scroll)
      if (this.options.makeVisible) {
        const wrap = this.domView.querySelector('.adi-content');
        if (target.offsetTop >= wrap.clientHeight || target.offsetTop <= wrap.scrollTop) {
          wrap.scrollTop = target.offsetTop - Math.floor(wrap.clientHeight / 2);
        }
      }
      this.drawAttrs(this.getSelected());
    });
    document.addEventListener('execute-action', e => this.processExecuteAction(event), {
      capture: true
    });

    // options events
    this.addEventDelegate(this.optsView, 'change', event => this.changeOption(event), false, 'input');
    this.addEventDelegate(this.optsView, 'click', event => this.toggleOptions(event), false, '.adi-opt-close');
    this.menuView.querySelector('.adi-menu-config').addEventListener('click', event => this.toggleOptions(event), false);

    // attributes events
    if (!this.isInstanceViewer) {
      this.addEventDelegate(this.attrView, 'change', this.changeAttribute, false, 'input');
    }
  }
}

class FxDomInspector extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.instanceName = null;
    this.instance = null;
  }
  connectedCallback() {
    this.render();
    if (this.instance) {
      this.shadowRoot.querySelector('#focus-button').style = 'display: none';
    } else {
      this.setupFocusButton();
    }
  }
  setInstance(instance) {
    this.instance = instance;
  }
  disconnectedCallback() {
    this.adiInstance = null;
  }
  setupFocusButton() {
    let styleBackup = '';
    let focusedElement = null;
    const removeFocus = () => {
      if (styleBackup === '') {
        focusedElement.removeAttribute('style');
      } else {
        focusedElement.setAttribute('style', styleBackup);
      }
      focusedElement = null;
    };
    const onHover = event => {
      const {
        target
      } = event;
      if (event.type === 'mouseover') {
        styleBackup = target.getAttribute('style') || '';
        target.setAttribute('style', `outline: 2px solid blue; ${styleBackup}`);
        focusedElement = target;
        return;
      }
      if (focusedElement) {
        removeFocus();
      }
    };
    const focusButton = this.shadowRoot.querySelector('#focus-button');
    let isFocussing = false;
    const styleElement = window.document.head.appendChild(document.createElement('style'));
    const stopFocussing = () => {
      isFocussing = false;
      window.document.body.removeEventListener('click', listener);
      focusButton.classList.remove('selected-btn');
      styleElement.innerHTML = '';
      document.body.style.cursor = 'auto';
      window.document.body.removeEventListener('mouseover', onHover);
      window.document.body.removeEventListener('mouseout', onHover);
      if (focusedElement) {
        removeFocus();
      }
    };
    const listener = event => {
      stopFocussing();
      event.preventDefault();
      event.stopPropagation();
      if (event.target !== focusButton) {
        // Do not 'click on the focusbutton. It's a cancel.
        // console.log('done', event.target);
        window.document.dispatchEvent(new CustomEvent('log-active-element', {
          detail: {
            target: event.target
          }
        }));
      }
    };
    const startFocussing = () => {
      isFocussing = true;
      focusButton.classList.add('selected-btn');
      document.body.style.cursor = 'crosshair';
      window.document.body.removeEventListener('click', listener);
      styleElement.innerHTML = 'fx-fore::before { color:blue; content: "Sub fore!" } fx-fore {border: solid 1px blue}';
      window.document.body.addEventListener('click', listener);
      window.document.body.addEventListener('mouseover', onHover);
      window.document.body.addEventListener('mouseout', onHover);
    };
    window.document.addEventListener('keyup', event => {
      if (isFocussing && event.code === 'Escape') {
        stopFocussing();
        return;
      }
      if (!isFocussing && event.code === 'KeyI' && event.ctrlKey) {
        startFocussing();
      }
    });
    focusButton.addEventListener('click', clickEvent => {
      if (isFocussing) {
        stopFocussing();
      } else {
        startFocussing();
      }
      clickEvent.preventDefault();
      clickEvent.stopPropagation();
    });
  }
  render() {
    const style = `
      @import '../../resources/fore.css';
      
        :host {
          display:block;
          background:transparent;
        }
        body {
            -webkit-animation: bugfix infinite 1s;
            font-size:1rem;
        }
        
        @-webkit-keyframes bugfix {
            from {
                padding: 0
            }
            to {
                padding: 0
            }
        }
        .adi-content {
            position: relative;
            overflow: auto;
            box-sizing: border-box;
            -moz-box-sizing: border-box;
            height: 100% !important;
            padding:0;
            font-size:0.8em;
        }
        .adi-content header{
            padding:0.5rem;
            // background:rgba(255, 255, 255, 0.2);
            border-bottom:2px solid #ddd;
            border-collapse:collapse;
        }
        .adi-content > * {
            padding:0 0.25em;
        }
        
        #adi-wrapper {
            top: 0;
            font-family: "Segoe UI", Arial;
            font-size: 1.1rem;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            position:relative;
            height:calc(100% - 8rem);
            display:flex;
        }
        
        #adi-wrapper.left {
            left: 0
        }
        
        #adi-wrapper.right {
            right: 0
        }
        
        #adi-wrapper.transparent {
            background: rgba(250, 250, 250, 0.9)
        }
        
        #adi-panel {
            position:fixed;
            top:0;
            /*bottom: 0;*/
            right: 0;
            height: 24px;
            background: #d4d4d4;
            border-top: 1px solid #bbc5c9
        }
        
        #adi-panel .adi-path-wrap {
            position:absolute;
            bottom: 0;
            left: 0;
            width: 80%;
            height: 24px;
            padding: 0 13px 0 18px;
            line-height: 24px;
            overflow: hidden;
            box-sizing: border-box;
            -moz-box-sizing: border-box
        }
        
        #adi-panel .adi-path-wrap.adi-overflowing .adi-path-left, 
        #adi-panel .adi-path-wrap.adi-overflowing .adi-path-right {
            display: block
        }
        
        #adi-panel .adi-path {
            height: 24px;
            overflow: hidden;
            white-space: nowrap
        }
        
        #adi-panel .adi-path-left, #adi-panel .adi-path-right {
            display: none;
            position: absolute;
            top: 0;
            width: 8px;
            height: 24px;
            background-repeat: no-repeat;
            background-position: center center;
            opacity: .7
        }
        
        #adi-panel .adi-path-left:hover, #adi-panel .adi-path-right:hover {
            opacity: 1
        }
        
        #adi-panel .adi-path-left {
            left: 7px;
            background-image: url('img/left_shift.png')
        }
        
        #adi-panel .adi-path-right {
            position:absolute;
            right: 2px;
            background-image: url('/resources/scripts/dom-inspector/img/right_shift.png')
        }
        
        #adi-panel .adi-menu-wrap {
            bottom: 0;
            right: 24px;
            width: 50px;
            height: 24px
        }
        
        #adi-panel .adi-menu-lookup, #adi-panel .adi-menu-config {
            display: block;
            float: left;
            width: 24px;
            height: 24px;
            border-left: 1px solid #bbc5c9;
            background-position: center center;
            background-repeat: no-repeat;
            opacity: .7;
            border-radius: 0
        }
        
        #adi-panel .adi-menu-lookup:hover, #adi-panel .adi-menu-config:hover {
            background-color: #c5d9d8;
            opacity: 1
        }
        
        #adi-panel .adi-menu-lookup.adi-active, #adi-panel .adi-menu-config.adi-active {
            background-color: #fafafa;
            opacity: 1
        }
        
        #adi-panel .adi-menu-lookup {
            background-image: url('/resources/scripts/dom-inspector/img/lookup.png')
        }
        
        #adi-panel .adi-menu-config {
            background-image: url('/resources/scripts/dom-inspector/img/config.png')
        }
        
        
        
        #adi-vert-split {
            position: fixed;
            top: 0;
            width: 4px;
            height: 100%;
            cursor: e-resize;
            border-width: 0 1px 0 0;
            background: #bbc5c9;
            border-color: #768285;
            border-style: solid;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #adi-vert-split:hover {
            background: #c5d9d8;
        }
        
        
        #adi-dom-view {
            border-right:2px solid #ddd;
            overflow:auto;
            flex-grow:3;
        }
        
        #adi-dom-view ul {
            margin: 0;
            padding: 0;
            list-style: none
        }
        
        #adi-dom-view ul[data-open=true] {
            display: block
        }
        
        #adi-dom-view ul[data-open=false] {
            display: none
        }
        
        #adi-dom-view ul ul {
            margin: 4px 0
        }
        
        #adi-dom-view ul li {
            padding-left: 1em;
            padding-bottom: 0.125em;
            margin: 0;
            padding-top: 0.125em;        
        }
        
        
        
        
        
        
        
        #adi-dom-view .adi-normal-node, 
        #adi-dom-view .adi-end-node {
            margin-right: 5px;
            padding: 0 6px 0px;
            background: #d2e8ff;
            border-radius: 8px;
            cursor: default;
            font-size:0.8rem;
        }
        #adi-dom-view .adi-text-node:after, #adi-dom-view .adi-comment-node:after {
            content: '"'
        }
        
        #adi-dom-view .adi-text-node:before, #adi-dom-view .adi-comment-node:before {
            content: '"'
        }
        
        #adi-dom-view .adi-comment-node {
            color: #999;
            font-style: italic
        }
        
        #adi-dom-view .adi-text-node, #adi-dom-view .adi-comment-node {
            display: block;
            padding: 3px 8px;
            color: #444;
            background: #fff;
            border-radius: 8px
        }
        
        #adi-dom-view .adi-normal-node:hover, 
        #adi-dom-view .adi-normal-node.hover, 
        #adi-dom-view .adi-end-node:hover, 
        #adi-dom-view .adi-end-node.hover {
            background: var(--paper-grey-700);
            color:white;
        }
        
       #adi-dom-view .adi-normal-node:hover ~ span,
       #adi-dom-view .adi-normal-node.hover ~ span,
       #adi-dom-view .adi-end-node:hover ~ span,
       #adi-dom-view .adi-end-node.hover ~ span {
            background: var(--paper-grey-700);
            color:white;
        }
        
        #adi-dom-view .adi-normal-node.adi-active-node, 
        #adi-dom-view .adi-end-node.adi-active-node {
            background: var(--paper-grey-700);
            color:white;
        }
        
        #adi-dom-view .adi-normal-node.adi-active-node ~ span,
        #adi-dom-view .adi-end-node.adi-active-node ~ span {
            background: var(--paper-grey-700);
            color:white;
        }
        
        
        
        
        
        
        #adi-dom-view .adi-trigger {
            display: inline-block;
            width: 10px;
            height: 10px;
            margin: 0 5px 0 -13px;
            opacity: .7
        }
        
        #adi-dom-view .adi-trigger.closed {
            // background: url('/resources/scripts/dom-inspector/img/node_closed.png') no-repeat;
        }   
        #adi-dom-view .adi-trigger.closed::before {
            content:'\\25B8';
        }
        
        #adi-dom-view .adi-trigger.opened {
            // background: url('/resources/scripts/dom-inspector/img/node_opened.png') no-repeat
        }
        #adi-dom-view .adi-trigger.opened::before{
            content:'\\25BE';
        }
        
        #adi-dom-view .adi-trigger:hover {
            opacity: 1
        }
        
        #adi-opts-view {
            position: relative;
            height: 100%;
            padding: 0 15px;
            background: #fff
        }
        
        #adi-opts-view.adi-hidden {
            display: none
        }
        
        #adi-opts-view .adi-opt-heading, #adi-opts-view .adi-opt {
            display: block;
            padding: 5px 0
        }
        
        #adi-opts-view .adi-opt-heading {
            padding: 20px 0 10px;
            font-size: 1rem;
        }
        
        #adi-opts-view .adi-opt-heading:first-child {
            padding-top: 10px
        }
        
        #adi-opts-view .adi-opt input {
            margin-right: 6px
        }
        
        #adi-opts-view .adi-opt-close {
            position: absolute;
            top: 5px;
            right: 28px;
            width: 16px;
            height: 16px;
            background: url('/resources/scripts/dom-inspector/img/options_close.png') no-repeat;
            opacity: .7;
        }
        
        #adi-opts-view .adi-opt-close:hover {
            opacity: 1;
        }
        
        #adi-attr-view {
            top: 0.5rem;
            border: 1px solid #ddd;
            overflow: auto;
            padding: 0.25em;
            height: calc(90% - 1em);
            min-width: 10rem;
            position: absolute;
            z-index: 10;
            right: 0.5rem;
            background:rgba(255,255,255,0.85);
        }
        #adi-attr-view > .adi-content{
            height:calc(100% - 5em);
            overflow:auto;
        }
        
        #adi-attr-view .adi-attr {
            display: block;
            padding: 0.25em;
        }
        
        #adi-attr-view hr {
            height: 1px;
            border: none
        }
        
        #adi-attr-view input[type=text] {
            width: calc(100% - 0.5em);
            margin-top: 3px;
            padding: 2px;
        }
        
        #adi-horiz-split {
            height: 4px;
            cursor: n-resize;
            border-width: 0 0 1px 0;
            background: #bbc5c9;
            border-color: #768285;
            border-style: solid;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        #adi-horiz-split:hover {
            background: #c5d9d8;
        }
        
        #adi-dom-view .fore-node{
            background: var(--paper-blue-700);
            font-size:1.1em;
             color:white;
        }
        #adi-dom-view .adi-normal-node.fore-node:hover {
            background: var(--paper-grey-700);
            color:white;
        }
        #adi-dom-view .adi-end-node.fore-node{
            background: var(--paper-blue-700);
            font-size:1em;
            color:white;
       }

        #adi-dom-view .adi-node .adi-active-node.fore-node,
        #adi-dom-view .adi-node.action .adi-active-node.fore-node,
        #adi-dom-view .adi-node.action .adi-active-node.fore-node ~ .adi-end-node
         {
            background: var(--paper-grey-700);
            color:white;
        }
        
        #adi-dom-view .adi-node.fx-fore{
            background:var(--paper-blue-grey-50); 
        }
        #adi-dom-view .adi-node.fx-model{
            background:var(--paper-blue-grey-100); 
            padding:0.25em 0;
        }       
               
        #adi-dom-view .adi-node.action .fore-node {
            background:var(--paper-blue-grey-100);
            color:black;
            font-family:monospace;
        }
                    
        .toggleView{
            /*width:20px;*/
            /*height: 20px;*/
        }
        input, select{
            display: block;
        }
        header{
            background:rgba(255, 255, 255, 0.2);
        }

        .selected-btn { color: orange }
      `;
    const html = `
        <slot name="header"></slot>
        <button id="focus-button">Focus</button>
        <slot></slot>
      `;
    this.shadowRoot.innerHTML = `
          <style>
              ${style}
          </style>
          ${html}
      `;
    this.hasAttribute('instance') ? this.getAttribute('instance') : '#document';
    this.adiInstance = new ADI(this.shadowRoot, this.hasAttribute('instance') ? this.instance : '#document');
  }
  verticalResize(e) {
    if (!this.vertResizing) {
      return;
    }
    e = e || window.event;
    document.documentElement.style.cursor = 'e-resize';
    const nWidth = this.options.width + this.xPos - e.clientX;
    if (nWidth >= this.options.minWidth) {
      this.options.width = nWidth;
      this.xPos = e.clientX;
      this.refreshUI();
      this.saveOptions();
    }
  }
}
if (!customElements.get('fx-dom-inspector')) {
  customElements.define('fx-dom-inspector', FxDomInspector);
}

/**
 * A simple collapsible treeview for showing JSON data.
 *
 */
class FxJsonInstance extends HTMLElement {
  // constructor(container, options = {}) {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.instanceElement = null;
    this.foreSelector = null;
  }
  connectedCallback() {
    this.container = this.querySelector('.json-path-picker-container');
    this.foreSelector = this.hasAttribute('fore') ? this.getAttribute('fore') : 'fx-fore'; // default to first one in doc
    this.render();
  }
  render() {
    const style = `
        @import '../../resources/fore.css';
      
        :host {
          display:block;
          font-size:0.8em;
          background:rgba(250, 250, 250, 0.9);
        }
        .container{
            margin-left:1em;
        }
        .header{
            margin-left:0;
        }

        ::slot[name='header']{
            margin-left:-1em;
        }
        /* Syntax highlighting for JSON objects */
        ul.json-dict, ol.json-array {
          list-style-type: none;
          margin: 0 0 0 1px;
          border-left: 1px dotted #ccc;
          padding-left: 2em;
        }
        .json-string {
          // color: #0B7500;
        }
        .json-literal {
          color: #1A01CC;
          font-weight: bold;
        }
        
        /* Toggle button */
        a.json-toggle {
          position: relative;
          color: inherit;
          text-decoration: none;
        }
        a.json-toggle:focus {
          outline: none;
        }
        a.json-toggle:before {
          content: "\\25BC"; /* down arrow */
          position: absolute;
          display: inline-block;
          width: 1em;
          left: -1.2em;
          font-size:0.8em;
        }
        a.json-toggle.collapsed:before {
          content: "\\25B6"; /* left arrow */
        }
        
        /* Collapsable placeholder links */
        a.json-placeholder {
          color: #aaa;
          padding: 0 1em;
          text-decoration: none;
        }
        a.json-placeholder:hover {
          text-decoration: underline;
        }
        
        /* Copy path icon */
        .pick-path {
          color: lightgray;
          cursor: pointer;
          margin-left: 3px;
        }
        
        .pick-path:hover {
          color: darkgray;
        }
        
      `;
    const instanceId = this.hasAttribute('instance') ? this.getAttribute('instance') : 'default';
    const fore = document.querySelector(this.foreSelector);
    if (!fore) {
      throw new Error(`this '${this.foreSelector}' does not match a fx-fore element`);
    }
    const html = `
          <div class="container"></div>
      `;
    this.shadowRoot.innerHTML = `
          <style>
              ${style}
          </style>
          <slot name="header">
            <header class="header">${instanceId}</header>
          </slot>
          <slot></slot>
          ${html}
      `;

    // fore.addEventListener('ready', e => {

    const instanceElement = document.querySelector(`#${instanceId}`);
    if (!instanceElement || instanceElement.nodeName !== 'FX-INSTANCE' || instanceElement.getAttribute('type') !== 'json') {
      throw new Error(`this '${instanceId}' does not match an fx-instance element or is not of type JSON`);
    }
    const container = this.shadowRoot.querySelector('.container');
    const json = instanceElement.instanceData;
    let tree = this.json2html(json, {
      outputWithQuotes: true
    });
    if (this.isCollapsable(json)) tree = '<a href=\'#\' class="json-toggle"></a>'.concat(tree); // Insert HTML in target DOM element

    container.innerHTML = tree;
    const toggles = this.shadowRoot.querySelectorAll('.json-toggle');
    toggles.forEach(toggle => {
      toggle.addEventListener('click', this._handleToggleEvent.bind(this));
    });
    // container.addEventListener('click', (event) => this._handleToggleEvent);
    // });
  }

  disconnectedCallback() {}
  _isHidden(elem) {
    const width = elem.offsetWidth;
    const height = elem.offsetHeight;
    return width === 0 && height === 0 || window.getComputedStyle(elem).display === 'none';
  }
  _handleToggleEvent(event) {
    // Change class
    // event.preventDefault();
    // event.stopPropagation();

    const elm = event.target;
    elm.classList.toggle('collapsed'); // Fetch every json-dict and json-array to toggle them

    const subTarget = this._siblings(elm, 'ul.json-dict, ol.json-array', el => {
      el.style.display = el.style.display === '' || el.style.display === 'block' ? 'none' : 'block';
    }); // ForEach subtarget, previous siblings return array so we parse it

    for (let i = 0; i < subTarget.length; i += 1) {
      if (!this._isHidden(subTarget[i])) {
        // Parse every siblings with '.json-placehoder' and remove them (previous add by else)
        this._siblings(subTarget[i], '.json-placeholder', el => el.parentNode.removeChild(el));
      } else {
        // count item in object / array
        const childs = subTarget[i].children;
        let count = 0;
        for (let j = 0; j < childs.length; j += 1) {
          if (childs[j].tagName === 'LI') {
            count += 1;
          }
        }
        const placeholder = count + (count > 1 ? ' items' : ' item'); // Append a placeholder
        subTarget[i].insertAdjacentHTML('afterend', '<a href class="json-placeholder">'.concat(placeholder, '</a>'));
      }
    } // Prevent propagation

    event.stopPropagation();
    event.preventDefault();
  }
  _siblings(el, sel, callback) {
    const sibs = [];
    for (let i = 0; i < el.parentNode.children.length; i += 1) {
      const child = el.parentNode.children[i];
      if (child !== el && typeof sel === 'string' && child.matches(sel)) {
        sibs.push(child);
      }
    } // If a callback is passed, call it on each sibs

    if (callback && typeof callback === 'function') {
      for (let _i = 0; _i < sibs.length; _i += 1) {
        callback(sibs[_i]);
      }
    }
    return sibs;
  }
  json2html(json, options) {
    let html = '';
    if (typeof json === 'string') {
      // Escape tags
      const tmp = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      if (this.isUrl(tmp)) {
        html += '<a href="'.concat(tmp, '" class="json-string">').concat(tmp, '</a>');
      } else {
        html += '<span class="json-string">"'.concat(tmp, '"</span>');
      }
    } else if (typeof json === 'number') {
      html += '<span class="json-literal">'.concat(json, '</span>');
    } else if (typeof json === 'boolean') {
      html += '<span class="json-literal">'.concat(json, '</span>');
    } else if (json === null) {
      html += '<span class="json-literal">null</span>';
    } else if (json instanceof Array) {
      if (json.length > 0) {
        html += '[<ol class="json-array">';
        for (let i = 0; i < json.length; i += 1) {
          html += '<li data-key-type="array" data-key="'.concat(i, '">'); // Add toggle button if item is collapsable

          if (this.isCollapsable(json[i])) {
            html += '<a href="#" class="json-toggle"></a>';
          }
          html += this.json2html(json[i], options); // Add comma if item is not last

          if (i < json.length - 1) {
            html += ',';
          }
          html += '</li>';
        }
        html += '</ol>]';
      } else {
        html += '[]';
      }
    } else if (this._typeof(json) === 'object') {
      let keyCount = Object.keys(json).length;
      if (keyCount > 0) {
        html += '{<ul class="json-dict">';
        for (const key in json) {
          if (json.hasOwnProperty(key)) {
            html += '<li data-key-type="object" data-key="'.concat(key, '">');
            const keyRepr = options.outputWithQuotes ? '<span class="json-string">"'.concat(key, '"</span>') : key; // Add toggle button if item is collapsable

            if (this.isCollapsable(json[key])) {
              html += '<a href=\'#\' class="json-toggle">'.concat(keyRepr, '</a>');
            } else {
              html += keyRepr;
            }

            // ### keep the following comment for later - pick path is a good idea but needs to be adapted to XPath syntax
            // html += '<span class="pick-path" title="Pick path">&#10697;</span>';
            html += ': '.concat(this.json2html(json[key], options)); // Add comma if item is not last

            keyCount -= 1;
            if (keyCount > 0) {
              html += ',';
            }
            html += '</li>';
          }
        }
        html += '</ul>}';
      } else {
        html += '{}';
      }
    }
    return html;
  }
  isUrl(string) {
    const regexp = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#:.?+=&%@!\-/]))?/;
    return regexp.test(string);
  }
  _typeof(obj) {
    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
      this._typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      this._typeof = function _typeof(obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      };
    }
    return this._typeof(obj);
  }
  isCollapsable(arg) {
    return arg instanceof Object && Object.keys(arg).length > 0;
  }

  /*
    setup() {
        // Create shadow DOM
         // Add styles to shadow DOM
        const style = document.createElement('style');
        style.textContent = `
    /!* add your CSS styles here *!/
  `;
        shadowRoot.appendChild(style);
         // Move content to shadow DOM
        const container = this.container.cloneNode(true);
        shadowRoot.appendChild(container);
        this.container.remove();
        this.container = shadowRoot.querySelector('.json-path-picker-container');
        this.clearBtn = shadowRoot.querySelector('.json-path-picker-clear-btn');
        this.jsonTextarea = shadowRoot.querySelector('.json-path-picker-json');
        this.treeView = shadowRoot.querySelector('.json-path-picker-tree');
        this.resultView = shadowRoot.querySelector('.json-path-picker-result');
         const data = {
            "automobiles": [
                {
                    "maker": "Nissan",
                    "model": "Teana",
                    "year": 2000
                },
                {
                    "maker": "Honda",
                    "model": "Jazz",
                    "year": 2023
                },
                {
                    "maker": "Honda",
                    "model": "Civic",
                    "year": 2007
                },
                {
                    "maker": "Toyota",
                    "model": "Yaris",
                    "year": 2008
                },
                {
                    "maker": "Honda",
                    "model": "Accord",
                    "year": 2011
                }
            ],
            "motorcycles": [{
                "maker": "Honda",
                "model": "ST1300",
                "year": 2012
            }]
        }
         this.updateTree(JSON.stringify(data));
     }
  */

  static get observedAttributes() {
    return ['data'];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'data') {
      this.jsonTextarea.value = newValue;
      this.updateTree(newValue);
    }
  }
  updateTree(jsonString) {
    try {
      this.data = JSON.parse(jsonString);
      this.treeView.innerHTML = '';
      this.treeView.appendChild(this.createTreeView(this.data, ''));
    } catch (e) {
      console.error(e);
      alert('Invalid JSON');
    }
  }
  createTreeView(data, path) {
    const ul = document.createElement('ul');
    ul.classList.add('jp-ul');
    if (Array.isArray(data)) {
      data.forEach((item, index) => {
        const li = document.createElement('li');
        li.classList.add('jp-li');
        const newPath = `${path}[${index}]`;
        li.appendChild(this.createItemView(newPath, item));
        ul.appendChild(li);
      });
    } else if (typeof data === 'object' && data !== null) {
      Object.keys(data).forEach(key => {
        const li = document.createElement('li');
        li.classList.add('jp-li');
        const newPath = `${path}.${key}`;
        li.appendChild(this.createItemView(newPath, data[key]));
        ul.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.classList.add('jp-li');
      li.appendChild(this.createItemView(path, data));
      ul.appendChild(li);
    }
    return ul;
  }
}
if (!customElements.get('fx-json-instance')) {
  customElements.define('fx-json-instance', FxJsonInstance);
}

// import './fx-minimap.js';

class FxDevtools extends HTMLElement {
  static get properties() {
    return {
      fore: {
        type: Object,
        description: 'The fx-fore element the devtools are attached to'
      },
      instances: {
        type: Array,
        description: 'Instances of selected Fore element'
      },
      selector: {
        type: String,
        description: 'optional selector to attach to a certain fx-fore element with given id'
      }
    };
  }
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    Object.keys(this.constructor.properties).forEach(propertyName => {
      const property = this.constructor.properties[propertyName];
      const attribute = property.attribute || propertyName;
      const value = this.getAttribute(attribute) || property.default;
      const typedValue = property.type(value);
      this[propertyName] = typedValue;
    });
    this.isResizing = false;
    this.lastY = 0;
    this.defaultHeight = '40vh';
    this.buttonByInstanceId = new Map();
    const attachToFore = fore => {
      this.fore = fore;
      this.instances = [...this.fore.getModel().instances];
      // console.log('instances',this.instances);
      const header = this.shadowRoot.querySelector('.instances header');
      header.textContent = 'Data ';
      this.instances.forEach(instance => {
        const btn = document.createElement('button');
        btn.setAttribute('type', 'button');
        btn.textContent = instance.id;
        header.appendChild(btn);
        this.buttonByInstanceId.set(instance.id, btn);
        btn.addEventListener('click', () => this.selectInstance(instance.id));
      });
      if (!this.instances.length) {
        return;
      }
      this.selectInstance(this.instances[0].id);
    };
    const fore = document.querySelector('fx-fore');
    if (fore) {
      // If there's no `fore` element, there cannot be an inspector
      if (fore.inited) {
        // The fore element is already initialized. We can attach immediately.
        // This can happen if the fore element does not use anything asynchronous and loads right away.
        attachToFore(fore);
      } else {
        fore.addEventListener('model-construct-done', () => attachToFore(fore));
      }
    }
    window.document.addEventListener('log-active-element', e => {
      const target = e ? e.detail?.target || e.target : window.event.srcElement;

      // Note that the event target or srcElement may be the document node.
      const closestFore = target.nodeType === Node.DOCUMENT_NODE ? null : target.closest('fx-fore');
      if (closestFore) {
        attachToFore(closestFore);
      }
      const instance = this.instances.find(instance => {
        if (instance.type !== 'xml') {
          // TODO: handle JSON instances!
          return false;
        }
        return instance.instanceData.contains(target);
      });
      // const instance = this._getInstanceForTarget(target);

      if (instance) {
        this.selectInstance(instance.id);
      }
    });
  }
  _getInstanceForTarget(node) {
    this.instances.forEach(instance => {
      if (instance.type === 'xml' && instance.instanceData.contains(node)) {
        return instance;
      }
      if (instance.type === 'json') {
        return instance;
      }
    });
  }
  selectInstance(instanceId) {
    const button = this.buttonByInstanceId.get(instanceId);
    if (!button) {
      return;
    }
    if (button.classList.contains('selected-btn')) {
      return;
    }
    const selectedBtn = this.shadowRoot.querySelector('.selected-btn');
    if (selectedBtn) {
      selectedBtn.classList.remove('selected-btn');
    }
    button.classList.add('selected-btn');
    const instancePanel = this.shadowRoot.querySelector('.instance-panel');
    instancePanel.innerHTML = '';
    this.instances = [...this.fore.querySelectorAll('fx-instance')];
    const instance = Array.from(this.instances).find(inst => inst.id === instanceId);
    // console.log('wanted instance', instance);

    const panelContent = this._renderInstancePanel(instance);
    // console.log('panelContent', panelContent);
    // instancePanel.innerHTML = panelContent;
    instancePanel.append(panelContent);
  }
  connectedCallback() {
    this.render();
    // document.body.style.height = document.body.scrollHeight + 320 + 'px';
  }

  _startResize(event) {
    this.isResizing = true;
    this.lastY = event.clientY;
  }
  _resizePanel(event) {
    if (!this.isResizing) return;
    const delta = event.clientY - this.lastY;
    this.style.height = `${this.offsetHeight - delta}px`;
    this.lastHeight = this.style.height;
    this.lastY = event.clientY;
  }
  _stopResize(event) {
    event.preventDefault();
    event.stopPropagation();
    this.isResizing = false;
    document.body.style.height = 'inherit'; // reset before calculating scrollheight
    document.body.style.width = 'inherit'; // reset before calculating scrollheight
    const newHeight = document.body.scrollHeight + this.offsetHeight;
    document.body.style.height = `${newHeight}px`;
  }
  render() {
    const style = `
      @import '../../resources/fore.css';
      
        :host {
          display:block;
          position:fixed;
          bottom:0;
          left:0;
          width:100vw;
          height:var(--fx-devtools-height);
          font-style:inherit;
          font-family: 'Verdana' , 'Sans';
          font-size:1em;
          max-width:100vw;
          height:3em;
        }
        :host(.open){
            height:40vh;
        }
        
        fx-action-log{
            height:100%;
        }
        fx-dom-inspector{
            max-height:100%;
            height:100%;
            position:relative;
        }
        body {
        }
        details{
            height:100%;
            background:#ebf6ff;
        }
        .dom{
            width:45%;
            border-left:1px solid #999;
            position:relative
        }
        .dom fx-minimap{
            position:absolute;
            right:0;
            top:0;
            width:5rem;
            height:6rem;
        }
        header{
            padding:0.5rem;
            border-bottom:2px solid #ddd;
            font-size:1rem;
        }
        header button{
            margin:0 0.5em;
            border:thin solid #999;
            padding:0 0.5em;
            cursor:pointer;
        }
        header button:hover{
            background:white;
        }
        
        header button.selected-btn{
            background:steelblue;
            color:white;
        }
        .instances{
            width:35%;
            border-left:1px solid #999;
        }
        .instance-panel{
            height:100%;
            overflow:auto;
        }
        .panels{
            display:grid;
            grid-template-columns:20% 50% 30%;
            height:100%;
            width:100%;
            max-height:100%;
            border-top:thin solid #ddd;
        }
        .panels > section {
            min-height:20rem;
/*
            background:#efefef;
*/
            position:relative;
            display:inline-block;
            height:100%;
            width:auto;
        }
        #options{
            display:none;
        }
        #options.open{
            position:absolute;
            z-index:10;
            left:0;
            top:3em;
            height:100%;
            display:block;
            padding:0;
            background:rgba(255,255,255,0.95);
            width:100%;
        }
        .optionsBtn{
            font-size:2rem;
        }
        details[open] .optionsBtn{
            display:inline;
        }
        .resizer{
            width:100vw;
            height:6px;
            background:rgba(215,220,235,0.3);
            cursor: ns-resize;
            position:absolute;
            top:0;
            
        }
        summary{
            height:3rem;
            padding:0 1em;
            border-bottom:2px solid #ddd;
            display:flex;
            justify-content:space-between;
            align-items:center;
            color:rgba(0,0,0,0.7);
            background: rgba(235, 255, 255, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            
            color:white;
            font-weight:300;
                      background: rgb(119,119,119);
          background: linear-gradient(90deg, rgba(0,85,159,0.75) 0%, rgba(56,154,252,0.5) 50%, rgba(255,255,255,0.1) 100%);

        }
        summary button{
            padding:0;
            border:0;
            background:transparent;
        }
        .wrapper{
            height:100%;
        }
        .vertDevider{
            background:#ddd;
            width:4px;
            height:100%;
            cursor: ew-resize;
        }
      `;
    // console.log('render instances',this.instances);

    const html = `
        <section class="wrapper">
            <slot></slot>
            <details class="fx-devtools" open>
                <div class="resizer"></div>
                <summary>Fore Glass 
                    <div>
                        <svg preserveAspectRatio="xMidYMid meet" focusable="true" style="width: 24px;height: 24px; margin-bottom:-1px;" width="24px" height="24px" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg">
                            <g role="button" id="find-in-page"><path d="M20 19.59V8l-6-6H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L20 19.59zM9 13c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z"></path></g>
                        </svg>
                        <button class="optionsBtn" id="optionsTrigger">&#9881;</button>                    
                    </div>
                </summary>
                <section class="panels">
                    <section class="log">
                        <fx-action-log selector="${this.selector}"></fx-action-log>
                    </section>
                    <section class="dom">
                        <fx-dom-inspector>
                            <header slot="header">Document</header>
                        </fx-dom-inspector>
                    </section>
                    <section class="instances">
                        <header></header>
                        <div class="instance-panel">
                        </div>
                    </section>
                    <section id="options">
                        <fx-log-settings></fx-log-settings>
                    </section>
                </section>
            </details>
        </section>
      `;
    this.shadowRoot.innerHTML = `
          <style>
              ${style}
          </style>
          ${html}
      `;

    // resizing handler
    this.resizer = this.shadowRoot.querySelector('.resizer');
    this.resizer.addEventListener('mousedown', this._startResize.bind(this));
    document.addEventListener('mousemove', this._resizePanel.bind(this));
    document.addEventListener('mouseup', this._stopResize.bind(this));

    // setup handler for option button on the right of the panel
    const optionsTrigger = this.shadowRoot.querySelector('#optionsTrigger');
    optionsTrigger.addEventListener('click', () => {
      const tr = this.shadowRoot.querySelector('#options');
      tr.classList.toggle('open');
      tr.classList.contains('open') ? optionsTrigger.style.background = 'lightsteelblue' : optionsTrigger.style.background = 'transparent';
    });

    // opening/closing the devtools
    const caption = this.shadowRoot.querySelector('.fx-devtools');
    caption.addEventListener('click', ev => {
      if (ev.target.nodeName === 'DIV' && ev.target.classList.contains('resizer')) {
        return;
      }
      if (ev.target.parentNode.open) {
        this.removeAttribute('open');
        this.lastHeight = this.style.height;
        this.style.height = '3em';
      } else {
        this.setAttribute('open', '');
        this.style.height = this.lastHeight ? this.lastHeight : '40vh';
      }
    });
    this.classList.add('open');

    /*
        document.addEventListener('value-changed', e =>{
            console.log('value-changed hitting glass', e.target);
        })
    */
  }

  _handleOpen(ev) {
    // console.log('that works')

    document.body.style.height = '';
  }
  _renderInstancePanel(instance) {
    if (instance.type === 'xml') {
      const domInspector = document.createElement('fx-dom-inspector');
      domInspector.setInstance(instance);
      domInspector.setAttribute('instance', instance.id);
      return domInspector;

      /*
                        return
                            `<fx-dom-inspector instance="${instance.id}"> </fx-dom-inspector>`
            */
    }

    if (instance.type === 'json') {
      const jsonInspector = document.createElement('fx-json-instance');
      jsonInspector.setAttribute('instance', instance.id);
      const span = document.createElement('span');
      span.setAttribute('slot', 'header');
      jsonInspector.append(span);
      return jsonInspector;
      /*
            return `
                <fx-json-instance instance="${instance.id}">
                    <span slot="header"></span>
                </fx-json-instance>
            `
      */
    }
  }
}

if (!customElements.get('fx-devtools')) {
  customElements.define('fx-devtools', FxDevtools);
}

/**
 * a simple component that wraps a Fore page and puts it into shadowDom.
 *
 * HTML link elements passed as children will be used to construct a CSSStyleSheet that is passed
 * to the shadowDOM.
 * @customElement
 */
class ForeComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.src = '';
  }
  connectedCallback() {
    this.src = this.getAttribute('src');
    const style = `
          :host {
            display:block;
          }
        `;
    const html = `
          <fx-fore src="${this.src}">
          </fx-fore>
          <slot id="default"></slot>
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${html}
        `;

    /*
     * wait for slotchange, then filter document.stylesheets to construct CSSStyleSheet
     */
    const slot = this.shadowRoot.querySelector('#default');
    slot.addEventListener('slotchange', async event => {
      const children = event.target.assignedElements();
      const hostedStylesheet = children.filter(linkElem => linkElem.nodeName.toUpperCase() === 'LINK');
      if (!hostedStylesheet) return;
      const allCSS = [...document.styleSheets].map(styleSheet => {
        if (hostedStylesheet.find(sh => sh.href === styleSheet.href)) {
          try {
            return [...styleSheet.cssRules].map(rule => rule.cssText).join('');
          } catch (e) {
            console.log('Access to stylesheet %s is denied. Ignoring', styleSheet.href);
          }
        }
      }).filter(Boolean).join('\n');
      const sheet = new CSSStyleSheet();
      sheet.replaceSync(allCSS);
      this.shadowRoot.adoptedStyleSheets = [sheet];
    });

    /*
        const eventSlot = this.shadowRoot.querySelector('slot[name="event"]');
        eventSlot.addEventListener('slotchange', async event => {
            const children = event.target.assignedElements();
            console.log('events', children)
        });
    */
    const eventTmpl = this.querySelector('fx-action');
    if (eventTmpl) {
      // const clone = eventTmpl.content.cloneNode(true);
      const clone = eventTmpl.cloneNode(true);
      this.removeChild(eventTmpl);
      // const content = document.importNode(clone, true);

      const fore = this.shadowRoot.querySelector('fx-fore');
      // fore.appendChild(content.firstElementChild);
      fore.appendChild(clone);
    }
  }
}
if (!customElements.get('fore-component')) {
  customElements.define('fore-component', ForeComponent);
}

/**
 * `fx-upload` allows to embed uploaded content into XML.
 *
 * @customElement
 */

class FxUpload extends AbstractControl {
  constructor() {
    super();
    this.inited = false;
    this.attachShadow({
      mode: 'open'
    });
  }
  static get properties() {
    return {
      ...AbstractControl.properties,
      accept: {
        type: String
      },
      fileNameExpr: {
        type: String
      },
      mimetypeExpr: {
        type: String
      }
    };
  }
  connectedCallback() {
    this.updateEvent = 'change';
    this.accept = this.hasAttribute('accept') ? this.getAttribute('accept') : '';
    this.label = this.hasAttribute('label') ? this.getAttribute('label') : null;
    const style = `
            :host{
                display:inline-block;
            }
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${this.renderHTML(this.ref)}
        `;
    this.widget = this.getWidget();
    this.addEventListener('mousedown', e => {
      // ### prevent mousedown events on all control content that is not the widget or within the widget
      if (!Fore.isWidget(e.target) && !e.target?.classList.contains('fx-hint')) {
        e.preventDefault();
        // e.stopImmediatePropagation();
      }

      this.widget.focus();
    });

    // console.log('widget ', this.widget);
    let listenOn = this.widget; // default: usually listening on widget

    // ### convenience marker event
    if (this.debounceDelay) {
      listenOn.addEventListener(this.updateEvent, debounce(this, () => {
        // console.log('eventlistener ', this.updateEvent);
        // console.info('handling Event:', event.type, listenOn);
        this._importUploadedContent();
      }, this.debounceDelay));
    } else {
      listenOn.addEventListener(this.updateEvent, async event => {
        this._importUploadedContent(event);
      });
    }
    this.boundInitialized = false;
    this.fileNameExpr = this.getAttribute('filename');
    this.mimetypeExpr = this.getAttribute('mimetype');
  }
  async _importUploadedContent(event) {
    console.log('_importUploadedContent', event);
    const file = event.target.files[0];
    this.evalInContext();
    // update file ref
    const fileNode = evaluateXPathToFirstNode(this.fileNameExpr, this.nodeset, this.getOwnerForm());
    if (fileNode) {
      this.fileName = fileNode.nodeValue = file.name;
    }
    this.mimetype = file.type;

    // update mediatype
    const mimetypeNode = evaluateXPathToFirstNode(this.mimetypeExpr, this.nodeset, this.getOwnerForm());
    if (mimetypeNode) {
      mimetypeNode.nodeValue = this.mimetype;
    }
    let content = await this._readFile(file);
    // const setval = this.shadowRoot.getElementById('setvalue');
    console.log('content', content);
    if (file.type.endsWith('xml')) {
      const uploadedXML = new DOMParser().parseFromString(content, 'application/xml');
      content = uploadedXML.firstElementChild;
    }
    this.setValue(content);
    // // this.value=content;
    // return content;
  }

  async _readFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();

      // Determine how to read the file based on MIME type
      const isTextFile = file.type.startsWith("text/");
      const readMethod = isTextFile ? "readAsText" : "readAsDataURL";
      reader.onload = () => {
        const result = reader.result;
        // If it's a binary file, return only the Base64 content without the MIME prefix
        if (!isTextFile) {
          const base64Content = result.split(",")[1]; // Remove MIME prefix
          resolve(base64Content);
        } else {
          resolve(result); // Return plain text
        }
      };

      reader.onerror = () => reject(new Error("Error reading file"));

      // Start reading the file
      reader[readMethod](file);
    });
  }

  /**
   * updates the model with a new value by executing it's `<fx-setvalue>` action.
   *
   * In case the `as='node'` is given the bound node is replaced with the widgets' value with is
   * expected to be a node again.
   *
   * @param val the new value to be set
   */
  setValue(val) {
    this.value = val;
    const modelitem = this.getModelItem();
    if (this.mimetype.endsWith('xml')) {
      this.nodeset.textContent = '';
      this.nodeset.append(document.importNode(val, true));
    } else {
      modelitem.value = val;
      if (this.mimetype.startsWith('text/')) {
        const cdata = this.nodeset.ownerDocument.createCDATASection(val);
        this.nodeset.textContent = '';
        this.nodeset.append(cdata);
      } else {
        this.nodeset.textContent = '';
        this.nodeset.append(val);
      }
    }
    if (this.getAttribute('class')) {
      this.classList.add('visited');
    } else {
      this.setAttribute('class', 'visited');
    }
    if (modelitem?.readonly) {
      console.warn('attempt to change readonly node', modelitem);
      return; // do nothing when modelItem is readonly
    }

    // const setval = this.shadowRoot.getElementById('setvalue');
    // setval.setValue(modelitem, val);

    if (this.modelItem instanceof ModelItem && !this.modelItem?.boundControls.includes(this)) {
      this.modelItem.boundControls.push(this);
    }
    this.getModel();
    Fore.dispatch(this, 'value-changed', {
      path: this.modelItem.path,
      value: this.modelItem.value,
      oldvalue: "",
      instanceId: this.modelItem.instanceId,
      foreId: this.getOwnerForm().id
    });
    this.getModel().updateModel();
    this.getOwnerForm().refresh(true);

    // console.log('data', this.getOwnerForm().getModel().getDefaultInstanceData());
  }

  renderHTML(ref) {
    return `
            ${this.label ? `${this.label}` : ''}
            <slot></slot>
            <input type="file" ${this.accept !== '' ? `accept="${this.accept}"` : ''}>
            <fx-setvalue id="setvalue" ref="${ref}"></fx-setvalue>
        `;
  }

  /**
   * The widget is the actual control being used in the UI e.g. a native input control or any
   * other component that presents a control that can be interacted with.
   *
   * This function returns the widget by querying the children of this control for an element
   * with `class="widget"`. If that cannot be found it searches for an native `input` of any type.
   * If either cannot be found a `<input type="text">` is created.
   *
   * @returns {HTMLElement|*}
   */
  getWidget() {
    return this.shadowRoot.querySelector('input');
  }

  /**
   * updates the widget from the modelItem value. During refresh the a control
   * evaluates it's binding expression to determine the bound node. The bound node corresponds
   * to a modelItem which acts a the state object of a node. The modelItem determines the value
   * and the state of the node and set the `value` property of this class.
   *
   * @returns {Promise<void>}
   */
  async updateWidgetValue() {
    // this._getValueFromHtmlDom() = this.value;

    let {
      widget
    } = this;
    if (!widget) {
      widget = this;
    }
    if (widget.value !== this.value) ;
  }
  async refresh(force) {
    // console.log('fx-control refresh', this);
    super.refresh(force);
    // ### if we find a ref on control we have a 'select' control of some kind
    Fore.refreshChildren(this, force);
  }
  evalLabel(optionLabel, node, newEntry) {
    const labelExpr = optionLabel.substring(1, optionLabel.length - 1);
    if (!labelExpr) return;
    const label = evaluateXPathToString(labelExpr, node, this);
    newEntry.textContent = label;
  }
  createEntry() {
    return this.template.content.firstElementChild.cloneNode(true);
    // const content = this.template.content.firstElementChild.cloneNode(true);
    // return content;
    // const newEntry = document.importNode(content, true);
    // this.template.parentNode.appendChild(newEntry);
    // return newEntry;
  }

  // eslint-disable-next-line class-methods-use-this
  _getValueAttribute(element) {
    let result;
    Array.from(element.attributes).forEach(attribute => {
      const attrVal = attribute.value;
      if (attrVal.indexOf('{') !== -1) {
        // console.log('avt found ', attribute);
        result = attribute;
      }
    });
    return result;
  }
}
if (!customElements.get('fx-upload')) {
  window.customElements.define('fx-upload', FxUpload);
}

/**
 * @param {number} howLong How long to wait, in ms
 * @returns {Promise<void>}
 */
async function wait(howLong) {
  return new Promise(resolve => setTimeout(() => resolve(), howLong));
}

/**
 * Superclass for all action elements. Provides basic wiring of events to targets as well as
 * handle conditionals and loops of actions.
 *
 * @fires action-performed - is dispatched after each execution of an action.
 * @customElement
 * @demo demo/index.html
 */
class AbstractAction extends ForeElementMixin {
  static get properties() {
    return {
      ...super.properties,
      /**
       * can be either 'cancel' or 'perform' (default)
       */
      defaultAction: {
        type: String
      },
      /**
       * delay before executing action in milliseconds
       */
      delay: {
        type: Number
      },
      /**
       * detail - event detail object
       */
      detail: {
        type: Object
      },
      /**
       * event to listen for
       */
      event: {
        type: Object
      },
      handler: {
        type: Object
      },
      /**
       * boolean XPath expression. If true the action will be executed.
       */
      ifExpr: {
        type: String
      },
      /**
       * The iterate attribute can be added to any XForms action. It contains an expression
       * that is evaluated once using the in-scope evaluation context before the action is
       * executed, which will result in a sequence of items. The action will be executed with
       * each item in the sequence as its context. This context replaces the default in scope
       * evaluation context.
       *
       * The interaction with `@while` and `@if` is undefined.
       */
      iterateExpr: {
        type: String
      },
      /**
       * whether nor not an action needs to run the update cycle
       */
      needsUpdate: {
        type: Boolean
      },
      /**
       * The observer if given is the element on which an event is triggered. It must be an ancestor of the target
       * element of an event.
       */
      observer: {
        type: Object
      },
      /**
       * can be either 'capture' or 'default' (default)
       */
      phase: {
        type: String
      },
      /**
       * can be either 'stop' or 'continue' (default)
       */
      propagate: {
        type: String
      },
      /**
       * id of target element to attach listener to
       */
      target: {
        type: String
      },
      /**
       * boolean XPath expression. If true loop will be executed. If an ifExpr is present this
       * also needs to be true to actually run the action.
       */
      whileExpr: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.detail = {};
    this.needsUpdate = false;
  }
  disconnectedCallback() {}
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute('inert', 'true');
    this.style.display = 'none';
    this.propagate = this.hasAttribute('propagate') ? this.getAttribute('propagate') : 'continue';
    this.repeatContext = undefined;
    if (this.hasAttribute('event')) {
      this.event = this.getAttribute('event');
    }
    if (this.hasAttribute('defaultAction')) {
      this.defaultAction = this.getAttribute('defaultAction');
    } else {
      this.defaultAction = 'perform';
    }
    if (this.hasAttribute('phase')) {
      this.phase = this.getAttribute('phase');
    } else {
      this.phase = 'default';
    }

    /*
            this.addEventListener('click', e => {
              e.preventDefault();
              e.stopPropagation();
            });
        */

    this.ifExpr = this.hasAttribute('if') ? this.getAttribute('if') : null;
    this.whileExpr = this.hasAttribute('while') ? this.getAttribute('while') : null;
    this.delay = this.hasAttribute('delay') ? Number(this.getAttribute('delay')) : 0;
    this.iterateExpr = this.hasAttribute('iterate') ? this.getAttribute('iterate') : null;
    this._addUpdateListener();
  }
  _addUpdateListener() {
    this.target = this.getAttribute('target');
    if (this.target) {
      if (this.target === '#window') {
        window.addEventListener(this.event, e => this.execute(e), {
          capture: this.phase === 'capture'
        });
      } else if (this.target === '#document') {
        document.addEventListener(this.event, e => this.execute(e), {
          capture: this.phase === 'capture'
        });
      } else {
        this.targetElement = resolveId(this.target, this);
        if (!this.targetElement) return; // does not or does not yet exist
        this?.targetElement.addEventListener(this.event, e => this.execute(e), {
          capture: this.phase === 'capture'
        });
      }
    } else {
      this.targetElement = this.parentNode;
      if (!this.targetElement || this.targetElement.nodeType !== Node.ELEMENT_NODE) return;
      this.targetElement.addEventListener(this.event, e => this.execute(e), {
        capture: this.phase === 'capture'
      });
      // console.log('adding listener for ', this.event , ` to `, this);
    }
  }

  async performSafe() {
    try {
      await this.perform();
      // Return true to indicate success
      return true;
    } catch (error) {
      await Fore.dispatch(this, 'error', {
        origin: this,
        message: 'Action execution failed',
        expr: XPathUtil.getDocPath(this),
        level: 'Error'
      });
      // Return false to indicate failure. Any loops must be canceled
      return false;
    }
  }

  /**
   * executes the action.
   *
   * Will first evaluate ifExpr and continue only if it evaluates to 'true'. The 'whileExpr' will be executed
   * considering the delay if present.
   *
   * After calling `perform' which actually implements the semantics of an concrete action
   * `actionPerformed` will make sure that update cycle is run if 'needsUpdate' is true.
   *
   * @param e
   */
  async execute(e) {
    if (!this.getModel().modelConstructed) return;
    // console.log(this, this.event);
    if (this.event) {
      if (this.event === 'submit-done') {
        console.info(`%csubmit-done ${this.event} #${this?.parentNode?.id}`, 'background:lime; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
      } else {
        console.info(`%cexecuting ${this.constructor.name} ${this.event}`, 'background:lime; color:black; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;');
      }
    } else {
      console.info(`%cexecuting ${this.constructor.name}`, 'background:limegreen; color:black; margin-left:1rem; padding:.5rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;width:100%;', this);
    }
    if (e && e.target.nodeType !== Node.DOCUMENT_NODE && e.target !== window) {
      /*
             ### ignore event if there's a parent fore and the current element is NOT part of it. This avoids
             ### an event to fire twice on an inner one and the surrounding one(s).
             ### e.target might be outside an fx-fore element and shouldn't get cancelled in that case.
            */
      if (e.target.closest('fx-fore') && e.target.closest('fx-fore') !== this.closest('fx-fore')) {
        // Event originates from a sub-component. Ignore it!
        // No need to stop propagation. All other listeners will also ignore it from here
        return;
      }
    }
    if (this.propagate === 'stop') {
      // console.log('event propagation stopped', e)
      e.stopPropagation();
    }
    if (this.defaultAction === 'cancel') {
      e.preventDefault();
    }
    let resolveThisEvent = () => {};
    if (e && e.listenerPromises) {
      e.listenerPromises.push(new Promise(resolve => {
        resolveThisEvent = resolve;
      }));
    }

    // Outermost handling
    if (FxFore.outermostHandler === null) {
      console.log(`%coutermost Action on ${this.getOwnerForm().id}`, 'background:darkblue; color:white; padding:0.3rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;', this);
      FxFore.outermostHandler = this;
      this.dispatchEvent(new CustomEvent('outermost-action-start', {
        composed: true,
        bubbles: true,
        cancelable: true,
        detail: {
          cause: e?.type
        }
      }));
    }
    if (e) {
      this.currentEvent = e;
    }
    this.needsUpdate = false;
    try {
      this.evalInContext();
    } catch (error) {
      console.warn('evaluation failed', error);
    }
    if (this.targetElement && this.targetElement.nodeset) {
      this.nodeset = this.targetElement.nodeset;
    }

    // Order of application between if / while and iterate is undefined. See
    // https://www.w3.org/MarkUp/Forms/wiki/@iterate
    if (this.iterateExpr) {
      // Same as whileExpr, let it go update UI afterwards
      await this.handleIterateExpr();
      this._finalizePerform(resolveThisEvent);
      return;
    }

    // Check if 'if' condition is true - otherwise exist right away
    if (this.ifExpr && !evaluateXPathToBoolean(this.ifExpr, getInScopeContext(this), this)) {
      this._finalizePerform(resolveThisEvent);
      return;
    }
    if (this.whileExpr) {
      // After loop is done call actionPerformed to update the model and UI
      await this.handleWhileExpr();
      this._finalizePerform(resolveThisEvent);
      return;
    }
    if (this.delay) {
      // Delay further execution until the delay is done
      await wait(this.delay);
      if (!XPathUtil.contains(this.getOwnerForm(), this)) {
        // We are no longer in the document. Stop working
        this.actionPerformed();
        resolveThisEvent();
        return;
      }
    }
    await this.performSafe();
    this._finalizePerform(resolveThisEvent);
  }
  async handleWhileExpr() {
    // While: while the condition is true, delay a bit and execute the action
    // Start by waiting
    await wait(this.delay || 0);
    if (!XPathUtil.contains(this.getOwnerForm(), this)) {
      // We are no longer in the document. Stop working
      return;
    }
    if (!evaluateXPathToBoolean(this.whileExpr, getInScopeContext(this), this)) {
      // Done with iterating
      return;
    }

    // Perform the action once. But quit if it failed
    if (!this.performSafe()) {
      return;
    }

    // Go for one more iteration
    if (this.delay) {
      // If we have a delay, fire and forget this.
      // Otherwise, if we have no delay, keep waiting for all iterations to be done.
      // The while is then uninterruptable and immediate

      this.handleWhileExpr();
      return;
    }
    await this.handleWhileExpr();
  }
  async handleIterateExpr() {
    try {
      // Iterate: get the context sequence and perform the action once per item.
      const contextSequence = evaluateXPath(this.iterateExpr, getInScopeContext(this), this);
      if (contextSequence.length === 0) {
        return;
      }
      if (!XPathUtil.contains(this.getOwnerForm(), this)) {
        // We are no longer in the document. Stop working
        return;
      }
      for (const item of contextSequence) {
        if (this.delay) {
          await wait(this.delay || 0);
        }

        // This will be picked up in `getInscopeContext`
        this.currentContext = item;

        // Perform the action once. But quit if it failed
        if (!(await this.performSafe())) {
          return;
        }
      }
    } finally {
      this.currentContext = null;
    }
  }
  _finalizePerform(resolveThisEvent) {
    this.currentEvent = null;
    this.actionPerformed();
    if (FxFore.outermostHandler === this) {
      console.log(`%cfinalizing outermost Action on ${this.getOwnerForm().id}`, 'background:darkblue; color:white; padding:0.3rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;', this);
      FxFore.outermostHandler = null;
      /*
                        console.info(
                            `%coutermost Action done`,
                            'background:#e65100; color:white; padding:0.3rem; display:inline-block; white-space: nowrap; border-radius:0.3rem;',
                            this,
                        );
                        console.timeEnd('outermostHandler');
            */
      this.dispatchEvent(new CustomEvent('outermost-action-end', {
        composed: true,
        bubbles: true,
        cancelable: true
      }));
    }
    resolveThisEvent();
  }

  /**
   * Template method to be implemented by each action that is called by execute() as part of
   * the processing.
   *
   * This function should not called on any action directly - call execute() instead to ensure proper execution of 'if' and 'while'
   */
  async perform() {
    // await Fore.dispatch(document, 'execute-action', {action:this, event:this.event});

    // todo: review - this evaluation seems redundant as we already evaluated in execute
    if (this.isBound() || this.nodeName === 'FX-ACTION') {
      this.evalInContext();
    }
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
  }

  /**
   * calls the update cycle if action signalled that update is needed.
   */
  actionPerformed() {
    const model = this.getModel();
    if (!model) {
      return;
    }
    if (!model.inited) {
      return;
    }
    if (FxFore.outermostHandler && !XPathUtil.contains(FxFore.outermostHandler.ownerDocument, FxFore.outermostHandler)) {
      // The old outermostHandler fell out of the document. An error has happened.
      // Just remove the old one and act like we are starting anew.
      // console.warn('Unsetting outermost handler');
      FxFore.outermostHandler = null;
    }
    // console.log('actionPerformed action parentNode ', this.parentNode);
    if (this.needsUpdate && (FxFore.outermostHandler === this || !FxFore.outermostHandler)) {
      // console.log('running update cycle for outermostHandler', this);
      model.recalculate();
      model.revalidate();
      this.getOwnerForm().refresh(true);
      this.dispatchActionPerformed();
    } else if (this.needsUpdate) {
      // console.log('Update delayed!');
      // We need an update, but the outermost action handler is not done yet. Make this clear!
      // console.log('running actionperformed on', this, ' to be updated by ', FxFore.outermostHandler);
      FxFore.outermostHandler.needsUpdate = true;
    }

    // console.log('running actionperformed on', this, ' outermostHandler', FxFore.outermostHandler);
  }

  /**
   * dispatches action-performed event
   *
   * @event action-performed - whenever an action has been run
   */
  dispatchActionPerformed() {
    // console.log('action-performed ', this);
    Fore.dispatch(this, 'action-performed', {});
  }
}
AbstractAction.dataChanged = false;
if (!customElements.get('abstract-action')) {
  window.customElements.define('abstract-action', AbstractAction);
}

/**
 * `fx-append` appends an entry to a repeat.
 *
 *
 *
 * @deprecated - will be replaced with `fx-insert`
 * @fires index-changed - fired after new item is appended
 * @customElement
 */
// class FxAppend extends FxAction {
class FxAppend extends AbstractAction {
  static get properties() {
    return {
      ...AbstractAction.properties,
      ref: {
        type: String
      },
      /**
       * the repeat this action is appending to.
       */
      repeat: {
        type: String
      },
      clear: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.repeat = '';
  }
  connectedCallback() {
    super.connectedCallback();
    this.ref = this.getAttribute('ref');
    this.repeat = this.getAttribute('repeat');
    // this.repeated = this.closest('fx-repeatitem');
  }

  /**
   * appends a instance of the repeat template to the existing ones.
   *
   * The data structure to insert into the instance data is determined by the 'ref' attributes
   * found in the template of the repeat. This is similar to lazy instance creation.
   *
   * Note: This is a significant difference to XForms which takes the instance nodes as template to insert but
   * has the problem of empty nodesets not being able to insert an entry without using a separate instance
   * holding the template.
   *
   * As a consequence the item that are appended are not propagated with values but empty. However usually
   * that's what the user wants and not the other way round (duplicating the last data items). If the XForms
   * behavior should be needed for some reason later on, it can be added easier by a providing an 'duplicate' action.
   *
   */
  async perform() {
    super.perform();
    this._dataFromTemplate();
    /*
        const instData = new XMLSerializer().serializeToString(
            this.getModel()
                .getDefaultInstance()
                .getInstanceData(),
        );
    */
    // console.log('modified instance ', this.getModel().getDefaultInstance().getInstanceData());

    this.needsUpdate = true;
  }
  actionPerformed() {
    super.actionPerformed();
    // const repeat = document.getElementById(this.repeat);
    // repeat.setIndex(repeat.nodeset.length);
    this._dispatch();
  }

  /**
   * creates a data-template from repeat template and appends it to inscope context instance.
   *
   * @private
   */
  _dataFromTemplate() {
    const inscope = this.getInScopeContext();
    const parentForm = this.getOwnerForm();
    const repeat = parentForm.querySelector(`#${this.repeat}`);
    // console.log('_dataFromTemplate repeat', repeat);
    // console.log('_dataFromTemplate repeat ref', repeat.ref);

    const templ = repeat.shadowRoot.querySelector('template');
    // console.log('_dataFromTemplate ', templ);
    // console.log('_dataFromTemplate content', templ.content);

    // iterate template for refs
    // todo: will fail for pathes with predicates - need to be filtered before
    // const rootNode = document.createElement(repeat.ref);

    // const rootNode = document.createElement(repeat.ref);
    // const rootNode = inscope.ownerDocument.createElement(repeat.ref);
    const rootNode = inscope.ownerDocument.createElement(repeat.ref);

    // const data = this._dataFromRefs(rootNode, templ.content)
    const data = this._generateInstance(templ.content, rootNode);
    // console.log('_dataFromTemplate DATA', data);
    inscope.appendChild(data);
    parentForm.signalChangeToElement(inscope.localName);
    parentForm.signalChangeToElement(data.localName);
    // console.log('appended new item ', data);
    // return data;
  }

  /**
   * dispatches set-index event to target repeat
   *
   * The target repeat is a child of the same repeat-item as the append action.
   */
  _dispatch() {
    const targetRepeat = resolveId(this.repeat, this);
    Fore.dispatch(targetRepeat, 'index-changed', {
      index: targetRepeat.nodeset.length
    });
  }

  /**
   * clear all text nodes and attribute values to get a 'clean' template.
   * @param n
   * @private
   *
   *
   */
  _clear(n) {
    let node = n.firstChild;
    const attrs = n.attributes;
    for (let i = 0; i < attrs.length; i += 1) {
      // n.setAttribute(attrs[i].name,'');
      attrs[i].value = '';
    }
    while (node) {
      if (node.nodeType === 1 && node.hasAttributes()) {
        node.textContent = '';
      }
      this._clear(node);
      node = node.nextSibling;
    }
  }
  _generateInstance(start, parent) {
    if (start.nodeType === 1 && start.hasAttribute('ref')) {
      const ref = start.getAttribute('ref');
      let generated;
      if (ref === '.') ; else if (ref.startsWith('@')) {
        parent.setAttribute(ref.substring(1), '');
      } else {
        generated = document.createElement(ref);
        parent.appendChild(generated);
        if (start.children.length === 0) {
          generated.textContent = start.textContent;
        }
      }
    }
    if (start.hasChildNodes()) {
      const list = start.children;
      for (let i = 0; i < list.length; i += 1) {
        this._generateInstance(list[i], parent);
      }
    }
    return parent;
  }
  getInstanceId() {
    if (this.ref.startsWith('instance(')) {
      return 'not implemented';
    }
    return 'default';
  }

  /*
    _fadeIn (el, display) {
      // eslint-disable-next-line no-param-reassign
      el.style.opacity = 0;
      // eslint-disable-next-line no-param-reassign
      el.style.display = display || 'block';
       (function fade() {
        // let val = parseFloat(el.style.opacity);
        let val = parseFloat(el.style.opacity);
        val += 0.1;
        if (!(val > 1)) {
          // eslint-disable-next-line no-param-reassign
          el.style.opacity = val;
          requestAnimationFrame(fade);
        }
      })();
    }
  */
}

if (!customElements.get('fx-append')) {
  window.customElements.define('fx-append', FxAppend);
}

/**
 * `fx-delete`
 * deletes nodes from instance data.
 *
 * @fires deleted event
 * @customElement
 * @demo demo/todo.html
 */
class FxDelete extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      ref: {
        type: String
      }
    };
  }

  /**
   * deletes nodes from instance data.
   *
   * Will NOT perform delete if nodeset is pointing to document node, document fragment, root node or being readonly.
   */
  async perform() {
    const inscopeContext = getInScopeContext(this.getAttributeNode('ref') || this, this.ref);
    this.nodeset = evaluateXPathToNodes(this.ref, inscopeContext, this);

    // console.log('delete nodeset ', this.nodeset);

    const instanceId = XPathUtil.resolveInstance(this, this.ref);
    const instance = this.getModel().getInstance(instanceId);

    // const path = instance && this.nodeset.length !== 0 ? evaluateXPathToString('path()', this.nodeset[0], instance) : '';

    const path = Fore.getDomNodeIndexString(this.nodeset);
    const nodesToDelete = this.nodeset;
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event,
        path
      }
    }));
    const fore = this.getOwnerForm();
    let parent;
    if (Array.isArray(nodesToDelete)) {
      if (nodesToDelete.length === 0) return;
      parent = nodesToDelete[0].parentNode;
      fore.signalChangeToElement(parent.localName);
      nodesToDelete.forEach(item => {
        this._deleteNode(parent, item);
        fore.signalChangeToElement(item.localName);
      });
    } else {
      parent = nodesToDelete.parentNode;
      fore.signalChangeToElement(parent.localName);
      this._deleteNode(parent, nodesToDelete);
      fore.signalChangeToElement(nodesToDelete.localName);
    }
    await Fore.dispatch(instance, 'deleted', {
      ref: path,
      deletedNodes: nodesToDelete,
      instanceId,
      foreId: fore.id
    });
    this.needsUpdate = true;
  }
  _deleteNode(parent, node) {
    if (parent.nodeType === Node.DOCUMENT_NODE) return;
    if (node.nodeType === Node.DOCUMENT_NODE) return;
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return;
    if (node.parentNode === null) return;
    const mi = this.getModelItem();
    if (mi.readonly) return;
    parent.removeChild(node);
  }

  /**
   * overwriting as we need to perform additional rebuild()
   */
  actionPerformed() {
    this.getModel().rebuild();
    super.actionPerformed();
  }
}
if (!customElements.get('fx-delete')) {
  window.customElements.define('fx-delete', FxDelete);
}

/**
 * `fx-setfocus`
 * Set the focus to a target control optionally selecting eventual value in case a `select` attribute is given.
 *
 * @customElement
 */
class FxSetfocus extends AbstractAction {
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.control = this.hasAttribute('control') ? this.getAttribute('control') : null;
  }
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));

    // super.perform();
    const selector = `#${this.control}`;
    let targetElement = document.querySelector(selector);
    if (!targetElement) {
      Fore.dispatch(this, 'error', {
        origin: this,
        message: `Instance '${this.control}' not found`,
        level: 'Error'
      });
      return;
    }

    // ### focus action is itself hosted within a repeat
    const parentIItem = targetElement.closest('fx-repeatitem');
    if (parentIItem) {
      targetElement = parentIItem.querySelector(selector);
      this._focus(targetElement);
      // return;
    }

    // ### the target element is hosted within a repeat
    const repeatitem = targetElement.closest('fx-repeatitem, .fx-repeatitem');
    if (repeatitem) {
      // targetElement is repeated
      // get the active repeatitem (only for fx-repeat for now - todo: support repeat attributes
      const repeat = repeatitem.parentNode;
      targetElement = repeat.querySelector(`[repeat-index] ${selector}`);
    }
    this._focus(targetElement);
    if (this.hasAttribute('select')) {
      this._select(targetElement);
    }
  }
  _focus(targetElement) {
    if (targetElement && typeof targetElement.getWidget === 'function') {
      targetElement.getWidget().focus();
    }
    if (targetElement && targetElement.nodeType === Node.ELEMENT_NODE) {
      targetElement.click();
    }
  }
  _select(targetElement) {
    if (targetElement) {
      targetElement.getWidget().select();
    }
  }
}
if (!customElements.get('fx-setfocus')) {
  window.customElements.define('fx-setfocus', FxSetfocus);
}

/**
 * `fx-insert`
 * inserts nodes into data instances
 *
 * @customElement
 */
class FxInsert extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      at: {
        type: Number
      },
      position: {
        type: Number
      },
      origin: {
        type: Object
      },
      keepValues: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    const style = `
        :host{
            display:none;
        }
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        <slot></slot>
    `;
    this.at = Number(this.hasAttribute('at') ? this.getAttribute('at') : 0); // default: size of nodeset, determined later
    this.position = this.hasAttribute('position') ? this.getAttribute('position') : 'after';
    this.origin = this.hasAttribute('origin') ? this.getAttribute('origin') : null; // last item of context seq
    this.keepValues = !!this.hasAttribute('keep-values');
  }
  _cloneOriginSequence(inscope, targetSequence) {
    let originSequenceClone;
    if (this.origin) {
      // ### if there's an origin attribute use it
      let originTarget;
      try {
        /*
        todo: discuss where to pass vars from event.detail into function context
         */
        // this.setInScopeVariables(this.detail);

        /*
        if in 'create-nodes' mode and origin targets a repeat, the repeat
        we use the already during initData() created nodeset as a template for insertion
         */
        if (this.origin.startsWith('#') && this.getOwnerForm().createNodes) {
          const repeat = this.getOwnerForm().querySelector(this.origin);
          originSequenceClone = repeat.createdNodeset.cloneNode(true);
          if (!originSequenceClone) {
            console.error(`createdNodeset for repeat ${this.origin} does not exist`);
          }
        } else {
          // originTarget = evaluateXPathToFirstNode(this.origin, inscope, this);
          originTarget = evaluateXPathToFirstNode(this.origin, inscope, this);
          if (Array.isArray(originTarget) && originTarget.length === 0) {
            console.warn('invalid origin for this insert action - ignoring...', this);
            originSequenceClone = null;
          }
          originSequenceClone = originTarget.cloneNode(true);
        }
      } catch (error) {
        console.warn('invalid origin for this insert action - ignoring...', this);
      }
    } else if (targetSequence) {
      // ### use last item of targetSequence
      originSequenceClone = this._cloneTargetSequence(targetSequence);
      if (originSequenceClone && !this.keepValues) {
        this._clear(originSequenceClone);
      }
    }
    return originSequenceClone;
  }
  _getInsertIndex(inscope, targetSequence) {
    if (targetSequence.length === 0) {
      return null;
    }
    if (this.hasAttribute('at')) {
      return evaluateXPathToNumber(this.getAttribute('at'), inscope, this);
    }
    return targetSequence.length;
  }
  async perform() {
    // We have a few terms here: `inScope` is the 'current item' we have. It is the item we're
    // copying and inserting elsewhere.  If we have a `ref`, one of the nodes returned will
    // become the sibling of this copy.  The `context` is the new parent of the copied
    // element. It's usually better to add a `context` because that deals with empty elements.
    let inscope;
    let context;
    let targetSequence = [];
    const inscopeContext = getInScopeContext(this);
    const fore = this.getOwnerForm();

    // ### 'context' attribute takes precedence over 'ref'
    if (this.hasAttribute('context')) {
      [context] = evaluateXPathToNodes(this.getAttribute('context'), inscopeContext, fore);
      inscope = inscopeContext;
    }
    if (this.hasAttribute('ref')) {
      if (inscope) {
        targetSequence = evaluateXPathToNodes(this.ref, inscope, this);
      } else {
        inscope = getInScopeContext(this.getAttributeNode('ref'), this.ref);
        targetSequence = evaluateXPathToNodes(this.ref, inscope, this);
      }
    }
    // const originSequenceClone = this._cloneOriginSequence(inscope, targetSequence);

    const originSequenceClone = this._cloneOriginSequence(inscope, targetSequence);
    if (!originSequenceClone) return; // if no origin back out without effect

    let insertLocationNode;
    let index;

    // if the targetSequence is empty but we got an originSequence use inscope as context and ignore 'at' and 'position'
    if (targetSequence.length === 0) {
      if (context) {
        insertLocationNode = context;
        context.appendChild(originSequenceClone);
        fore.signalChangeToElement(insertLocationNode.localName);
        fore.signalChangeToElement(originSequenceClone.localName);
        index = 1;
      } else {
        // No context but creating nodes from UI
        if (!inscope && this.getOwnerForm().createNodes) {
          const repeat = this.getOwnerForm().querySelector(this.origin);
          inscope = getInScopeContext(repeat, repeat.ref);
          insertLocationNode = inscope;
          inscope.appendChild(originSequenceClone);
          index = inscope.length - 1;
        } else {
          insertLocationNode = inscope;
          inscope.appendChild(originSequenceClone);
          index = 1;
        }
      }
    } else {
      /* ### insert at position given by 'at' or use the last item in the targetSequence ### */
      if (this.hasAttribute('at')) {
        // todo: eval 'at'
        // index = this.at;
        // insertLocationNode = targetSequence[this.at - 1];

        index = evaluateXPathToNumber(this.getAttribute('at'), inscope, this);
        insertLocationNode = targetSequence[index - 1];
      } else {
        // this.at = targetSequence.length;
        index = targetSequence.length;
        insertLocationNode = targetSequence[targetSequence.length - 1];
      }

      // ### if the insertLocationNode is undefined use the targetSequence - usually the case when the targetSequence just contains a single node
      if (!insertLocationNode) {
        index = 1;
        insertLocationNode = targetSequence;
        const context = evaluateXPathToNumber('count(preceding::*)', targetSequence, this.getOwnerForm());
        // console.log('context', context);
        index = context + 1;
        // index = targetSequence.findIndex(insertLocationNode);
      }

      if (this.position && this.position === 'before') {
        // this.at -= 1;
        insertLocationNode.parentNode.insertBefore(originSequenceClone, insertLocationNode);
        fore.signalChangeToElement(insertLocationNode.parentNode);
        fore.signalChangeToElement(originSequenceClone.localName);
      }
      if (this.position && this.position === 'after') {
        // insertLocationNode.parentNode.append(originSequence);
        // const nextSibl = insertLocationNode.nextSibling;
        index += 1;
        if (this.hasAttribute('context') && this.hasAttribute('ref')) {
          // index=1;
          inscope.append(originSequenceClone);
        } else if (this.hasAttribute('context')) {
          index = 1;
          insertLocationNode.prepend(originSequenceClone);
          fore.signalChangeToElement(insertLocationNode);
          fore.signalChangeToElement(originSequenceClone.localName);
        } else {
          insertLocationNode.insertAdjacentElement('afterend', originSequenceClone);
          fore.signalChangeToElement(insertLocationNode);
          fore.signalChangeToElement(originSequenceClone.localName);
        }
      }
    }
    // instance('default')/items/item[index()]

    // console.log('insert context item ', insertLocationNode);
    // console.log('parent ', insertLocationNode.parentNode);
    // console.log('instance ', this.getModel().getDefaultContext());
    // Fore.dispatch()

    // const instanceId = XPathUtil.resolveInstance(this, this.getAttribute('context'));
    const instanceId = XPathUtil.resolveInstance(this, this.ref);
    const inst = this.getModel().getInstance(instanceId);
    // console.log('<<<<<<< resolved instance', inst);
    // Note: the parent to insert under is always the parent of the inserted node. The 'context' is not always the parent if the sequence is empty, or the position is different
    // const xpath = XPathUtil.getPath(originSequenceClone.parentNode, instanceId);
    const xpath = XPathUtil.getPath(insertLocationNode.parentNode, instanceId);
    const path = Fore.getDomNodeIndexString(originSequenceClone);
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event,
        path
      }
    }));
    Fore.dispatch(inst, 'insert', {
      'inserted-nodes': originSequenceClone,
      'insert-location-node': insertLocationNode,
      position: this.position,
      instanceId,
      foreId: fore.id
    });

    // todo: this actually should dispatch to respective instance
    document.dispatchEvent(
    // new CustomEvent('insert', {
    new CustomEvent('index-changed', {
      composed: true,
      bubbles: true,
      detail: {
        insertedNodes: originSequenceClone,
        index
      }
    }));
    this.needsUpdate = true;
    console.log('Changed!', xpath);
    return [xpath];
  }

  // eslint-disable-next-line class-methods-use-this
  _cloneTargetSequence(seq) {
    if (Array.isArray(seq) && seq.length !== 0) {
      return seq[seq.length - 1].cloneNode(true);
    }
    if (!Array.isArray(seq) && seq) {
      return seq.cloneNode(true);
    }
    return null;
  }
  actionPerformed(changedPaths) {
    // ### make sure the necessary modelItems will get created
    this.getModel().rebuild();
    super.actionPerformed();
  }

  /**
   * clear all text nodes and attribute values to get a 'clean' template.
   * @param n
   * @private
   */
  _clear(n) {
    const attrs = n.attributes;

    // clear attrs
    for (let i = 0; i < attrs.length; i += 1) {
      // n.setAttribute(attrs[i].name,'');
      attrs[i].value = '';
    }
    // clear text content
    if (n.textContent) {
      n.textContent = '';
    }
    let node = n.firstChild;
    while (node) {
      if (node.nodeType === 1 && node.hasAttributes()) {
        node.textContent = '';
      }
      this._clear(node);
      node = node.nextSibling;
    }
  }
}
if (!customElements.get('fx-insert')) {
  window.customElements.define('fx-insert', FxInsert);
}

/**
 * `fx-message`
 *
 * Action to display messages to the user.
 *
 *
 */
class FxMessage extends AbstractAction {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  static get properties() {
    return {
      ...AbstractAction.properties,
      modelItem: undefined,
      messageTextContent: {
        type: String,
        get value() {
          return 'here!';
        }
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.event = this.hasAttribute('event') ? this.getAttribute('event') : '';
    this.level = this.hasAttribute('level') ? this.getAttribute('level') : 'ephemeral';
    this.message = '';
    this.messageTextContent = this.textContent;
    const style = `
        :host{
            display:none;
        }
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        ${this.renderHTML()}
    `;
  }

  /*
  disconnectedCallback() {
    // super.disconnectedCallback();
    this.targetElement.removeEventListener(this.event, e => this.execute(e));
  }
  */

  // eslint-disable-next-line class-methods-use-this
  renderHTML() {
    return `
        <slot></slot>
    `;
  }
  async perform() {
    super.perform();
    if (this.hasAttribute('value')) {
      this.message = this._getValue();
    } else {
      this.getOwnerForm().evaluateTemplateExpression(this.messageTextContent, this.firstChild);
      this.message = this.textContent;
    }
    this.dispatchEvent(new CustomEvent('message', {
      composed: false,
      bubbles: true,
      detail: {
        level: this.level,
        message: this.message
      }
    }));
  }
  _getValue() {
    if (this.hasAttribute('value')) {
      const valAttr = this.getAttribute('value');
      try {
        const inscopeContext = getInScopeContext(this, valAttr);
        return evaluateXPathToString(valAttr, inscopeContext, this);
      } catch (error) {
        console.error(error);
        Fore.dispatch(this, 'error', {
          message: error
        });
      }
    }
    if (this.textContent) {
      return this.textContent;
    }
    return null;
  }
}
if (!customElements.get('fx-message')) {
  window.customElements.define('fx-message', FxMessage);
}

// import { FxAction } from './fx-action.js';

/**
 * `fx-setvalue`
 *
 * @customElement
 */
class FxSetvalue extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      ref: {
        type: String
      },
      valueAttr: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.ref = '';
    this.valueAttr = '';
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.hasAttribute('ref')) {
      this.ref = this.getAttribute('ref');
    } else {
      throw new Error('fx-setvalue must specify a "ref" attribute');
    }
    this.valueAttr = this.getAttribute('value');
  }
  async perform() {
    super.perform();
    let {
      value
    } = this;
    if (this.valueAttr !== null) {
      const inscopeContext = getInScopeContext(this, this.valueAttr);
      /*
      todo: review @martin - shouldn't we always return a string value?
      this comes down to the question if setvalue should only allow setting of strings
      which i tend to agree. Can't remember a case where i wanted to set an attribute
      or element (for json wouldn't make much sense either) - for cases like that
      fx-replace would be more appropriate.
      This is of practical relevance cause currently forces to append 'text()' to value expressions
      or getting unexpected results.
      */

      [value] = evaluateXPath(this.valueAttr, inscopeContext, this, this.detail);
    } else if (this.textContent !== '') {
      value = this.textContent;
    } else {
      value = '';
    }
    if (value?.nodeType && value.nodeType === Node.ATTRIBUTE_NODE) {
      value = value.nodeValue;
    }
    const mi = this.getModelItem();
    this.setValue(mi, value);
    // todo: check this again - logically needsUpate should be set but makes tests fail
    //  this.needsUpdate = true;
  }

  /**
   * need to overwrite default dispatchExecute to do it ourselves. This is necessary for tracking control value changes
   * which call setvalue directly without perform().
   */
  dispatchExecute() {}
  setValue(modelItem, newVal) {
    const item = modelItem;
    if (!item) return;
    if (item.value !== newVal) {
      // const path = XPathUtil.getPath(modelItem.node);
      const path = Fore.getDomNodeIndexString(modelItem.node);
      const ev = this.event;
      const targetElem = this;
      this.dispatchEvent(new CustomEvent('execute-action', {
        composed: true,
        bubbles: true,
        cancelable: true,
        detail: {
          action: targetElem,
          event: ev,
          value: newVal,
          path
        }
      }));
      if (newVal?.nodeType) {
        if (newVal.nodeType === Node.ELEMENT_NODE) {
          item.value = newVal;
        }
        if (newVal.nodeType === Node.ATTRIBUTE_NODE) {
          item.value = newVal.getValue();
        }
        if (newVal.nodeType === Node.TEXT_NODE) {
          item.value = newVal.textContent;
        }
      } else {
        item.value = newVal;
        item.node.textContent = newVal;
      }
      this.getModel().changed.push(modelItem);
      this.needsUpdate = true;
    }
  }
}
if (!customElements.get('fx-setvalue')) {
  window.customElements.define('fx-setvalue', FxSetvalue);
}

/**
 * `fx-send` - finds and activates a `fx-submission` or a `fx-connection` element.
 *
 * @customElement
 */
class FxSend extends AbstractAction {
  constructor() {
    super();
    this.value = '';
    this.url = null;
    this.target = null;
  }
  connectedCallback() {
    // eslint-disable-next-line wc/guard-super-call
    super.connectedCallback();
    // console.log('connectedCallback ', this);
    this.submission = this.getAttribute('submission');
    this.url = this.hasAttribute('url') ? this.getAttribute('url') : null;
    this.target = this.hasAttribute('target') ? this.getAttribute('target') : null;
    this.connection = this.hasAttribute('connection') ? this.getAttribute('connection') : null;
  }
  async perform() {
    super.perform();

    // reset CSS class that signalled validation error during last submit
    this.getOwnerForm().classList.remove('submit-validation-failed');
    if (this.connection) {
      const connectionElement = this.getModel().querySelector(`#${this.connection}`);
      if (connectionElement === null) {
        this.dispatchEvent(new CustomEvent('error', {
          composed: false,
          bubbles: true,
          cancelable: true,
          detail: {
            id: this.id,
            origin: this,
            message: `<fx-connection id="${this.connection}"> not found`,
            expr: XPathUtil.getDocPath(this),
            level: 'Error'
          }
        }));
        return;
      }
      this._emitToChannel();
      return;
    }
    const submission = this.getModel().querySelector(`#${this.submission}`);
    if (submission === null) {
      this.dispatchEvent(new CustomEvent('error', {
        composed: false,
        bubbles: true,
        cancelable: true,
        detail: {
          id: this.id,
          origin: this,
          message: `<fx-submission id="${this.submission}"> not found`,
          expr: XPathUtil.getDocPath(this),
          level: 'Error'
        }
      }));
      return;

      // throw new Error(`submission with id: ${this.submission} not found`);
    }
    // console.log('submission', submission);

    if (this.url) {
      const resolved = this.evaluateAttributeTemplateExpression(this.url, this);
      submission.parameters.set('url', resolved);
    }
    if (this.target) {
      const resolved = this.evaluateAttributeTemplateExpression(this.target, this);
      submission.parameters.set('target', resolved);
    }
    await submission.submit();
    if (submission.replace === 'instance') {
      this.getModel().updateModel();
      this.getOwnerForm().refresh();
    }
    // if not of type fx-submission signal error
  }

  _emitToChannel() {
    const channel = this.getModel().querySelector(`#${this.connection}`);
    if (channel === null) {
      return;
    }
    channel.send();
  }
}
if (!customElements.get('fx-send')) {
  window.customElements.define('fx-send', FxSend);
}

/**
 * `fx-toggle`
 *
 */
class FxToggle extends AbstractAction {
  /*
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }
  */
  connectedCallback() {
    super.connectedCallback();
    if (this.hasAttribute('case')) {
      this.case = this.getAttribute('case');
    }
  }
  async perform() {
    super.perform();
    if (this.case) {
      const ownerForm = this.getOwnerForm();
      // todo: id resolution!!!
      const caseElement = ownerForm.querySelector(`#${this.case}`);
      if (!caseElement) {
        Fore.dispatch(this, 'error', {
          message: `fx-case id not found: ${this.case}`
        });
        return;
      }
      const fxSwitch = caseElement.parentNode;
      fxSwitch.toggle(caseElement);
    }
    this.needsUpdate = true;
  }
}
if (!customElements.get('fx-toggle')) {
  window.customElements.define('fx-toggle', FxToggle);
}

/**
 * `fx-dispatch`
 *
 * dispatches an event with optional details.
 *
 * Properties given by `fx-property` child elements are stored to the events' details object and
 * can be accessed in usual JavaScript way.
 */
class FxDispatch extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      name: {
        type: String
      },
      targetid: {
        type: String
      },
      details: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.name = null;
    this.targetid = null;
    this.details = null;
    this.attachShadow({
      mode: 'open'
    });
  }

  /**
   * checks for `event` attribute. If not present will throw an Error
   *
   * @throws Error when no `event` attribute is given
   */
  connectedCallback() {
    super.connectedCallback();
    this.name = this.getAttribute('name');
    if (!this.name) {
      throw new Error('no event specified for dispatch', this);
    }
    this.targetid = this.hasAttribute('targetid') ? this.getAttribute('targetid') : null;

    // ### has a shadow just to hide
    /*
    this.shadowRoot.innerHTML = `
        <style>
            :host *{
                display: none;
            }
        </style>
        <slot></slot>
    `;
    */
  }

  /*
    disconnectedCallback() {
        super.disconnectedCallback();
    }
  */

  async perform() {
    super.perform();
    const properties = this.querySelectorAll('fx-property');
    const details = {};
    Array.from(properties).forEach(prop => {
      // console.log('prop ', prop);
      const name = prop.getAttribute('name');
      const value = prop.getAttribute('value');
      const expr = prop.getAttribute('expr');
      if (expr) {
        if (value) {
          throw new Error('if "expr" is given there must not be a "value" attribute');
        }
        const [result] = evaluateXPath(expr, this.getInScopeContext(), this);
        let serialized = null;
        if (result.nodeName) {
          const serializer = new XMLSerializer();
          serialized = serializer.serializeToString(result);
        }
        if (serialized) {
          details[name] = serialized;
        } else {
          details[name] = result;
        }
      }
      if (value) {
        details[name] = value;
      }
    });

    // console.log('details ', details);

    // ### when targetid is given dispatch to that if present (throw an error if not) - otherwise dispatch to document
    if (this.targetid) {
      let target = resolveId(this.targetid, this.parentNode, null);
      if (!target) {
        // TODO: essentially, we want to highly prefer the closest target. in the same subcontrol.
        // However, it may be that our target is elsewhere. Do a global search for that case
        target = document.getElementById(this.targetid);
      }
      if (!target) {
        throw new Error(`targetid ${this.targetid} does not exist in document`);
      }
      target.dispatchEvent(new CustomEvent(this.name, {
        composed: true,
        bubbles: true,
        detail: details
      }));
    } else {
      document.dispatchEvent(new CustomEvent(this.name, {
        composed: true,
        bubbles: true,
        detail: details
      }));
    }
  }
}
if (!customElements.get('fx-dispatch')) {
  window.customElements.define('fx-dispatch', FxDispatch);
}

/**
 * `fx-update`
 *
 * Calls updateModel() on fx-model which in turn will rebuild, recalculate and revalidate.
 *
 */
class FxUpdate extends AbstractAction {
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
    this.getModel().updateModel();
  }
}
if (!customElements.get('fx-update')) {
  window.customElements.define('fx-update', FxUpdate);
}

/**
 * `fx-refresh`
 *
 * Calls refresh() on fx-form
 *
 */
class FxRefresh extends AbstractAction {
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
    if (this.hasAttribute('self')) {
      console.log(`### <<<<< refresh() self ${this} >>>>>`);
      const control = XPathUtil.getClosest('fx-control', this);
      if (control) {
        control.refresh();
        return;
      }
    }
    if (this.hasAttribute('force')) {
      console.log(`### <<<<< refresh() force ${this} >>>>>`);
      this.getOwnerForm().forceRefresh();
      return;
    }
    if (this.hasAttribute('control')) {
      const targetId = this.getAttribute('control');
      console.log(`### <<<<< refresh() control '${targetId}' >>>>>`);
      const ctrl = resolveId(targetId, this);
      if (ctrl && Fore.isUiElement(ctrl.nodeName) && typeof ctrl.refresh === 'function') {
        ctrl.refresh();
      }
      return;
    }
    this.getOwnerForm().refresh();
  }
}
if (!customElements.get('fx-refresh')) {
  window.customElements.define('fx-refresh', FxRefresh);
}

// import { FxAction } from './fx-action.js';

/**
 * `fx-replace` - replaces the node referred to with 'ref' with node referred to with 'with' attribute.
 *
 * @customElement
 */
class FxReplace extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      with: {
        type: String
      },
      replaceNode: Object
    };
  }
  constructor() {
    super();
    this.with = '';
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.with = this.getAttribute('with');
  }
  async perform() {
    super.perform();
    // console.log('replace action variables', this.inScopeVariables);
    // if (!this.nodeset) {
    //   return;
    // }
    const target = evaluateXPathToFirstNode(this.with, this.nodeset, this);
    if (!target) return;
    this.replace(this.nodeset, target);
  }
  actionPerformed() {
    this.getModel().rebuild();
    super.actionPerformed();
  }
  replace(toReplace, replaceWith) {
    if (!toReplace || !replaceWith) return; // bail out silently
    if (!toReplace.nodeName || !replaceWith.nodeName) {
      console.warn('fx-replace: one argument is not a node');
      return;
    }
    if (toReplace.nodeType === Node.ATTRIBUTE_NODE) {
      const {
        ownerElement
      } = toReplace;
      ownerElement.setAttribute(replaceWith.nodeName, replaceWith.textContent);
      ownerElement.removeAttribute(toReplace.nodeName);
    } else if (toReplace.nodeType === Node.ELEMENT_NODE) {
      const cloned = replaceWith.cloneNode(true);
      toReplace.replaceWith(cloned);
    }
    // const modelitem = this.getModelItem();
    // this.getModel().changed.push(modelitem);
    this.needsUpdate = true;
  }
}
if (!customElements.get('fx-replace')) {
  window.customElements.define('fx-replace', FxReplace);
}

/**
 * `fx-return`
 * returns data from a nested Fore to it's host Fore.
 *
 * behaves like a `<fx-submission @replace='instance' with `targetref` and respects relevance processing.
 *
 * `targetref` will be the `ref` of the host control.
 *
 * todo: deos not relevant selection yet
 *
 * @customElement
 */
class FxReturn extends AbstractAction {
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    // const nonrelevant = this.hasAttribute('nonrelevant') ? this.getAttribute('nonrelevant') : null;
  }

  async perform() {
    super.perform();

    /*
    ### note that this event does not use Fore.dispatch as the event uses 'composed:true' to let the event travel
    up through the shadowRoot and being catched in outer form.
    */
    const event = new CustomEvent('return', {
      composed: true,
      bubbles: true,
      detail: {
        nodeset: this.nodeset
      }
    });
    this.getOwnerForm().dispatchEvent(event);
  }
}
if (!customElements.get('fx-return')) {
  window.customElements.define('fx-return', FxReturn);
}

/**
 * `fx-action`
 * an action to wrap other actions and defers the update cycle until the end of the block.
 *
 * @customElement
 * @demo demo/index.html
 */
class FxAction extends AbstractAction {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.src = this.hasAttribute('src') ? this.getAttribute('src') : null;
    const style = `
        :host{
            display:none;
        }
    `;
    this.shadowRoot.innerHTML = `
        <style>
            ${style}
        </style>
        <slot></slot>
    `;
  }
  async perform() {
    super.perform();
    const {
      children
    } = this;
    if (this.src) {
      this.innerHTML = ''; // reset
      const script = document.createElement('script');
      script.src = this.src;
      this.appendChild(script);
    } else {
      for (const actionOrVar of children) {
        if (actionOrVar.localName === 'fx-var') {
          continue;
        }
        const action = actionOrVar;
        action.detail = this.detail;
        await action.execute();
      }
      this.dispatchActionPerformed();
      this.needsUpdate = true;
    }
  }
}
if (!customElements.get('fx-action')) {
  window.customElements.define('fx-action', FxAction);
}

/**
 * `fx-confirm`
 * Displays a simple confirmation before actually executing the nested actions.
 *
 * @customElement
 * @demo demo/project.html
 */
class FxConfirm extends FxAction {
  static get properties() {
    return {
      ...FxAction.properties,
      message: {
        type: String
      }
    };
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.message = this.hasAttribute('message') ? this.getAttribute('message') : null;
  }
  async perform() {
    if (window.confirm(this.message)) {
      await super.perform();
    }
  }
}
if (!customElements.get('fx-confirm')) {
  window.customElements.define('fx-confirm', FxConfirm);
}

/**
 * `fx-show`
 * to show a `<dialog>` with given id.
 *
 *
 *
 * @customElement
 * @event fx-show dispatched when dialog is shown
 */
class FxShow extends FxAction {
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.dialog = this.getAttribute('dialog');
    if (!this.dialog) {
      Fore.dispatch(this, 'error', {
        message: 'dialog does not exist'
      });
    }
  }
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
    const targetDlg = resolveId(this.dialog, this);
    if (!targetDlg) {
      console.error('target dialog with given id does not exist', this.dialog);
    }
    targetDlg.showModal();
    Fore.dispatch(targetDlg, 'dialog-shown', {});
  }
}
if (!customElements.get('fx-show')) {
  window.customElements.define('fx-show', FxShow);
}

/**
 * `fx-hide`
 * hides a dialog
 *
 * @customElement
 * @demo demo/project.html
 */
class FxHide extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      dialog: {
        type: String
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.dialog = this.getAttribute('dialog');
    if (!this.dialog) {
      Fore.dispatch(this, 'error', {
        message: 'dialog does not exist'
      });
    }
  }
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
    const dialog = resolveId(this.dialog, this);
    dialog.close();
    Fore.dispatch(dialog, 'dialog-hidden', {});
  }
}
if (!customElements.get('fx-hide')) {
  window.customElements.define('fx-hide', FxHide);
}

/**
 * `fx-reload`
 * reloads browser window when receiving 'reload' event
 *
 * @event reload dispatched when action executes. Usually calls its own handler but might get cancelled by other handler.
 * @customElement
 * @demo demo/project.html
 */
class FxReload extends AbstractAction {
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this.addEventListener('reload', () => {
      window.location.reload();
    }, {
      once: true
    });
  }
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
    Fore.dispatch(this, 'reload', {});
  }
}
if (!customElements.get('fx-reload')) {
  window.customElements.define('fx-reload', FxReload);
}

/**
 * `fx-reset`
 * resets an instance to use inline template data
 *
 * @customElement
 * @demo demo/project.html
 */
class FxReset extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      instance: {
        type: String
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.instance = this.getAttribute('instance');
    if (!this.instance) {
      Fore.dispatch(this, 'error', {
        message: 'instance does not exist'
      });
    }
  }
  async perform() {
    this.dispatchEvent(new CustomEvent('execute-action', {
      composed: true,
      bubbles: true,
      cancelable: true,
      detail: {
        action: this,
        event: this.event
      }
    }));
    const model = this.getModel();
    const data = model.getInstance(this.instance);
    data.reset();
    this.needsUpdate = true;
  }
}
if (!customElements.get('fx-reset')) {
  window.customElements.define('fx-reset', FxReset);
}

/**
 * `fx-load`
 *
 * Action to load a window, tab or embed some Html into the current page at given location.
 *
 */
class FxLoad extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      attachTo: {
        type: String
      },
      url: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
    this.url = '';
    this.replace = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.attachTo = this.hasAttribute('attach-to') ? this.getAttribute('attach-to') : '_self';
    this.replace = this.hasAttribute('replace') ? true : false;
    // Add a 'doneEvent' to block the action chain untill the event fired on the element we're
    // loading something into.
    this.awaitEvent = this.hasAttribute('await') ? this.getAttribute('await') : '';
    this.url = this.hasAttribute('url') ? this.getAttribute('url') : '';
    const style = `
            :host{
                display:none;
            }
        `;
    this.shadowRoot.innerHTML = `
            <style>
                ${style}
            </style>
            ${this.renderHTML()}`;
  }
  disconnectedCallback() {
    // super.disconnectedCallback();
    this.targetElement.removeEventListener(this.event, e => this.execute(e));
  }

  // eslint-disable-next-line class-methods-use-this
  renderHTML() {
    return `
        <slot></slot>
    `;
  }
  async perform() {
    await super.perform();

    // this.getOwnerForm().evaluateTemplateExpression(this.urlContent, this);

    const template = this.querySelector('template');
    if (template) {
      const clone = template.content.cloneNode(true);
      const content = document.importNode(clone, true);
      // this._attachToElement(content);
      if (this.attachTo.startsWith('#')) {
        const targetId = this.attachTo.substring(1);
        const resolved = resolveId(targetId, this);
        // remove all children
        while (resolved.firstChild) {
          resolved.removeChild(resolved.firstChild);
        }
        if (this.awaitEvent) {
          let resolveEvent;
          const waitForEvent = new Promise(resolve => {
            resolveEvent = resolve;
          });
          const eventListener = () => {
            resolveEvent();
            resolved.removeEventListener(this.awaitEvent, eventListener);
          };
          if (this.replace) {
            this.parentNode.replaceChild(content, resolved);
          } else {
            resolved.appendChild(content);
          }
          resolved.addEventListener(this.awaitEvent, eventListener);
          await waitForEvent;
          this.needsUpdate = true;
          Fore.dispatch(this, 'loaded', {
            attachPoint: this.attachTo,
            content
          });
          return;
        }
        resolved.appendChild(content);
        this.needsUpdate = true;
      }
      Fore.dispatch(this, 'loaded', {});
      return;
    }
    if (!this.url) {
      // for authoring errors we log errors directly to DOM

      this.dispatchEvent(new CustomEvent('error', {
        composed: false,
        bubbles: true,
        cancelable: true,
        detail: {
          origin: this,
          message: 'neither template element nor Url was specified.',
          level: 'Error'
        }
      }));
      return;
    }
    const resolvedUrl = this.evaluateAttributeTemplateExpression(this.url, this);
    if (this.attachTo === '_blank') {
      window.open(this.url);
    }
    if (this.attachTo === '_self') {
      window.location.href = this.url;
    }
    try {
      const response = await fetch(resolvedUrl, {
        method: 'GET',
        mode: 'cors',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'text/html'
        }
      });
      const data = await response.text();
      // console.log('data loaded: ', data);
      // const data = Fore.loadHtml(resolvedUrl);

      // todo: if data contain '<template' element as first child instanciate and insert it
      if (!this.attachTo) {
        this.innerHtml = data;
      }
      this._attachToElement(data);
      Fore.dispatch(this, 'loaded', {
        url: this.url
      });
    } catch (error) {
      throw new Error(`failed loading data ${error}`);
    }
  }
  _attachToElement(content) {
    let effectiveContent;
    if (content.nodeType) {
      effectiveContent = content;
    } else {
      try {
        effectiveContent = new DOMParser().parseFromString(content, 'text/html').firstElementChild;
      } catch (e) {
        Fore.dispatch(this, 'error', {
          message: 'parsing of content as HTML failed'
        });
      }
    }
    if (!(this.attachTo.startsWith('_') || this.attachTo.startsWith('#'))) {
      Fore.dispatch(this, 'error', {
        message: 'valid values for "attach-to" start with "_" or "#"'
      });
    }
    if (this.attachTo.startsWith('#')) {
      const targetId = this.attachTo.substring(1);
      const resolved = resolveId(targetId, this);
      resolved.innerHTML = '';
      // resolved.innerHTML = effectiveContent;
      if (effectiveContent.querySelector('fx-fore')) {
        resolved.append(effectiveContent.querySelector('fx-fore').cloneNode(true));
        return;
      }
      const body = effectiveContent.querySelector('body').cloneNode(true);
      resolved.appendChild(body.firstElementChild);
    }
  }
  _evaluateUrlExpression() {
    const url = this.getAttribute('url');
    if (!url) {
      throw new Error('url not specified');
    }
    const replaced = url.replace(/{[^}]*}/g, match => {
      if (match === '{}') return match;
      const naked = match.substring(1, match.length - 1);
      const inscope = getInScopeContext(this, naked);
      if (!inscope) {
        console.warn('no inscope context for ', this);
        return match;
      }
      // Templates are special: they use the namespace configuration from the place where they are
      // being defined
      const instanceId = XPathUtil.getInstanceId(naked);

      // If there is an instance referred
      const inst = instanceId ? this.getModel().getInstance(instanceId) : this.getModel().getDefaultInstance();
      try {
        return evaluateXPathToString(naked, inscope, this, null, inst);
      } catch (error) {
        console.warn('ignoring unparseable url', error);
        return match;
      }
    });
    return replaced;
  }
}
if (!customElements.get('fx-load')) {
  window.customElements.define('fx-load', FxLoad);
}

// import { FxAction } from './fx-action.js';

/**
 * `fx-setvalue`
 *
 * @customElement
 */
class FxToggleboolean extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      ref: {
        type: String
      },
      valueAttr: {
        type: String
      },
      value: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.ref = '';
    this.valueAttr = '';
    this.value = false;
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.hasAttribute('ref')) {
      this.ref = this.getAttribute('ref');
    } else {
      throw new Error('fx-togglealue must specify a "ref" attribute');
    }
  }
  async perform() {
    super.perform();
    const mi = this.getModelItem();
    mi.value === 'true' ? mi.node.textContent = 'false' : mi.node.textContent = 'true';
    this.needsUpdate = true;
  }
}
if (!customElements.get('fx-toggleboolean')) {
  window.customElements.define('fx-toggleboolean', FxToggleboolean);
}

/**
 * `fx-call`
 *
 * @customElement
 */
class FxCall extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      action: {
        type: String
      },
      fn: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.action = '';
    this.fn = '';
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.hasAttribute('action')) {
      this.action = this.getAttribute('action');
    } else if (this.hasAttribute('function')) {
      this.fn = this.getAttribute('function');
    } else {
      throw new Error('fx-call must specify an "action" or "function" attribute');
    }
  }
  async perform() {
    super.perform();
    if (this.action) {
      await this._callAction();
    }
    // execute function
    if (this.fn) {
      this._callFunction();
    }
  }

  /**
   * find action and execute it
   */
  async _callAction() {
    /**
     * @type {import('./fx-action.js').FxAction}
     */
    const action = document.querySelector(`#${this.action}`);
    if (action) {
      await action.perform();
    } else {
      Fore.dispatch(this, 'error', {
        origin: this,
        message: `Action '${this.action}' not found`,
        expr: XPathUtil.getDocPath(this),
        level: 'Error'
      });
    }
  }
  _callFunction() {
    const inscope = getInScopeContext(this, 'instance()');
    evaluateXPath(this.fn, inscope, this);
  }
}
if (!customElements.get('fx-call')) {
  window.customElements.define('fx-call', FxCall);
}

// import { FxAction } from './fx-action.js';

/**
 * `fx-setattribute` allows to create and set an attribute value in the data.
 *
 * @customElement
 */
class FxSetattribute extends AbstractAction {
  static get properties() {
    return {
      ...super.properties,
      ref: {
        type: String
      },
      attrName: {
        type: String
      },
      attrValue: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.ref = '';
    this.attrName = '';
    this.attrValue = '';
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    if (this.hasAttribute('ref')) {
      this.ref = this.getAttribute('ref');
    } else {
      throw new Error('fx-setvalue must specify a "ref" attribute');
    }
    this.attrName = this.hasAttribute('name') ? this.getAttribute('name') : null;
    this.attrValue = this.hasAttribute('value') ? this.getAttribute('value') : '';
    if (!this.attrName) {
      Fore.dispatch('this', 'error', {
        message: 'name or value not specified'
      });
    }
  }
  async perform() {
    super.perform();
    const mi = this.getModelItem();
    if (mi.node.nodeType !== Node.ELEMENT_NODE) {
      Fore.dispatch('this', 'error', {
        message: 'referenced item is not an element'
      });
      return;
    }
    mi.node.setAttribute(this.attrName, this.attrValue);
    this.needsUpdate = true;
  }
}
if (!customElements.get('fx-setattribute')) {
  window.customElements.define('fx-setattribute', FxSetattribute);
}

/**
 * `fx-action`
 * an action to wrap other actions and defers the update cycle until the end of the block.
 *
 * @customElement
 * @demo demo/index.html
 */
class FxConstructDone extends FxAction {
  connectedCallback() {
    // eslint-disable-next-line wc/guard-super-call
    super.connectedCallback();
    console.log('parentNode', this.parentNode);
    if (this.parentNode.nodeName !== 'FX-MODEL') {
      Fore.dispatch(this, 'error', {
        message: 'parent is not a model'
      });
      return;
    }
    this.parentNode.addEventListener('model-construct-done', e => {
      super.perform();
    });
  }
}
if (!customElements.get('fx-construct-done')) {
  window.customElements.define('fx-construct-done', FxConstructDone);
}

/**
 * `fx-unmodified` Action to reset the 'modified' state of Fore. A Fore page is considered
 * modified when a 'value-changed' event has occurred. If the respective Fore element uses
 * `show-confirmation="true"` it will display a page exit confirmation in case the data
 * are modified. The `fx-unmodified` action allows to return to 'clean' state again avoiding
 * the dialog box after data have been saved and are considered unmodified again.
 *
 * Typically this action could be called on a `submit-done` event of a submission.
 *
 *
 * @customElement
 */
class FxUnmodified extends AbstractAction {
  constructor() {
    super();
  }
  async perform() {
    this.getOwnerForm().markAsClean();
  }
}
if (!customElements.get('fx-unmodified')) {
  window.customElements.define('fx-unmodified', FxUnmodified);
}

/**
 * This class finds and lists all elements with an 'on-demand' attribute and offers them
 * in a popup list for activation. 'on-demand' is not a state like 'relevant' but just
 * shows/hides controls on demand. The controls still behave as usual otherwise.
 *
 *
 */
class FxControlMenu extends AbstractControl {
  connectedCallback() {
    this.attachShadow({
      mode: 'open'
    });
    this.selectExpr = this.getAttribute('select');
    const style = `
      :host {
        display: inline-block;
        position: relative;
      }

      .menu {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        z-index: 10;
        background: white;
        border: 1px solid #ccc;
        padding: 0.5em;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        min-width: 10em;
        white-space:nowrap;
      }

      .menu.visible {
        display: block;
      }

      .menu a {
        display: block;
        padding: 0.25em 0.5em;
        text-decoration: none;
        color: black;
        cursor: pointer;
      }

      .menu a:hover {
        background-color: #eee;
      }
    `;
    this.shadowRoot.innerHTML = `
      <style>${style}</style>
      <slot></slot>
      <div class="menu" part="menu"></div>
    `;
    this.menuEl = this.shadowRoot.querySelector('.menu');

    // Slotted button click
    const slot = this.shadowRoot.querySelector('slot');
    slot.addEventListener('slotchange', () => {
      const nodes = slot.assignedNodes({
        flatten: true
      });
      const button = nodes.find(node => node.nodeType === Node.ELEMENT_NODE && node.tagName === 'BUTTON');
      if (button) {
        button.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
          this.updateMenu();
          this.menuEl.classList.toggle('visible');
        });
      }
    });

    // Update menu on custom event
    document.addEventListener('update-control-menu', () => {
      this.updateMenu();
    });

    // Close on outside click
    document.addEventListener('click', e => {
      const inside = this.contains(e.target) || this.shadowRoot.contains(e.target);
      if (!inside) {
        this.menuEl.classList.remove('visible');
      }
    });

    // Close on Escape
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        this.menuEl.classList.remove('visible');
      }
    });
    if (this.getAttribute('mode') === 'hide-on-empty') {
      this.getOwnerForm().addEventListener('ready', () => {
        const container = document.querySelector(this.selectExpr);
        if (!container) return;
        const widgets = container.querySelectorAll('.widget');
        widgets.forEach(widget => {
          const value = widget.value?.trim();
          const control = widget.closest('fx-control');
          if (control && (value === '' || value == null)) {
            control.setAttribute('on-demand', 'true');
          }
        });

        // After marking empty controls, update the menu
        this.updateMenu();
      });
    }
    const container = document.querySelector(this.selectExpr);
    container?.addEventListener('show-control', event => {
      this.updateMenu();
    });
    this.updateMenu();
  }
  updateMenu() {
    const container = document.querySelector(this.selectExpr);
    if (!container) return;
    let targets = [];
    if (container.hasAttribute('on-demand')) {
      if (container.nodeName === 'FX-REPEAT') {
        // If it's an <fx-repeat> with on-demand, use only the container
        targets = [container];
      } else {
        // If it's not <fx-repeat>, include container and inner [on-demand] targets
        targets = [container, ...container.querySelectorAll('[on-demand]')];
      }
    } else {
      // If container is not on-demand, only look for inner [on-demand]
      targets = Array.from(container.querySelectorAll('[on-demand]'));
    }
    this._currentTargets = targets;
    this.menuEl.innerHTML = ''; // Clear menu

    // Find the slotted button
    const slot = this.shadowRoot.querySelector('slot');
    const assignedNodes = slot.assignedNodes({
      flatten: true
    });
    const button = assignedNodes.find(node => node.nodeType === Node.ELEMENT_NODE && node.tagName === 'BUTTON');
    if (button) {
      button.disabled = targets.length === 0;
    }
    if (targets.length === 0) {
      this.menuEl.classList.remove('visible');
      return;
    }
    targets.forEach((el, index) => {
      let label = el.getAttribute('aria-label');
      if (!label) {
        label = el.querySelector('label')?.textContent.trim() || `Item ${index + 1}`;
      }
      if (!label) {
        console.warn('no label found - cannot create menu entry for ', el, ' - please add aria-label or label element to control');
      }
      const item = document.createElement('a');
      item.href = '#';
      item.textContent = label;
      item.addEventListener('click', e => {
        e.preventDefault();
        if (typeof el.activate === 'function') {
          el.activate();
        }
        this.menuEl.classList.remove('visible');

        // Wait one frame to let DOM updates (like on-demand removal) take effect
        requestAnimationFrame(() => {
          this.updateMenu();
        });
      });
      this.menuEl.appendChild(item);
    });
  }
}
if (!customElements.get('fx-control-menu')) {
  customElements.define('fx-control-menu', FxControlMenu);
}

/**
 * @param functionObject {{signature: string, type: string|null, functionBody: string}}
 * @param formElement {HTMLElement} The form element connected to this function. Used to determine inscope context
 * @returns {undefined}
 */
function registerFunction(functionObject, formElement) {
  if (functionObject.signature === null) {
    console.error('signature is a required attribute');
  }
  const type = functionObject.type ?? 'text/xpath';

  // Parse the signature to something useful
  // Signature is of the form `my:sumproduct($p as xs:decimal*, $q as xs:decimal*) as xs:decimal` or local:something($a as item()*) as item()*
  const signatureParseResult = functionObject.signature.match(/(?:(?<prefix>[a-zA-Z_\-][a-zA-Z0-9_\-]*):)?(?<localName>[a-zA-Z_\-][a-zA-Z0-9_\-]*\s*)\((?<params>(?:[^()]*|\([^()]*\))*)\)\s*(?:as\s+(?<returnType>.*))?/);
  if (!signatureParseResult) {
    throw new Error(`Function signature ${functionObject.signature} could not be parsed`);
  }
  const {
    prefix,
    localName,
    params,
    returnType
  } = signatureParseResult.groups;

  // TODO: lookup prefix
  const functionIdentifier = prefix === 'local' || !prefix ? {
    namespaceURI: 'http://www.w3.org/2005/xquery-local-functions',
    localName
  } : `${prefix}:${localName}`;

  // Make the function available globally w/o a prefix. See the functionNameResolver for for how
  // functionObject is picked up
  if (!prefix) {
    globallyDeclaredFunctionLocalNames.push(localName);
  }
  const paramParts = params ? params.split(',').map(param => {
    const match = param.match(/(?<variableName>\$[^\s]+)(?:\sas\s(?<varType>[^\s]+))/);
    if (!match) {
      throw new Error(`Param ${param} could not be parsed`);
    }
    const {
      variableName,
      varType
    } = match.groups;
    return {
      variableName,
      variableType: varType || 'item()*'
    };
  }) : [];
  switch (type) {
    case 'text/javascript':
      {
        // eslint-disable-next-line no-new-func
        const fun = new Function('_domFacade', ...paramParts.map(paramPart => paramPart.variableName), 'form', functionObject.functionBody);
        registerCustomXPathFunction(functionIdentifier, paramParts.map(paramPart => paramPart.variableType), returnType || 'item()*', (...args) => fun.apply(formElement.getInScopeContext(), [...args, formElement.getOwnerForm()]));
        break;
      }
    case 'text/xquf':
    case 'text/xquery':
    case 'text/xpath':
      {
        const typedValueFactories = paramParts.map(param => createTypedValueFactory(param.variableType));
        const language = type === 'text/xpath' ? 'XPath3.1' : type === 'text/xquery' ? 'XQuery3.1' : 'XQueryUpdate3.1';
        const fun = (domFacade, ...args) => evaluateXPath(functionObject.functionBody, formElement.getInScopeContext(), formElement.getOwnerForm(), paramParts.reduce((variablesByName, paramPart, i) => {
          // Because we know the XPath type here (from the function declaration) we do not have to depend on the implicit typings
          variablesByName[paramPart.variableName.replace('$', '')] = typedValueFactories[i](args[i], domFacade);
          return variablesByName;
        }, {}), {
          language
        });
        registerCustomXPathFunction(functionIdentifier, paramParts.map(paramPart => paramPart.variableType), returnType || 'item()*', fun);
        break;
      }
    default:
      throw new Error(`Unexpected mimetype ${type} for function`);
  }
}

/**
 * Allows to extend a form with local custom functions.
 */
class FxFunction extends ForeElementMixin {
  constructor() {
    super();
    this.attachShadow({
      mode: 'open'
    });
  }
  connectedCallback() {
    this.style.display = 'none';
    this.signature = this.hasAttribute('signature') ? this.getAttribute('signature') : null;
    this.type = this.hasAttribute('type') ? this.getAttribute('type') : null;
    this.shadowRoot.innerHTML = '<slot></slot>';
    this.override = this.hasAttribute('override') ? this.getAttribute('override') : 'true';
    this.functionBody = this.innerText;
    registerFunction(this, this);
  }
}
if (!customElements.get('fx-function')) {
  customElements.define('fx-function', FxFunction);
}

/**
 * Allows to extend a form with remote custom functions.
 *
 */
class FxFunctionlib extends ForeElementMixin {
  constructor() {
    super();

    /**
     * @type {Function}
     */
    this._resolve = null;

    /**
     * @type {Promise<undefined>}
     */
    this.readyPromise = new Promise(resolve => this._resolveLoading = resolve);
  }
  async connectedCallback() {
    this.style.display = 'none';
    const src = this.getAttribute('src');
    const result = await fetch(src);
    if (!result.ok) {
      console.error(`Loading function library at ${src} failed.`);
    }
    const body = await result.text();
    const document = new DOMParser().parseFromString(body, 'text/html');

    /**
     * @type {HTMLElement[]}
     */
    const functions = Array.from(document.querySelectorAll('fx-function'));
    // TODO: also recurse into new function libraries here?
    for (const func of functions) {
      const functionObject = {
        type: func.getAttribute('type'),
        signature: func.getAttribute('signature'),
        functionBody: func.innerText
      };
      registerFunction(functionObject, this);
    }
    this._resolveLoading(undefined);
  }
}
if (!customElements.get('fx-functionlib')) {
  customElements.define('fx-functionlib', FxFunctionlib);
}
